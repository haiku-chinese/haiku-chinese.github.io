<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

<!-- Mirrored from www.haiku-os.org/docs/api/group__midi2.html by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 05 Aug 2021 01:48:00 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- /Added by HTTrack -->
<head>
	<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
	<meta http-equiv="X-UA-Compatible" content="IE=9"/>
	<meta name="generator" content="Doxygen 1.8.16"/>
	<meta name="viewport" content="width=device-width, initial-scale=1"/>
	<title>The Haiku Book: MIDI 2 Kit</title>
	<link href="tabs.css" rel="stylesheet" type="text/css"/>
	<script type="text/javascript" src="jquery.js"></script>
	<script type="text/javascript" src="dynsections.js"></script>
	<link href="doxygen.css" rel="stylesheet" type="text/css" />
	<link href="book.css" rel="stylesheet" type="text/css"/>
	</head>
<body>
	<div id="banner">
		<div class="logo">
			<span class="subtitle">
				API Documentation
			</span>
			<span class="search">
				<input type="text" placeholder="Search" onkeydown="search(this,event);">
			</span>
		</div>
	</div>
	<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- Generated by Doxygen 1.8.16 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.html','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#files">Files</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#enum-members">Enumerations</a>  </div>
  <div class="headertitle">
<div class="title">MIDI 2 Kit</div>  </div>
</div><!--header-->
<div class="contents">

<p>The Midi Kit is the API that implements support for generating, processing, and playing music in MIDI format.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="files"></a>
Files</h2></td></tr>
<tr class="memitem:Midi2Defs_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="Midi2Defs_8h.html">Midi2Defs.h</a></td></tr>
<tr class="memdesc:Midi2Defs_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Some definitions to define raw MIDI events. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:MidiConsumer_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="MidiConsumer_8h.html">MidiConsumer.h</a></td></tr>
<tr class="memdesc:MidiConsumer_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines consumer classes for the MIDI Kit. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:MidiEndpoint_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="MidiEndpoint_8h.html">MidiEndpoint.h</a></td></tr>
<tr class="memdesc:MidiEndpoint_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the Baseclass of all MIDI consumers and producers. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:MidiProducer_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="MidiProducer_8h.html">MidiProducer.h</a></td></tr>
<tr class="memdesc:MidiProducer_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines producer classes for the MIDI Kit. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:MidiRoster_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="MidiRoster_8h.html">MidiRoster.h</a></td></tr>
<tr class="memdesc:MidiRoster_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the heart of the MIDI Kit: the MIDI Roster. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBMidiConsumer.html">BMidiConsumer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receives MIDI events from a producer.  <a href="classBMidiConsumer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBMidiEndpoint.html">BMidiEndpoint</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for all MIDI endpoints.  <a href="classBMidiEndpoint.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBMidiLocalConsumer.html">BMidiLocalConsumer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A consumer endpoint that is created by your own application.  <a href="classBMidiLocalConsumer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBMidiLocalProducer.html">BMidiLocalProducer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A producer endpoint that is created by your own application.  <a href="classBMidiLocalProducer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBMidiProducer.html">BMidiProducer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Streams MIDI events to connected consumers.  <a href="classBMidiProducer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBMidiRoster.html">BMidiRoster</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface to the system-wide Midi Roster.  <a href="classBMidiRoster.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga3a12937359d4054aea34afe1e1049452"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__midi2.html#ga3a12937359d4054aea34afe1e1049452">BMidiOp</a> </td></tr>
<tr class="memdesc:ga3a12937359d4054aea34afe1e1049452"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the status codes for MIDI Server notification messages.  <a href="group__midi2.html#ga3a12937359d4054aea34afe1e1049452">More...</a><br /></td></tr>
<tr class="separator:ga3a12937359d4054aea34afe1e1049452"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>The Midi Kit is the API that implements support for generating, processing, and playing music in MIDI format. </p>
<p><a href="https://www.midi.org/">MIDI</a>, which stands for 'Musical Instrument Digital Interface', is a well-established standard for representing and communicating musical data. This document serves as an overview. If you would like to see all the components, please look at <a class="el" href="group__midi2.html">the list with classes </a>.</p>
<h1><a class="anchor" id="book_midi2twokits"></a>
A Tale of Two MIDI Kits</h1>
<p>BeOS comes with two different, but compatible Midi Kits. This documentation focuses on the "new" Midi Kit, or midi2 as we like to call it, that was introduced with BeOS R5. The old kit, which we'll refer to as midi1, is more complete than the new kit, but less powerful.</p>
<p>Both kits let you create so-called MIDI endpoints, but the endpoints from midi1 cannot be shared between different applications. The midi2 kit solves that problem, but unlike midi1 it does not include a General MIDI softsynth, nor does it have a facility for reading and playing Standard MIDI Files. Don't worry: both kits are compatible and you can mix-and-match them in your applications.</p>
<p>The main differences between the two kits:</p><ul>
<li>Instead of one BMidi object that both produces and consumes events, we have <a class="el" href="classBMidiProducer.html" title="Streams MIDI events to connected consumers.">BMidiProducer</a> and <a class="el" href="classBMidiConsumer.html" title="Receives MIDI events from a producer.">BMidiConsumer</a>.</li>
<li>Applications are capable of sharing MIDI producers and consumers with other applications via the centralized Midi Roster.</li>
<li>Physical MIDI ports are now sharable without apps "stealing" events from each other.</li>
<li>Applications can now send/receive raw MIDI byte streams (useful if an application has its own MIDI parser/engine).</li>
<li>Channels are numbered 0&ndash;15, not 1&ndash;16</li>
<li>Timing is now specified in microseconds rather than milliseconds.</li>
</ul>
<h1><a class="anchor" id="book_midi2concepts"></a>
Midi Kit Concepts</h1>
<p>A brief overview of the elements that comprise the Midi Kit:</p><ul>
<li><b>Endpoints</b>. This is what the Midi Kit is all about: sending MIDI messages between endpoints. An endpoint is like a MIDI In or MIDI Out socket on your equipment; it either receives information or it sends information. Endpoints that send MIDI events are called <b>producers</b>; the endpoints that receive those events are called <b>consumers</b>. An endpoint that is created by your own application is called <b>local</b>; endpoints from other applications are <b>remote</b>. You can access remote endpoints using <b>proxies</b>.</li>
<li><b>Filters</b>. A filter is an object that has a consumer and a producer endpoint. It reads incoming events from its consumer, performs some operation, and tells its producer to send out the results. In its current form, the Midi Kit doesn't provide any special facilities for writing filters.</li>
<li><b>Midi</b> <b>Roster</b>. The roster is the list of all published producers and consumers. By publishing an endpoint, you allow other applications to talk to it. You are not required to publish your endpoints, in which case only your own application can use them.</li>
<li><b>Midi</b> <b>Server</b>. The Midi Server does the behind-the-scenes work. It manages the roster, it connects endpoints, it makes sure that endpoints can communicate, and so on. The Midi Server is started automatically when BeOS boots, and you never have to deal with it directly. Just remember that it runs the show.</li>
<li><b>libmidi</b>. The BMidi* classes live inside two shared libraries: libmidi.so and libmidi2.so. If you write an application that uses old Midi Kit, you must link it to libmidi.so. Applications that use the new Midi Kit must link to libmidi2.so. If you want to mix-and-match both kits, you should also link to both libraries.</li>
</ul>
<p>Here is a pretty picture:</p>
<div class="image">
<img src="midi2concepts.png" alt=""/>
</div>
<h1><a class="anchor" id="book_midi2mediakit"></a>
Midi Kit != Media Kit</h1>
<p>Be chose not to integrate the Midi Kit into the Media Kit as another media type, mainly because MIDI doesn't require any of the format negotiation that other media types need. Although the two kits look similar &ndash; both have a "roster" for finding or registering "consumers" and "producers" &ndash; there are some very important differences.</p>
<p>The first and most important point to note is that <a class="el" href="classBMidiConsumer.html" title="Receives MIDI events from a producer.">BMidiConsumer</a> and <a class="el" href="classBMidiProducer.html" title="Streams MIDI events to connected consumers.">BMidiProducer</a> in the Midi Kit are <b>NOT</b> directly analogous to BBufferConsumer and BBufferProducer in the Media Kit! In the Media Kit, consumers and producers are the data consuming and producing properties of a media node. A filter in the Media Kit, therefore, inherits from both BBufferConsumer and BBufferProducer, and implements their virtual member functions to do its work.</p>
<p>In the Midi Kit, consumers and producers act as endpoints of MIDI data connections, much as media_source and media_destination do in the Media Kit. Thus, a MIDI filter does not derive from <a class="el" href="classBMidiConsumer.html" title="Receives MIDI events from a producer.">BMidiConsumer</a> and <a class="el" href="classBMidiProducer.html" title="Streams MIDI events to connected consumers.">BMidiProducer</a>; instead, it contains <a class="el" href="classBMidiConsumer.html" title="Receives MIDI events from a producer.">BMidiConsumer</a> and <a class="el" href="classBMidiProducer.html" title="Streams MIDI events to connected consumers.">BMidiProducer</a> objects for each of its distinct endpoints that connect to other MIDI objects. The Midi Kit does not allow the use of multiple virtual inheritance, so you can't create an object that's both a <a class="el" href="classBMidiConsumer.html" title="Receives MIDI events from a producer.">BMidiConsumer</a> and a <a class="el" href="classBMidiProducer.html" title="Streams MIDI events to connected consumers.">BMidiProducer</a>.</p>
<p>This also contrasts with the old Midi Kit's conception of a BMidi object, which stood for an object that both received and sent MIDI data. In the new Midi Kit, the endpoints of MIDI connections are all that matters. What lies between the endpoints, i.e. how a MIDI filter is actually structured, is entirely at your discretion.</p>
<p>Also, rather than use token structs like media_node to make connections via the MediaRoster, the new kit makes the connections directly via the <a class="el" href="classBMidiProducer.html" title="Streams MIDI events to connected consumers.">BMidiProducer</a> object.</p>
<h1><a class="anchor" id="book_midi2remotelocal"></a>
Remote vs. Local Objects</h1>
<p>The Midi Kit makes a distinction between remote and local MIDI objects. You can only create local MIDI endpoints, which derive from either <a class="el" href="classBMidiLocalConsumer.html" title="A consumer endpoint that is created by your own application.">BMidiLocalConsumer</a> or <a class="el" href="classBMidiLocalProducer.html" title="A producer endpoint that is created by your own application.">BMidiLocalProducer</a>. Remote endpoints are endpoints that live in other applications, and you access them through <a class="el" href="classBMidiRoster.html" title="Interface to the system-wide Midi Roster.">BMidiRoster</a>.</p>
<p><a class="el" href="classBMidiRoster.html" title="Interface to the system-wide Midi Roster.">BMidiRoster</a> only gives you access to BMidiEndpoints, BMidiConsumers, and BMidiProducers. When you want to talk to remote MIDI objects, you do so through the proxy objects that <a class="el" href="classBMidiRoster.html" title="Interface to the system-wide Midi Roster.">BMidiRoster</a> provides. Unlike <a class="el" href="classBMidiLocalConsumer.html" title="A consumer endpoint that is created by your own application.">BMidiLocalConsumer</a> and <a class="el" href="classBMidiLocalProducer.html" title="A producer endpoint that is created by your own application.">BMidiLocalProducer</a>, these classes do not provide a lot of functions. That is intentional. In order to hide the details of communication with MIDI endpoints in other applications, the Midi Kit must hide the details of how a particular endpoint is implemented.</p>
<p>So what can you do with remote objects? Only what <a class="el" href="classBMidiConsumer.html" title="Receives MIDI events from a producer.">BMidiConsumer</a>, <a class="el" href="classBMidiProducer.html" title="Streams MIDI events to connected consumers.">BMidiProducer</a>, and <a class="el" href="classBMidiEndpoint.html" title="Base class for all MIDI endpoints.">BMidiEndpoint</a> will let you do. You can connect objects, get the properties of these objects &ndash; and that's about it.</p>
<h1><a class="anchor" id="book_midi2lifespan"></a>
Creating and Destroying Objects</h1>
<p>The constructors and destructors of most midi2 classes are private, which means that you cannot directly create them using the C++ <code>new</code> operator, on the stack, or as globals. Nor can you <code>delete</code> them. Instead, these objects are obtained through <a class="el" href="classBMidiRoster.html" title="Interface to the system-wide Midi Roster.">BMidiRoster</a>. The only two exceptions to this rule are <a class="el" href="classBMidiLocalConsumer.html" title="A consumer endpoint that is created by your own application.">BMidiLocalConsumer</a> and <a class="el" href="classBMidiLocalProducer.html" title="A producer endpoint that is created by your own application.">BMidiLocalProducer</a>. These two objects may be directly created and subclassed by developers.</p>
<h1><a class="anchor" id="book_midi2refcount"></a>
Reference Counting</h1>
<p>Each MIDI endpoint has a reference count associated with it, so that the Midi Roster can do proper bookkeeping. When you construct a <a class="el" href="classBMidiLocalProducer.html" title="A producer endpoint that is created by your own application.">BMidiLocalProducer</a> or <a class="el" href="classBMidiLocalConsumer.html" title="A consumer endpoint that is created by your own application.">BMidiLocalConsumer</a> endpoint, it starts with a reference count of 1. In addition, <a class="el" href="classBMidiRoster.html" title="Interface to the system-wide Midi Roster.">BMidiRoster</a> increments the reference count of any object it hands to you as a result of <a class="el" href="classBMidiRoster.html#afbf8efb9cfac2ac8f16c7a399f23039b">NextEndpoint() </a> or <a class="el" href="classBMidiRoster.html#aa093ac8e2baf81b1fbaa3cdadf4adeab">FindEndpoint() </a>. Once the count hits 0, the endpoint will be deleted.</p>
<p>This means that, to delete an endpoint, you don't call the <code>delete</code> operator directly; instead, you call <a class="el" href="classBMidiEndpoint.html#a368ed2bdb2b76afe1466daf0cc0e2b08">Release() </a>. To balance this call, there's also an <a class="el" href="classBMidiEndpoint.html#a504efce89310e4473c4a9ae77da7a641">Acquire() </a>, in case you have two disparate parts of your application working with the endpoint, and you don't want to have to keep track of who needs to Release() the endpoint.</p>
<p>When you're done with any endpoint object, you must Release() it. This is true for both local and remote objects. Repeat after me: Release() when you're done.</p>
<h1><a class="anchor" id="book_midi2events"></a>
MIDI Events</h1>
<p>To make some actual music, you need to <a class="el" href="classBMidiProducer.html#ae1fe6a25736a3f8eb154158429fc224a">Connect() </a> your consumers to your producers. Then you tell the producer to "spray" MIDI events to all the connected consumers. The consumers are notified of these incoming events through a set of hook functions.</p>
<p>The Midi Kit already provides a set of commonly used spray functions, such as <a class="el" href="classBMidiLocalProducer.html#ae894fdb7f04b2c65329720592cb525dd">SprayNoteOn() </a>, <a class="el" href="classBMidiLocalProducer.html#a25e58f5d855eadfebd50d8ac5e9db423">SprayControlChange() </a>, and so on. These correspond one-to-one with the message types from the MIDI spec. You don't need to be a MIDI expert to use the kit, but of course some knowledge of the protocol helps. If you are really hardcore, you can also use the <a class="el" href="classBMidiLocalProducer.html#ae8cabda990298dbb11a3c4d70edcb047">SprayData() </a> to send raw MIDI events to the consumers.</p>
<p>At the consumer side, a dedicated thread invokes a hook function for every incoming MIDI event. For every spray function, there is a corresponding hook function, e.g. <a class="el" href="classBMidiLocalConsumer.html#af8986251fbb08548712e0273c13dd87e">NoteOn() </a> and <a class="el" href="classBMidiLocalConsumer.html#a48ae4c29a7044c1f53fa2901f0aad548">ControlChange() </a>. The hardcore MIDI fanatics among you will be pleased to know that you can also tap into the <a class="el" href="classBMidiLocalConsumer.html#a4b99be774374a9098cdb7535baef51bb">Data() </a> hook and get your hands dirty with the raw MIDI data.</p>
<h1><a class="anchor" id="book_midi2time"></a>
Time</h1>
<p>The spray and hook functions accept a bigtime_t parameter named "time". This indicates when the MIDI event should be performed. The time is given in microseconds since the computer booted. To get the current tick measurement, you call the system_time() function from the Kernel Kit.</p>
<p>If you override a hook function in one of your consumer objects, it should look at the time argument, wait until the designated time, and then perform its action. The preferred method is to use the Kernel Kit's <code>snooze_until()</code> function, which sends the consumer thread to sleep until the requested time has come. (Or, if the time has already passed, returns immediately.)</p>
<p>Like this:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> MyConsumer::NoteOn(</div>
<div class="line">    <a class="code" href="SupportDefs_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> channel, <a class="code" href="SupportDefs_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> note, <a class="code" href="SupportDefs_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a> velocity, <a class="code" href="SupportDefs_8h.html#a29bb8e432e460af113ef8938cef96f8b">bigtime_t</a> time)</div>
<div class="line">{</div>
<div class="line">    snooze_until(time, B_SYSTEM_TIMEBASE);</div>
<div class="line">    ...do your thing...</div>
<div class="line">}</div>
</div><!-- fragment --><p>If you want your producers to run in real time, i.e. they produce MIDI data that needs to be performed immediately, you should pass time 0 to the spray functions (which also happens to be the default value). Since time 0 has already passed, <code>snooze_until()</code> returns immediately, and the consumer will process the events as soon as they are received.</p>
<p>To schedule MIDI events for a performance time that lies somewhere in the future, the producer must take into account the consumer's latency. Producers should attempt to get notes to the consumer by or before <em>(scheduled_performance_time - latency)</em>. The time argument is still the scheduled performance time, so if your consumer has latency, it should snooze like this before it starts to perform the events:</p>
<div class="fragment"><div class="line">snooze_until(time - Latency(), B_SYSTEM_TIMEBASE);</div>
</div><!-- fragment --><p>Note that a typical producer sends out its events as soon as it can; unlike a consumer, it does not have to snooze.</p>
<h1><a class="anchor" id="book_midi2ports"></a>
Other Timing Issues</h1>
<p>Each consumer object uses a Kernel Kit port to receive MIDI events from connected producers. The queue for this port is only 1 message deep. This means that if the consumer thread is asleep in a <code>snooze_until()</code>, it will not read its port. Consequently, any producer that tries to write a new event to this port will block until the consumer thread is ready to receive a new message. This is intentional, because it prevents producers from generating and queueing up thousands of events.</p>
<p>This mechanism, while simple, puts on the producer the responsibility for sorting the events in time. Suppose your producer sends three Note On events, the first on t + 0, the second on t + 4, and the third on t + 2. This last event won't be received until after t + 4, so it will be two ticks too late. If this sort of thing can happen with your producer, you should somehow sort the events before you spray them. Of course, if you have two or more producers connected to the same consumer, it is nearly impossible to sort this all out (pardon the pun). So it is not wise to send the same kinds of events from more than one producer to one consumer at the same time.</p>
<p>The article Introduction to MIDI, Part 2 in <a href="https://open-beos.sourceforge.net/nsl.php?mode=display&amp;id=36">OpenBeOS Newsletter 36</a> describes this problem in more detail, and provides a solution. Go read it now!</p>
<h1><a class="anchor" id="book_midi2filters"></a>
Writing a Filter</h1>
<p>A typical filter contains a consumer and a producer endpoint. It receives events from the consumer, processes them, and sends them out again using the producer. The consumer endpoint is a subclass of <a class="el" href="classBMidiLocalConsumer.html" title="A consumer endpoint that is created by your own application.">BMidiLocalConsumer</a>, whereas the producer is simply a <a class="el" href="classBMidiLocalProducer.html" title="A producer endpoint that is created by your own application.">BMidiLocalProducer</a>, not a subclass. This is a common configuration, because consumers work by overriding the event hooks to do work when MIDI data arrives. Producers work by sending an event when you call their member functions. You should hardly ever need to derive from <a class="el" href="classBMidiLocalProducer.html" title="A producer endpoint that is created by your own application.">BMidiLocalProducer</a> (unless you need to know when the producer gets connected or disconnected, perhaps), but you'll always have to override one or more of <a class="el" href="classBMidiLocalConsumer.html" title="A consumer endpoint that is created by your own application.">BMidiLocalConsumer</a>'s member functions to do something useful with incoming data.</p>
<p>Filters should ignore the time argument from the spray and hook functions, and simply pass it on unchanged. Objects that only filter data should process the event as quickly as possible and be done with it. Do not <code>snooze_until()</code> in the consumer endpoint of a filter!</p>
<h1><a class="anchor" id="book_midi2apidiffs"></a>
API Differences</h1>
<p>As far as the end user is concerned, the Haiku Midi Kit is mostly the same as the BeOS R5 kits, although there are a few small differences in the API (mostly bug fixes):</p><ul>
<li><a class="el" href="classBMidiEndpoint.html#a20623d6d71190a701e9bccc23e646e6a" title="Not used.">BMidiEndpoint::IsPersistent()</a> always returns false.</li>
<li>The B_MIDI_CHANGE_LATENCY notification is now properly sent. The Be kit incorrectly set be:op to B_MIDI_CHANGED_NAME, even though the rest of the message was properly structured.</li>
<li>If creating a local endpoint fails, you can still Release() the object without crashing into the debugger.</li>
</ul>
<h1><a class="anchor" id="book_midi2seealso"></a>
See also</h1>
<p>More about the Midi Kit:</p><ul>
<li><a class="el" href="Midi2Defs_8h.html">Midi2Defs.h</a></li>
<li>Be Newsletter Volume 3, Issue 47 - Motor Mix sample code</li>
<li>Be Newsletter Volume 4, Issue 3 - Overview of the new kit</li>
<li><a href="https://haiku-os.org/documents/dev/introduction_to_midi_part_1">Newsletter 33</a>, Introduction to MIDI, Part 1</li>
<li><a href="https://haiku-os.org/documents/dev/introduction_to_midi_part_2">Newsletter 36</a>, Introduction to MIDI, Part 2</li>
<li>Sample code and other goodies at the <a href="https://haiku-os.org/about/teams/midi_kit">Haiku Midi Kit team page</a></li>
</ul>
<p>Information about MIDI in general:</p><ul>
<li><a href="https://www.midi.org/">MIDI Manufacturers Association</a></li>
<li><a href="https://www.borg.com/~jglatt/tutr/miditutr.htm">MIDI Tutorials</a></li>
<li><a href="https://www.borg.com/~jglatt/tech/midispec.htm">MIDI Specification</a></li>
<li><a href="https://www.borg.com/~jglatt/tech/midifile.htm">Standard MIDI File Format</a></li>
<li><a href="https://www.io.com/~jimm/midi_ref.html">Jim Menard's MIDI Reference</a></li>
</ul>
<p>Please have a look at the <a class="el" href="midi2_intro.html">introduction </a> for a more comprehensive overview on how everything ties together. </p>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ga3a12937359d4054aea34afe1e1049452"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3a12937359d4054aea34afe1e1049452">&#9670;&nbsp;</a></span>BMidiOp</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__midi2.html#ga3a12937359d4054aea34afe1e1049452">BMidiOp</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Defines the status codes for MIDI Server notification messages. </p>
<p>These codes are used when you request notification as in <a class="el" href="classBMidiRoster.html#afe537ff3a6fc157e07436e7f62163622" title="Start receiving notifications from the Midi Roster.">BMidiRoster::StartWatching()</a>. Check against these codes to determine what is happening. See the StartWatching() method for a more complete description of the codes and their meaning. </p>

</div>
</div>
</div><!-- contents -->
<div class="ttc" id="aSupportDefs_8h_html_a29bb8e432e460af113ef8938cef96f8b"><div class="ttname"><a href="SupportDefs_8h.html#a29bb8e432e460af113ef8938cef96f8b">bigtime_t</a></div><div class="ttdeci">int64 bigtime_t</div><div class="ttdoc">Represents time in microseconds.</div><div class="ttdef"><b>Definition:</b> SupportDefs.h:53</div></div>
<div class="ttc" id="aSupportDefs_8h_html_a65f85814a8290f9797005d3b28e7e5fc"><div class="ttname"><a href="SupportDefs_8h.html#a65f85814a8290f9797005d3b28e7e5fc">uchar</a></div><div class="ttdeci">unsigned char uchar</div><div class="ttdoc">Unsigned 1-byte wide character.</div><div class="ttdef"><b>Definition:</b> SupportDefs.h:49</div></div>
<!-- start footer part -->
  <hr class="footer"/><address class="footer"><small>
    The Haiku Book pre-R1 - MIDI 2 Kit<br />
    Generated on Wed Aug 4 2021 13:07:57 by <a href="http://www.doxygen.org/index.html">Doxygen</a> 1.8.16
  </small></address>
<!-- Fathom -->
<script>
(function(f, a, t, h, o, m){
	a[h]=a[h]||function(){
		(a[h].q=a[h].q||[]).push(arguments)
	};
	o=f.createElement('script'),
	m=f.getElementsByTagName('script')[0];
	o.async=1; o.src=t; o.id='fathom-script';
	m.parentNode.insertBefore(o,m)
})(document, window, '../../../metrics.haiku-os.org/tracker.js', 'fathom');
fathom('trackPageview');
</script>
<!-- / Fathom --></body>

<!-- Mirrored from www.haiku-os.org/docs/api/group__midi2.html by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 05 Aug 2021 01:48:15 GMT -->
</html>