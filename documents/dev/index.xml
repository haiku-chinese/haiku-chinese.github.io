<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Developer Documents on Haiku Project</title><link>https://www.haiku-os.org/documents/dev/</link><description>Recent content in Developer Documents on Haiku Project</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>2001-2021 Haiku Inc.</copyright><lastBuildDate>Wed, 11 Oct 2006 03:25:25 +0000</lastBuildDate><atom:link href="https://www.haiku-os.org/documents/dev/index.xml" rel="self" type="application/rss+xml"/><item><title>Building Haiku on Ubuntu Linux, Step by Step</title><link>https://www.haiku-os.org/documents/dev/building_haiku_ubuntu_linux_step_step/</link><pubDate>Tue, 05 Mar 2019 11:19:23 +0000</pubDate><guid>https://www.haiku-os.org/documents/dev/building_haiku_ubuntu_linux_step_step/</guid><description>Architecture To check whether your target architecture is support visit Port status.
Pre-requisite Software You need some tools in order to build Haiku. See Pre-requisite software and install the tools mentioned there.
Getting the Source Code To download Haiku&amp;rsquo;s source anonymously, enter
git clone https://review.haiku-os.org/buildtools #needed for building git clone https://review.haiku-os.org/haiku #actual source If you&amp;rsquo;d like to learn more about downloading through git and git workflow, visit Getting the source code.</description></item><item><title>System calls</title><link>https://www.haiku-os.org/documents/dev/system_calls/</link><pubDate>Tue, 09 Dec 2008 20:52:25 +0000</pubDate><guid>https://www.haiku-os.org/documents/dev/system_calls/</guid><description>This paper presents the implementation of system calls in haiku, and especially on x86 systems. The system call mechanism is what allows user land code to communicate with kernel land code. The whole paper is focused on the example of one system call: is_computer_on. This api tells if the computer is currently powered on or not. Using this system call as a study is interesting because its implementation is quite simple, and it is a historical one in BeOS system (with its brother is_computer_on_fire, but it is not a system call in haiku :).</description></item><item><title>BeOS Joystick Framework</title><link>https://www.haiku-os.org/documents/dev/beos_joystick_framework/</link><pubDate>Mon, 11 Aug 2008 13:53:13 +0000</pubDate><guid>https://www.haiku-os.org/documents/dev/beos_joystick_framework/</guid><description>This article are more of a compliment to ITO Takayuki’s “BeOS Joystick Driver ” so reading ITO’s article before this one are advisable. I’m not a article writing person (not even in Swedish) but as I’m the 3:d that tries to implement the Joysticks framework in Haiku I think that it would be good to have something for the 4:th person to read if I drop this :)
When I started to look over the Joystick framework I thought that this would not be that hard, boy was I fooled :) , lol I don’t even know how to talk to hardware.</description></item><item><title>Laying It All Out, Part 1</title><link>https://www.haiku-os.org/documents/dev/laying_it_all_out_part_1/</link><pubDate>Mon, 14 Jul 2008 16:53:11 +0000</pubDate><guid>https://www.haiku-os.org/documents/dev/laying_it_all_out_part_1/</guid><description>
&lt;div class="field field-type-text field-field-body">
&lt;div class="field-items">
&lt;div class="field-item odd">
&lt;h3>The Motivation for a Layout System&lt;/h3>
&lt;p>One of the major complaints that any serious BeOS programmer would eventually make about the GUI classes in the Be API is the lack of easy font sensitivity. What this means is that if one designs a GUI using the system default fonts and then a user of your application changes their system fonts to be much smaller or larger than the default, the GUI will likely look bad (especially if the font size is larger.) Things that were previously aligned may not be, and likely text labels will run into other components or even disappear into the side of the window. This is especially true in fixed sized GUIs like dialog boxes and configuration panels. See Figure 1.&lt;/p></description></item><item><title>Copying files from and to Haiku from within Linux using bfs_shell</title><link>https://www.haiku-os.org/documents/dev/copying_files_from_and_to_haiku_from_within_linux_using_bfs_shell/</link><pubDate>Sat, 12 Jul 2008 09:38:59 +0000</pubDate><guid>https://www.haiku-os.org/documents/dev/copying_files_from_and_to_haiku_from_within_linux_using_bfs_shell/</guid><description>This is a tutorial on how to use the bfs_shell to copy files to and from a Haiku partition or image from within Linux.
Please use caution when you are working with partitions. In short, if you don't know for sure what you're doing here, please don't, unless you have backups of everything and are willing to restore everything.
This tuturial assumes you have completed:
Building Haiku on Ubuntu Linux step by step and optionally, if you have built Haiku to a partition and want to access it: Installing Haiku to a partition from Linux With that out of the way, there are two ways to do this:</description></item><item><title>Haiku Network Stack Architecture</title><link>https://www.haiku-os.org/documents/dev/haiku_network_stack_architecture/</link><pubDate>Mon, 24 Mar 2008 16:27:56 +0000</pubDate><guid>https://www.haiku-os.org/documents/dev/haiku_network_stack_architecture/</guid><description>This document may contained outdated information, please update!
The Haiku Network Stack is a modular and layered networking stack, very similar to what you may know as BONE.
The entry point when talking to the stack is through a dedicated device driver that publish itself in /dev/net. The userland library libnetwork.so (which combines libsocket.so, and libbind.so) directly talks to this driver, mostly via ioctl()1.
The driver either creates sockets, or passes on every command to the socket module2.</description></item><item><title>Welcome to Kernel Debugging Land...</title><link>https://www.haiku-os.org/documents/dev/welcome_to_kernel_debugging_land/</link><pubDate>Mon, 04 Feb 2008 22:01:09 +0000</pubDate><guid>https://www.haiku-os.org/documents/dev/welcome_to_kernel_debugging_land/</guid><description>
&lt;div class="field field-type-text field-field-body">
&lt;div class="field-items">
&lt;div class="field-item odd">
&lt;p>One of the most important tools of a Haiku kernel developer is the built-in
kernel debugger. Nevertheless also developers more comfortable with userland
hacking should not be shy to use it, as it can greatly help with various kinds
of bugs and problems. This document sheds some light on its basic and advanced
features.&lt;/p></description></item><item><title>OpenJDK 7 Environment Setup for BeOS R5.0.3</title><link>https://www.haiku-os.org/documents/dev/openjdk_7_enviornment_setup_for_beos_r5_0_3/</link><pubDate>Fri, 04 Jan 2008 05:14:16 +0000</pubDate><guid>https://www.haiku-os.org/documents/dev/openjdk_7_enviornment_setup_for_beos_r5_0_3/</guid><description>This document outlines the steps for installing and configuring an environment on BeOS R5 suitable for preliminary work on the OpenJDK 7 port to Haiku. This document, like the foundation for our porting effort is currently a work in progress.
Requirements to access OpenJDK's Mercurial Repository Python 2.4 This Python package from bebits works well on R5.
Follow the instructions to install it. It's not the cleanest install in the world, (I don't like</description></item><item><title>How to Work on the Haiku WebKit Port</title><link>https://www.haiku-os.org/documents/dev/how_work_haiku_webkit_port/</link><pubDate>Tue, 04 Dec 2007 05:57:08 +0000</pubDate><guid>https://www.haiku-os.org/documents/dev/how_work_haiku_webkit_port/</guid><description>
&lt;div class="field field-type-text field-field-body">
&lt;div class="field-items">
&lt;div class="field-item odd">
&lt;div class="box-stop">This article is out of date and the code linked should not be used for anything right now. Please, refer to the more recent &lt;a href="http://www.haiku-os.org/articles/2009-10-30_how_work_webkit" title="How to work on WebKit">How to Work on WebKit&lt;/a> article instead.&lt;/div>
&lt;p>To work on the Haiku WebKit port one needs to take some time to get the right environment set up. At the moment the Haiku WebKit port can only be developed on Linux and cross compiled with the GCC4 compiler. So the first step is to follow my &lt;a href="http://haiku-os.org/documents/dev/building_haiku_on_ubuntu_linux_step_by_step">tutorial on building Haiku on Ubuntu&lt;/a>. On step 5 of the above, please be sure to build the GCC4 cross compiler, not the GCC2 version. If you have already built Haiku with GCC2 on Linux, I recommend renaming your current "generated" directory in the Haiku tree to "generated_gcc2" and then continue with step 5 from the above, setting up the GCC4 cross compiler. Switching between compilers can then be done by just renaming the generated directory, since it contains all compiled build tools and necessary files for each compiler.&lt;/p></description></item><item><title>Running UserlandFS</title><link>https://www.haiku-os.org/documents/dev/running_userlandfs/</link><pubDate>Tue, 06 Nov 2007 16:26:56 +0000</pubDate><guid>https://www.haiku-os.org/documents/dev/running_userlandfs/</guid><description>
&lt;div class="field field-type-text field-field-body">
&lt;div class="field-items">
&lt;div class="field-item odd">
&lt;p>The UserlandFS is a file system wrapper for the kernel (similar to FUSE on Linux) which loads file system add-ons in userspace. In this way, it is a great tool for developing file system add-ons without unwanted trips to the Kernel Debugging Land. On top of that, several interesting test add-ons already exist for it in the Haiku source tree, including a network file system with full support for extended file attributes (meta data). The API which a file system add-on for UserlandFS has to implement is almost identical to the "real" kernel file system API, so that it is easy to migrate the add-on to the kernel once it is ready.&lt;/p></description></item><item><title>Using Snapshots For Short Locking Times</title><link>https://www.haiku-os.org/documents/dev/using_snapshots_for_short_locking_times/</link><pubDate>Sat, 08 Sep 2007 15:09:01 +0000</pubDate><guid>https://www.haiku-os.org/documents/dev/using_snapshots_for_short_locking_times/</guid><description>
&lt;div class="field field-type-text field-field-body">
&lt;div class="field-items">
&lt;div class="field-item odd">
&lt;p>The primary intention of my &lt;a href="http://haiku-os.org/documents/dev/understanding_the_design_and_requirements_of_multithreaded_applications">previous article&lt;/a> was to make it very clear why and when locking is needed in multithreaded applications. In this article, I want to present my experiences in writing a new prototype for a replacement of the document model in WonderBrush and how it is manipulated and rendered asynchronously.&lt;/p></description></item><item><title>Installing Haiku to a partition from Linux</title><link>https://www.haiku-os.org/documents/dev/installing_haiku_to_a_partition_from_linux/</link><pubDate>Thu, 06 Sep 2007 16:36:23 +0000</pubDate><guid>https://www.haiku-os.org/documents/dev/installing_haiku_to_a_partition_from_linux/</guid><description>2010-January: This document is now obsolete. We are in the process of consolidating and re-organizing the website documentation. For now please refer to the in-progress website documentation. This is a guide for you who have already been able to build an image of Haiku under Linux and running that with an emulator such as QEMU or VMWare and want to try Haiku natively with your real hardware.
Disclaimer: Do this on your own risk.</description></item><item><title>Understanding the Requirements of Multithreaded Applications</title><link>https://www.haiku-os.org/documents/dev/understanding_the_design_and_requirements_of_multithreaded_applications/</link><pubDate>Wed, 05 Sep 2007 08:18:38 +0000</pubDate><guid>https://www.haiku-os.org/documents/dev/understanding_the_design_and_requirements_of_multithreaded_applications/</guid><description>
&lt;div class="field field-type-text field-field-body">
&lt;div class="field-items">
&lt;div class="field-item odd">
&lt;p align="justify">
Though I am programming on BeOS since 1999, only in recent years I have slowly become more comfortable with various multithreading related issues in my programs. So I thought I'd like to share some of my experiences here for beginning programmers or programmers skeptical about multithreading. I hope to be extending this as a series of articles to help learn the benefits and pitfalls of multithreading. All with an emphasis on programming for the Haiku API.
&lt;/p></description></item><item><title>Documentation Team: Membership and Organisational Structure</title><link>https://www.haiku-os.org/documents/dev/documentation_team_membership_and_organisational_structure/</link><pubDate>Thu, 24 May 2007 13:46:22 +0000</pubDate><guid>https://www.haiku-os.org/documents/dev/documentation_team_membership_and_organisational_structure/</guid><description>
&lt;div class="field field-type-text field-field-body">
&lt;div class="field-items">
&lt;div class="field-item odd">
&lt;p>This document outlines the team structure of the &lt;a href="../../about/teams/documentation">Documentation Team&lt;/a>. It will describe how the privileges and duties are distributed between the three main entities: Contributors, Members and the Coordinator. It will also describe how the advancement system works.&lt;p></description></item><item><title>A Brief Introduction to our Source Repository Layout</title><link>https://www.haiku-os.org/documents/dev/a_brief_introduction_to_our_source_repository_layout/</link><pubDate>Thu, 17 May 2007 14:01:08 +0000</pubDate><guid>https://www.haiku-os.org/documents/dev/a_brief_introduction_to_our_source_repository_layout/</guid><description>
&lt;div class="field field-type-text field-field-body">
&lt;div class="field-items">
&lt;div class="field-item odd">
&lt;p>This document is supposed to give you some insight where you'll find what in the source repository tree. If you're familiar with Haiku already, you will notice that the tree layout to some degree mirrors the structure a Haiku installation has on disk.&lt;/p>
&lt;p>Things that are built are usually put under "src", for example, there is a "data", and a "src/data" folder - the former for example contains scripts or settings ready to be copied to the Haiku image, while the latter for example contains the MIME types database that first have to be converted from a format that is easy to edit to what Haiku expects.&lt;/p></description></item><item><title>Haiku Documentation Team How-To</title><link>https://www.haiku-os.org/documents/dev/haiku_documentation_team_how_to/</link><pubDate>Tue, 24 Apr 2007 23:58:45 +0000</pubDate><guid>https://www.haiku-os.org/documents/dev/haiku_documentation_team_how_to/</guid><description>
&lt;div class="field field-type-text field-field-body">
&lt;div class="field-items">
&lt;div class="field-item odd">
&lt;p>This how-to describes getting started with contributing to the Haiku documentation and the software you will need. The documentation team has a mailing list that can be found here:&lt;/p></description></item><item><title>Application Level API Incompatibilities with BeOS</title><link>https://www.haiku-os.org/documents/dev/application_level_api_incompatibilities_with_beos/</link><pubDate>Sat, 06 Jan 2007 22:11:43 +0000</pubDate><guid>https://www.haiku-os.org/documents/dev/application_level_api_incompatibilities_with_beos/</guid><description>BodyHaiku R1 (x86) was designed and is being implemented to be binary and source compatible with applications written for BeOS R5 (x86) to a large extent, but not the other way around. In some cases we deliberately broke source compatibility while at the same time maintaining binary compatibility. Here are some specific examples:
The "be" header path is gone - it's called "os" in Haiku; since it is always part of the default header search path anyway, you can always just remove it to let your software compile on both platforms, ie.</description></item><item><title>Developing IME Aware Applications</title><link>https://www.haiku-os.org/documents/dev/developing_ime_aware_applications/</link><pubDate>Sun, 10 Dec 2006 20:13:00 +0000</pubDate><guid>https://www.haiku-os.org/documents/dev/developing_ime_aware_applications/</guid><description>
&lt;div class="field field-type-text field-field-body">
&lt;div class="field-items">
&lt;div class="field-item odd">
&lt;p>To support Haiku and do something useful for it, I am pleased to show you how to communicate with the input server in BeOS.&lt;/p>
&lt;p>In BeOS, almost everything uses the UTF-8 character encoding for the processing of characters. Thus, if you want to write or display the characters of other languages than English, all you need to do is to find a font able to display the characters properly and an input method add-on to help you at outputting characters to the running application. The input method handling of BeOS was originally found in &lt;a href="http://www.beatjapan.org/mirror/www.be.com/aboutbe/pressreleases/98-05-28_be_ergosoft.html" target="_blank">the Japanese support&lt;/a>. It works this way: The input server loads the add-ons located at &lt;span class="geshifilter">&lt;code class="cpp geshifilter-cpp">B_SYSTEM_ADDONS_DIRECTORY&lt;/code>&lt;/span> /input_server/methods or &lt;span class="geshifilter">&lt;code class="cpp geshifilter-cpp">B_USER_ADDONS_DIRECTORY&lt;/code>&lt;/span>/input_server/methods, then filter all events generated by the keyboard or mouse with the Filter() method of BInputServerFilter to change them. There are only a few input methods written since the time BeOS R4 was released. Maybe it's because only ERGOSOFT Crop. and just a few developers know how to have method working. In my memory, existing methods are BeCJK, HanBe, Canna, ChineseTool and more recently "Anthy for Zeta".&lt;/p></description></item><item><title>How to get Haiku to work in Parallels</title><link>https://www.haiku-os.org/documents/dev/how_get_haiku_work_parallels/</link><pubDate>Wed, 01 Nov 2006 01:32:08 +0000</pubDate><guid>https://www.haiku-os.org/documents/dev/how_get_haiku_work_parallels/</guid><description> Here's how to get Haiku to work in Parallels:
Download a nightly build from the Haiku Build Factory. Rename the "haiku.image" file to "haiku.hdd". Use ImageTool to resize the haiku.hdd file to 120MB. Create a new VM in Parallels, with Guest OS Type as Windows. Set the Hard Drive to the haiku.hdd file that you downloaded. References BeOS related thread on Parallels Support Forum Parallels home page</description></item><item><title>Getting and Building the Haiku Source Code</title><link>https://www.haiku-os.org/documents/dev/getting_and_building_haiku_source_code/</link><pubDate>Sat, 28 Oct 2006 09:10:02 +0000</pubDate><guid>https://www.haiku-os.org/documents/dev/getting_and_building_haiku_source_code/</guid><description>
&lt;div class="field field-type-text field-field-body">
&lt;div class="field-items">
&lt;div class="field-item odd">
&lt;h3>Document Obsolete&lt;/h3>
&lt;div class="box-info">
&lt;strong>2010-January: This document is now obsolete. We are in the process of consolidating and re-organizing the website documentation. For now please refer to the &lt;a href="../../guides">in-progress website documentation&lt;/a>.&lt;/strong>
&lt;/div>
&lt;p>&lt;strong>Please note this document mainly pertains to building Haiku under BeOS R5 and later.&lt;/strong> If you're using a non-BeOS host platform, you might find &lt;a href="../../node/1781">this guide &lt;/a>more useful.&lt;/p>
&lt;h3>Getting the source&lt;/h3>
&lt;p>&lt;strong>All commands must be executed in the Terminal.&lt;/strong>&lt;/p>
&lt;p>Go to the parent directory for Haiku&amp;#39;s repository and enter:&lt;/p>
&lt;p>&lt;pre>svn checkout &lt;a href="http://svn.berlios.de/svnroot/repos/haiku/haiku/trunk" title="http://svn.berlios.de/svnroot/repos/haiku/haiku/trunk">http://svn.berlios.de/svnroot/repos/haiku/haiku/trunk&lt;/a> haiku&lt;/pre>&lt;/p>
&lt;p>This will checkout the source into a new subdirectory called &amp;quot;haiku&amp;quot;. &lt;strong>Members&lt;/strong> of Haiku should login with their BerliOS account to get commit access:&lt;/p></description></item><item><title>Driver Development Presentation at WalterCon 2006</title><link>https://www.haiku-os.org/documents/dev/driver_development_presentation_waltercon_2006/</link><pubDate>Fri, 27 Oct 2006 22:00:00 +0000</pubDate><guid>https://www.haiku-os.org/documents/dev/driver_development_presentation_waltercon_2006/</guid><description>
&lt;div class="field field-type-text field-field-body">
&lt;div class="field-items">
&lt;div class="field-item odd">
&lt;p>This is a transcription of the Driver Development Presentation given by Axel Dörfler at WalterCon 2006.&lt;/p>
&lt;h1>Contents&lt;/h1>
&lt;ol>
&lt;li>&lt;a href="">The Device File System&lt;/a>, &lt;i>devfs&lt;/i>&lt;/li>
&lt;li>&lt;a href="">Modules&lt;/a>&lt;/li>
&lt;li>&lt;a href="">Device Types&lt;/a>&lt;/li>
&lt;li>&lt;a href="">Interrupts&lt;/a>&lt;/li>
&lt;li>&lt;a href="">Haiku Specials&lt;/a>&lt;/li>
&lt;/ol></description></item><item><title>Getting Linux Developer Tools</title><link>https://www.haiku-os.org/documents/dev/getting_linux_developer_tools/</link><pubDate>Tue, 15 Aug 2006 19:34:00 +0000</pubDate><guid>https://www.haiku-os.org/documents/dev/getting_linux_developer_tools/</guid><description>
&lt;div class="field field-type-text field-field-body">
&lt;div class="field-items">
&lt;div class="field-item odd">
&lt;div class="box-info">
&lt;strong>2010-January: This document is now obsolete. We are in the process of consolidating and re-organizing the website documentation. For now please refer to the &lt;a href="../../guides">in-progress website documentation&lt;/a>.&lt;/strong>
&lt;/div>
&lt;h3>What you need&lt;/h3>
&lt;p>You will need svn before starting this process; the other tools (jam, gcc et al) are built from our repository. Before attempting to build Haiku, one must get copies of the development toolchain. Keep in mind that the process will consume around 1 GiB of disk space. &lt;/p></description></item><item><title>Windows and Views in the Haiku app_server</title><link>https://www.haiku-os.org/documents/dev/windows_and_views_in_the_haiku_app_server/</link><pubDate>Thu, 13 Jul 2006 04:00:00 +0000</pubDate><guid>https://www.haiku-os.org/documents/dev/windows_and_views_in_the_haiku_app_server/</guid><description>BodyLate last year, we decided to rewrite an important part of the Haiku app_server. Why was that? Let&amp;#39;s start out with what the app_server is supposed to do: At the heart, it manages multiple applications simultaneously using the display device as a shared resource. Two of the important system objects through which this is organized are Windows and Views. Through views, the applications can draw information onto the screen, while a window is merely some sort of container for views.</description></item><item><title>The Attack Of The Warriors, Part 2: IO-Warrior24 - 16 Bit Multipurpose I/O Ports</title><link>https://www.haiku-os.org/documents/dev/the_attack_of_the_warriors_part_2_io_warrior24_16_bit_multipurpose_i_o_ports/</link><pubDate>Fri, 27 Jan 2006 21:00:00 +0000</pubDate><guid>https://www.haiku-os.org/documents/dev/the_attack_of_the_warriors_part_2_io_warrior24_16_bit_multipurpose_i_o_ports/</guid><description>BodyThe code discussed in this article can be found here.
The IO-Warrior24 device from Code Mercenaries is equipped with 16 general purpose I/O (input/output) pins. When enabling the so-called special mode functions, more or less pins are reassigned to serve a special purpose. You can select between:
I2C, IIC: a two-wire serial Inter-IC-Bus allowing connection to RAMs, EEPROMs, ADCs,DACs and a lot more. LCD: parallel communication with alphanumerics Liquid-Christal-Display units SPI: a four-wire serial Serial-Peripheral-Interface-Bus similar to I2C LED-Matrix: a serial communication bus to control LEDs in a multiplexed matrix configuration RC5IR: Infrared Remote control according to the RC5 code We&amp;#39;ll now examine this impressive manifold of functions step-by-step.</description></item><item><title>Dependency Hell</title><link>https://www.haiku-os.org/documents/dev/dependency_hell/</link><pubDate>Sat, 21 May 2005 04:00:00 +0000</pubDate><guid>https://www.haiku-os.org/documents/dev/dependency_hell/</guid><description>BodyI suspect most readers have heard of this in reference to various Linux distributions. This describes the situation where package A requires package B that then requires package A, directly or indirectly, and you end up requiring a whole group of packages that seem to be entirely unrelated to installing package A, that include a lot of functionality of B. Well, that&amp;#39;s just a higher level abstraction of what I will discuss in this article.</description></item><item><title>The Attack Of The Warriors, Part 1</title><link>https://www.haiku-os.org/documents/dev/the_attack_of_the_warriors_part_1/</link><pubDate>Sat, 21 May 2005 04:00:00 +0000</pubDate><guid>https://www.haiku-os.org/documents/dev/the_attack_of_the_warriors_part_1/</guid><description>
&lt;div class="field field-type-text field-field-body">
&lt;div class="field-items">
&lt;div class="field-item odd">
&lt;p>&lt;em>The code discussed in this article can be found &lt;a href="../../files/HaikuNewsletter57Article1Archive1.zip">here&lt;/a>.&lt;/em>&lt;/p>
&lt;p>The warrior family MouseWarrior, KeyWarrior, JoyWarrior and IO-Warrior of the German company Code Mercenaries (&lt;a href="http://www.codemercs.com" title="www.codemercs.com">www.codemercs.com&lt;/a>) enables you to communicate with your PC via USB in a manifold way to various external devices. All members of the family are full USB V1.1/2.0 compliant, low speed devices using the HID 1.1 (Human Interface Device) device class. If you are missing the GeekPort - it&amp;#39;s back again.&lt;/p> &lt;p>Let&amp;#39;s start with a really simple device, the JoyWarrior24 A8-8 USB joystick controller.&lt;/p></description></item><item><title>Managing Your Replicants: XShelfInspector and XContainer</title><link>https://www.haiku-os.org/documents/dev/managing_your_replicants_xshelfinspector_and_xcontainer/</link><pubDate>Mon, 28 Mar 2005 05:00:00 +0000</pubDate><guid>https://www.haiku-os.org/documents/dev/managing_your_replicants_xshelfinspector_and_xcontainer/</guid><description>BodyThe source discussed in this article can be found here.
The original BeOS distribution from Be. Inc. contains two applications to help you manage your replicants: ShelfInspector and Container. Both can be found in the .../sample-code/application_kit/ folder. It&amp;#39;s a good idea to read Be&amp;#39;s original readme.txt concerning ShelfInspector. Both enhanced applications -- XShelfInspector and XContainer -- are working closely together like the original ones; however, some improvements have been added so one can use them more comfortably.</description></item><item><title>TransRepliShow: Dragging Replicants Transparently</title><link>https://www.haiku-os.org/documents/dev/transreplishow_dragging_replicants_transparently/</link><pubDate>Mon, 28 Mar 2005 05:00:00 +0000</pubDate><guid>https://www.haiku-os.org/documents/dev/transreplishow_dragging_replicants_transparently/</guid><description>BodyThis article follows up on Dr. Reh&amp;#39;s previous newsletter article, RepliShow: A Replicable Image Viewer. The code discussed is available here for your convenience.
Just remember Seth Flaxman&amp;#39;s RepliShow: While dragging the replicant you only see the border lines of an empty rectangle - not very Be-like. However, only a few lines of code are necessary to obtain a rectangle containing the dragged image and looking transparently. Because the dragging action is managed by the BDragger class we need to do some subclassing.</description></item><item><title>Using Subversion with the Haiku Source Repository</title><link>https://www.haiku-os.org/documents/dev/using_subversion_with_the_haiku_source_repository/</link><pubDate>Mon, 07 Mar 2005 05:00:00 +0000</pubDate><guid>https://www.haiku-os.org/documents/dev/using_subversion_with_the_haiku_source_repository/</guid><description>
&lt;div class="field field-type-text field-field-body">
&lt;div class="field-items">
&lt;div class="field-item odd">
&lt;div class="box-info">
&lt;strong>2011-November: This document is now obsolete. Subversion is no longer in use. We are in the process of consolidating and re-organizing the website documentation. For now please refer to the &lt;a href="../../guides">in-progress website documentation&lt;/a>.&lt;/strong>
&lt;/div>
&lt;p> As we&amp;#39;ve already &lt;a href="http://www.haiku-os.org/learn.php?mode=news_view&amp;amp;id=372">announced earlier&lt;/a>, we&amp;#39;re planning to switch our version control system from CVS to Subversion. While CVS is working nice basically, it&amp;#39;s much too limited to serve as a good foundation for a project of a size like ours. &lt;/p>&lt;p> The following document should give you an introduction on how to use Subversion with our repository - it will not provide you with many details, but with some pointers in case you want to know more about Subversion. The current version of Subversion is 1.1.3. &lt;/p></description></item><item><title>Painter and How AGG Works</title><link>https://www.haiku-os.org/documents/dev/painter_and_how_agg_works/</link><pubDate>Sat, 29 Jan 2005 06:00:00 +0000</pubDate><guid>https://www.haiku-os.org/documents/dev/painter_and_how_agg_works/</guid><description>
&lt;div class="field field-type-text field-field-body">
&lt;div class="field-items">
&lt;div class="field-item odd">
&lt;p>
This article is intended to give an overview of the Anti-Grain Geometry 2D engine by Maxim Shemanarev. This C++ graphics engine is currently the back-end of the Haiku &lt;span class="geshifilter">&lt;code class="cpp geshifilter-cpp">Painter&lt;/code>&lt;/span> class used by the app_server as its implementation of &lt;span class="geshifilter">&lt;code class="cpp geshifilter-cpp">BView&lt;/code>&lt;/span> style drawing. By introducing some of the concepts of AGG and how they are used within Painter, I'm hoping to make it easier for others to join the development of Painter and finding ways of improving its efficiency, adding features and/or finding means of adding hardware acceleration.
&lt;/p></description></item><item><title>RepliShow: A Replicable Image Viewer</title><link>https://www.haiku-os.org/documents/dev/replishow_a_replicable_image_viewer/</link><pubDate>Sat, 29 Jan 2005 05:00:00 +0000</pubDate><guid>https://www.haiku-os.org/documents/dev/replishow_a_replicable_image_viewer/</guid><description>BodyThe original version of RepliShow was written by Seth Flaxman, and has been modified by Dr. Hartmut Reh. The source discussed in this article can be found here.
Today we&amp;#39;ll be constructing a rather primitive application that displays images and is replicable. It will demonstrate two things: BeOS replicant technology and the Translation Kit.
Replicant technology is a standard part of BeOS, although it has not been widely used by many applications.</description></item><item><title>Replicants - More application than an application</title><link>https://www.haiku-os.org/documents/dev/replicants_more_application_than_an_application/</link><pubDate>Mon, 10 May 2004 04:00:00 +0000</pubDate><guid>https://www.haiku-os.org/documents/dev/replicants_more_application_than_an_application/</guid><description>BodyYep. I remember when Be first announced Replicants. They were going to be the next ActiveX. I wonder what ever happened to them.
The sad truth is that absolutely nothing happened to Replicants. Almost no one ever used them. No great mountains of applications ever came out for them. I was chatting with some people the other day on IRC and we wondered about this. Needing to write an article and not sure what to write, that commiseration came back to mind.</description></item><item><title>How to Write a Printer Driver</title><link>https://www.haiku-os.org/documents/dev/how_to_write_a_printer_driver/</link><pubDate>Sun, 15 Feb 2004 05:00:00 +0000</pubDate><guid>https://www.haiku-os.org/documents/dev/how_to_write_a_printer_driver/</guid><description>BodyA printer driver in BeOS R5 is an add-on that exports a specific C interface. This add-on is used by the print_server to add a new printer, configure a page, configure the print job, and print the print job on the printer. This article describes how the print_server interfaces with the printer driver.
The print_server is responsible for maintaining common settings. BMessage objects are used to pass settings from the print_server to a printer driver and vice versa.</description></item><item><title>System Logging</title><link>https://www.haiku-os.org/documents/dev/system_logging/</link><pubDate>Sun, 14 Dec 2003 05:00:00 +0000</pubDate><guid>https://www.haiku-os.org/documents/dev/system_logging/</guid><description>Body The system logging capabilities in BeOS are built on top of the syslog interface as defined by the POSIX standard. In addition to the functionality provided by that standard, it has some BeOS specific extensions. The following article will give an overview about how this service works internally in Haiku, and how it can be used in applications. The implementation as done in Haiku might differ from the actual implementation in BeOS, but it is fully binary compatible.</description></item><item><title>What are You Looking At?</title><link>https://www.haiku-os.org/documents/dev/what_are_you_looking_at/</link><pubDate>Wed, 10 Sep 2003 09:00:00 +0000</pubDate><guid>https://www.haiku-os.org/documents/dev/what_are_you_looking_at/</guid><description>Body[Obnoxious, snotty narrator begins]
&amp;quot;....When last we left our heroes at Munstris Diveloperz Inc., they were left wondering how applications can be made truly simple. Some software just worked well and other software just seemed bad, but they couldn&amp;#39;t figure out why. It seemed like finding a good software tool was no simpler a task than navigating a vast digital jungle with little more than a pocket knife while wishing for a razor-sharp machete.</description></item><item><title>Node Monitoring</title><link>https://www.haiku-os.org/documents/dev/node_monitoring/</link><pubDate>Thu, 15 May 2003 04:00:00 +0000</pubDate><guid>https://www.haiku-os.org/documents/dev/node_monitoring/</guid><description>This document describes the feature of the BeOS kernel to monitor nodes. First, there is an explanation of what kind of functionality we have to reproduce (along with the higher level API), then we will present the implementation in Haiku.
Requirements - Exported Functionality in BeOS From user-level, BeOS exports the following API as found in the storage/NodeMonitor.h header file:
status_t watch_node(const node_ref *node, uint32 flags, BMessenger target);</description></item><item><title>The Art of Locking</title><link>https://www.haiku-os.org/documents/dev/the_art_of_locking/</link><pubDate>Thu, 17 Apr 2003 04:00:00 +0000</pubDate><guid>https://www.haiku-os.org/documents/dev/the_art_of_locking/</guid><description>BodyI&amp;#39;m sorry, this is not about how to lock Haiku developers into basements to ensure they are most productive--it is a well known fact that this is BGA&amp;#39;s speciality, anyway ;-) --no, I want to talk a bit about multiple threads and how to prevent them from mangling shared resources due to uncontrolled access.
Before you skip to the next article expecting to be bored to death by repetition of well-stressed basics, give me a chance to explain: Instead of wading through the fundamentals on BLocker or semaphores, I want to discuss a specific locking problem, for which I recently found, as I feel, quite an elegant solution.</description></item><item><title>template &lt; madness > : Unit Test Policy</title><link>https://www.haiku-os.org/documents/dev/template_madness_unit_test_policy/</link><pubDate>Wed, 19 Mar 2003 05:00:00 +0000</pubDate><guid>https://www.haiku-os.org/documents/dev/template_madness_unit_test_policy/</guid><description>BodyAlmost all of my recent coding efforts have gone into work on BMessage. Early on, I decided that wanted to try a more &amp;quot;modern&amp;quot; back-end to BMessage, something that would leverage the power of the STL. The end result is out there enough that I&amp;#39;m not sure I want to use it. At any rate, I&amp;#39;m not going to talk about that right now; maybe in another article, if you&amp;#39;re all good.</description></item><item><title>The Art of Jamming - All Parts</title><link>https://www.haiku-os.org/documents/dev/the_art_of_jamming_all_parts/</link><pubDate>Sat, 08 Mar 2003 05:00:00 +0000</pubDate><guid>https://www.haiku-os.org/documents/dev/the_art_of_jamming_all_parts/</guid><description>BodyPart 1 Before the musicians in the audience get too excited, I&amp;#39;m not going to talk about getting together with buddies to crank out some tunes. Nor will the cooks in the audience find instructions on making the perfect fruit preserves. No, when I say Jamming, I refer to the act of using the Jam build tool.
In this first part of my series on the Jam build tool, I&amp;#39;m going to provide a high level overview as well as show the product of some of my recent labors with Jam: the Jamfile-engine.</description></item><item><title>Compile them resources</title><link>https://www.haiku-os.org/documents/dev/compile_them_resources/</link><pubDate>Fri, 07 Mar 2003 21:00:00 +0000</pubDate><guid>https://www.haiku-os.org/documents/dev/compile_them_resources/</guid><description>BodyAll BeOS programs have &amp;quot;resources&amp;quot;. Simply put, a resource is data that is bundled with your application&amp;#39;s executable. Typical examples are the application&amp;#39;s icons and its signature, but you can attach any data you want. Many applications store bitmaps, text, cursors, and even complete user interfaces (dialog boxes, menus, etc.) as resources.
This may sound a lot like attributes; after all, aren&amp;#39;t attributes a way to store additional data alongside your files as well?</description></item><item><title>Introduction to MIDI: Part 2</title><link>https://www.haiku-os.org/documents/dev/introduction_to_midi_part_2/</link><pubDate>Fri, 21 Feb 2003 05:00:00 +0000</pubDate><guid>https://www.haiku-os.org/documents/dev/introduction_to_midi_part_2/</guid><description>BodyThis second part of my introduction to MIDI programming on (Open)BeOS is about timing. If you read Part 1 and tried out the demo app, you may have noticed that playback of the notes really lagged behind if you quickly pressed several keys in a row. That is bad, because we want MIDI processing to be as real-time as possible. This article explains where the lag comes from, and shows you how to prevent it.</description></item><item><title>Introduction to MIDI: Part 1</title><link>https://www.haiku-os.org/documents/dev/introduction_to_midi_part_1/</link><pubDate>Wed, 08 Jan 2003 05:00:00 +0000</pubDate><guid>https://www.haiku-os.org/documents/dev/introduction_to_midi_part_1/</guid><description>BodyOr rather, how to use MIDI on the BeOS and, of course, Haiku. MIDI stands for Musical Instrument Digital Interface and is a well-established protocol for controlling musical devices such as keyboards, synthesizers, drum computers, and a whole bunch of other stuff. The protocol is fairly simple and consists of commands such as &amp;quot;play this note&amp;quot; and &amp;quot;now use this instrument&amp;quot;. You don&amp;#39;t need to be a MIDI expert to write BeOS MIDI apps, but some knowledge of the protocol helps.</description></item><item><title>Experiments in Scheduling</title><link>https://www.haiku-os.org/documents/dev/experiments_in_scheduling/</link><pubDate>Thu, 12 Dec 2002 04:00:00 +0000</pubDate><guid>https://www.haiku-os.org/documents/dev/experiments_in_scheduling/</guid><description>
&lt;div class="field field-type-text field-field-body">
&lt;div class="field-items">
&lt;div class="field-item odd">
&lt;p>&lt;strong>Note:&lt;/strong> this article was written by Daniel Reinhold who unfortunately left the Haiku project and thus doesn&amp;#39;t have his own website account.&lt;/p> The OS scheduler is the heart (nearly literally) of any operating system, so it&amp;#39;s got to be in good working order. It needs to be fast, efficient, and distribute the computer&amp;#39;s resources fairly. But what does that really mean? What makes a good scheduler? &lt;p>In order to better understand this critical component, I recently wrote a userland prototype that mimics a real scheduler. This is taking advantage of the &amp;#39;friendly third option&amp;#39; in kernel development. That is, when you want to test (and/or otherwise examine) a piece of kernel level code, you either: &lt;/p></description></item><item><title>A crash course in inline source code documentation with Doxygen</title><link>https://www.haiku-os.org/documents/dev/a_crash_course_in_inline_source_code_documentation_with_doxygen/</link><pubDate>Wed, 27 Nov 2002 11:00:00 +0000</pubDate><guid>https://www.haiku-os.org/documents/dev/a_crash_course_in_inline_source_code_documentation_with_doxygen/</guid><description>BodySo I&amp;#39;m sure a number of you out there were a bit skeptical as to whether or not I&amp;#39;d be able to churn out two Doxygen newsletter articles in a row (I sure didn&amp;#39;t think I&amp;#39;d manage :). Well, just to spite all of us non-believers, here I am with a shiny new tutorial on documenting your source code with Doxygen. The things I&amp;#39;m going to cover here are just the basic meat-and-potatoes parts of Doxygen that I use on a day to day basis; for anything else, please consult the online Doxygen manual; it&amp;#39;s really quite handy :).</description></item><item><title>I Will Survive</title><link>https://www.haiku-os.org/documents/dev/i_will_survive/</link><pubDate>Wed, 30 Oct 2002 11:00:00 +0000</pubDate><guid>https://www.haiku-os.org/documents/dev/i_will_survive/</guid><description>BodyIt&amp;#39;s not something that might happen in a rare circumstance, something that can be neglected in the design of your media application, but something that will happen as soon as the user hits that big inviting button on front of the Media preference panel - the media_server quitting while you rely on it and the connections you have established with your own and other media nodes. So, for your programs to survive this situation, is quite desirable.</description></item><item><title>Unit Testing, Part Deux</title><link>https://www.haiku-os.org/documents/dev/unit_testing_part_deux/</link><pubDate>Wed, 31 Jul 2002 09:00:00 +0000</pubDate><guid>https://www.haiku-os.org/documents/dev/unit_testing_part_deux/</guid><description>
&lt;div class="field field-type-text field-field-body">
&lt;div class="field-items">
&lt;div class="field-item odd">
&lt;p>So, I&amp;#39;m sure you&amp;#39;re all dying to know about the new grand unified CppUnit testing framework we have. What? You haven&amp;#39;t heard of it? Color me unsurprised. :-) &lt;/p>
&lt;h3>Part I &amp;#151 Running Tests&lt;/h3>
&lt;p>For those of you who are purely interested in helping us out by running the tests on your own computer, this section is for you.&lt;/p>
&lt;p>First off, you&amp;#39;ll need to slurp a copy of our repository onto your computer. Next, you&amp;#39;ll need to build the entire tree (technically you don&amp;#39;t need the *whole* tree, but it&amp;#39;s easier on me if you just build it all; that way I don&amp;#39;t have to list off all the targets you&amp;#39;d need to specify :-). For those who are unsure of how to do this, get a copy of our development tools off the &lt;a href="../../downloads">Download page&lt;/a>, do an anonymous checkout of our repository (check out &lt;a href="../../documents/dev/getting_and_building_haiku_source_code">Getting and Building the Haiku Source Code&lt;/a> for details), run ./configure from the current/ directory, run jam from the current/ directory, and go watch The Godfather (possibly all three of them) while everything builds.&lt;/p></description></item><item><title>Optimization can be your friend</title><link>https://www.haiku-os.org/documents/dev/optimization_can_be_your_friend/</link><pubDate>Sun, 14 Jul 2002 09:00:00 +0000</pubDate><guid>https://www.haiku-os.org/documents/dev/optimization_can_be_your_friend/</guid><description>BodyOptimization is one of those topics that everyone thinks that they understand a little about, but is often surrounded by platitudes, mystery and rumour. I want to talk a little about when to optimize, why one should optimize and some of the more successful techniques of doing so.
Keep it simple The first rule of optimization is, &amp;quot;Don&amp;#39;t&amp;quot;. As Extreme Programming says, &amp;quot;Do the simplest thing that will work&amp;quot;. If you are working in an OO language, this is often fairly easy because of information hiding.</description></item><item><title>Hello kernel? You have a syscall from userland!</title><link>https://www.haiku-os.org/documents/dev/hello_kernel_you_have_a_syscall_from_userland/</link><pubDate>Sun, 14 Jul 2002 04:00:00 +0000</pubDate><guid>https://www.haiku-os.org/documents/dev/hello_kernel_you_have_a_syscall_from_userland/</guid><description>
&lt;div class="field field-type-text field-field-body">
&lt;div class="field-items">
&lt;div class="field-item odd">
&lt;p>&lt;strong>Note:&lt;/strong> this article was written by Daniel Reinhold. &lt;br />&lt;/p>&lt;p>One of the features of modern operating systems is the ability to separate application code from the critical code that implements the core of the system. Regular applications run in user mode (often referred to as userland) which means that they cannot directly manipulate the vital system data structures. This makes everything much more stable -- buggy apps may crash and burn themselves, but they can&amp;#39;t bring down the rest of the system. &lt;/p>&lt;p> The flipside to this protection is that userland code is walled off from the kernel code. This means, for example, that your application cannot directly call a kernel function. But the kernel implements many useful services that most apps would like to take advantage of. Indeed, that is one of the main purposes of the kernel -- to abstract all those icky underlying hardware details and provide a clean, consistent interface for applications. So how does all this useful interface ever get called and used? &lt;/p></description></item><item><title>It should just work</title><link>https://www.haiku-os.org/documents/dev/it_should_just_work/</link><pubDate>Sun, 02 Jun 2002 09:00:00 +0000</pubDate><guid>https://www.haiku-os.org/documents/dev/it_should_just_work/</guid><description>BodyI had a lot of company this weekend &amp;#151; it was really our first time entertaining in the new house (other than an occasional friend dropping by). I like to think that my friends are a fairly intelligent group. Birds of a feather and all. My friends often come to me for help with their computer &amp;quot;issues&amp;quot;, despite the fact that I haven&amp;#39;t run Windows as my OS of choice since 1996.</description></item><item><title>Device driver basics</title><link>https://www.haiku-os.org/documents/dev/device_driver_basics/</link><pubDate>Sat, 18 May 2002 09:00:00 +0000</pubDate><guid>https://www.haiku-os.org/documents/dev/device_driver_basics/</guid><description>BodyDevice drivers are difficult to write. Understanding the hardware can be the hardest part. Often the documentation is hard to read and understand because it is written from a hardware designer&amp;#39;s perspective (that is, if you can get the documentation -- many manufacturers are very reluctant to give it out). Drivers work directly with the kernel - a bad pointer can crash the whole OS. And, finally, you can&amp;#39;t use warm and comfortable debugging tools, since you are working in the kernel.</description></item><item><title>Let's make use of Thread Local Storage!</title><link>https://www.haiku-os.org/documents/dev/lets_make_use_of_thread_local_storage/</link><pubDate>Sat, 04 May 2002 09:00:00 +0000</pubDate><guid>https://www.haiku-os.org/documents/dev/lets_make_use_of_thread_local_storage/</guid><description>BodyTUTORIAL NEEDS REVISION - as stated in comments - "Note one should use initialize_after() and terminate_before() instead of _init() and _fini(), as the shared object crt code actually defines them already in BeOS, to do some dirty tricks, and call the initialize/terminate functions when present." - NEEDS REVISION
Last week, I came across an interesting problem which I had not dealt with before. Some people on IRC were discussing the testing of the new netkit, and had problems with the unimplemented libnet call _h_errnop(), which supposedly returns the address of the errno variable for network funcs.</description></item><item><title>Unit Testing</title><link>https://www.haiku-os.org/documents/dev/unit_testing/</link><pubDate>Sat, 06 Apr 2002 11:00:00 +0000</pubDate><guid>https://www.haiku-os.org/documents/dev/unit_testing/</guid><description>Unit testing is the process of showing that a part of a software system works as far as the requirements created for that part of the system. Unit testing is best if it has the following characteristics:
The software component is tested in isolation with as little interaction with other software components as possible. The software component is tested using automated tools so that unit tests can be run with every build of the software if required.</description></item><item><title>Binary Compatibility in 3 Easy Steps!</title><link>https://www.haiku-os.org/documents/dev/binary_compatibility_3_easy_steps/</link><pubDate>Sat, 09 Feb 2002 11:00:00 +0000</pubDate><guid>https://www.haiku-os.org/documents/dev/binary_compatibility_3_easy_steps/</guid><description>
&lt;div class="field field-type-text field-field-body">
&lt;div class="field-items">
&lt;div class="field-item odd">
&lt;p>In the early days of the Haiku project, a debate raged concerning one of the projects primary goals: maintaining binary compatibility with BeOS R5. The idea was that the only way an effort to rewrite BeOS would be successful was if folks could continue running the apps they already had.&lt;/p>
&lt;p>Certainly, a lot of software available for BeOS is open source or actively maintained -- these apps could just be recompiled if necessary. Others -- PostMaster, Gobe&amp;#39;s Productive suite and a few other crucial apps -- weren&amp;#39;t likely to get rebuilt, either because the original author had stopped maintenance without being kind enough to release the source, or because it just wouldn&amp;#39;t be commercially feasible.&lt;/p></description></item><item><title>CD-ROMs, Unit Testing, and You</title><link>https://www.haiku-os.org/documents/dev/cd_roms_unit_testing_and_you/</link><pubDate>Sat, 12 Jan 2002 11:00:00 +0000</pubDate><guid>https://www.haiku-os.org/documents/dev/cd_roms_unit_testing_and_you/</guid><description>BodyI will go out on a little bit of a limb and say that the single most important and beneficial step that you can take to improve your code is to test first. Yes, I know. I hate testing, too.
I picked up a few books on Extreme Programming several months ago. There are far more useful tidbits of knowledge in there than I can explain in a short article, but one of the most simple and useful is to take what you *hate* and do it *more*.</description></item><item><title>Division of Labor: Kits, Libraries, Servers, and Teams</title><link>https://www.haiku-os.org/documents/dev/division_of_labor_kits_libraries_servers_and_teams/</link><pubDate>Sun, 30 Dec 2001 04:00:00 +0000</pubDate><guid>https://www.haiku-os.org/documents/dev/division_of_labor_kits_libraries_servers_and_teams/</guid><description>BodyNote: this article was written by Daniel Reinhold.
I remember several years back (about spring &amp;#39;96) when I first discovered the joys of the internet and was amazed at the sheer number of goodies to be plucked. This was well before BeOS Intel, so I spent alot of time downloading Windows shareware programs. After a few months, however, the excitement died down considerably when I discovered an unfortunate truth: most of those shareware programs were complete crap.</description></item><item><title>Ufetch: a Basic Web Client</title><link>https://www.haiku-os.org/documents/dev/ufetch_a_basic_web_client/</link><pubDate>Sat, 15 Dec 2001 11:00:00 +0000</pubDate><guid>https://www.haiku-os.org/documents/dev/ufetch_a_basic_web_client/</guid><description>BodyThe web has certainly become one of the most ubiquitous and important publishing spaces around. What defines the web, technically, is html and http. Html is the publishing format and http is the transport protocol.
Let&amp;#39;s consider http. This protocol is so simple. Some would say simplistic &amp;#151; it certainly has it share of detractors. While it may not be the most sophisticated protocol around, it gets the job done.</description></item><item><title>Using Scripting in Haiku</title><link>https://www.haiku-os.org/documents/dev/using_scripting_in_haiku/</link><pubDate>Sat, 03 Nov 2001 11:00:00 +0000</pubDate><guid>https://www.haiku-os.org/documents/dev/using_scripting_in_haiku/</guid><description>BodyWith this article I hope to explain the basics of scripting using BeOS and how it can enhance the Haiku project. To try out several examples mentioned in this article, you&amp;#39;ll have to download a program called hey, which enables you to script BeOS applications from a Terminal.
The program hey was developed by Atilla Mezei, an early BeOS developer, who unfortunately seems to have left the BeOS community. He created this tool to have a good testing tool when implementing scripting in BeOS applications.</description></item></channel></rss>