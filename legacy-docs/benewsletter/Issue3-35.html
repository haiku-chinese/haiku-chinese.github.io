<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<!-- Mirrored from www.haiku-os.org/legacy-docs/benewsletter/Issue3-35.html by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 05 Aug 2021 01:41:59 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- /Added by HTTrack -->
<head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Be Newsletters - Volume 3: 1998</title><link rel="stylesheet" href="be_newsletter.css" type="text/css" media="all" /><link rel="shortcut icon" type="image/vnd.microsoft.icon" href="images/favicon.ico" /><!--[if IE]>
    <link rel="stylesheet" type="text/css" href="be_newsletter_ie.css" />
    <![endif]--><meta name="generator" content="DocBook XSL Stylesheets V1.73.2" /><link rel="start" href="index-2.html" title="Be Newsletters" /><link rel="up" href="volume3.html" title="Volume 3: 1998" /><link rel="prev" href="Issue3-34.html" title="Issue 3-34, August 26, 1998" /><link rel="next" href="Issue3-36.html" title="Issue 3-36, September 9, 1998" /></head><body><div id="header"><div id="headerT"><div id="headerTL"><a accesskey="p" href="Issue3-34.html" title="Issue 3-34, August 26, 1998"><img src="images/navigation/prev.png" alt="Prev" /></a> <a accesskey="u" href="volume3.html" title="Volume 3: 1998"><img src="images/navigation/up.png" alt="Up" /></a> <a accesskey="n" href="Issue3-36.html" title="Issue 3-36, September 9, 1998"><img src="images/navigation/next.png" alt="Next" /></a></div><div id="headerTR"><div id="navigpeople"><a href="../../index.html"><img src="images/People_24.png" alt="haiku-os.org" title="Visit The Haiku Website" /></a></div><div class="navighome" title="Home"><a accesskey="h" href="index-2.html"><img src="images/navigation/home.png" alt="Home" /></a></div><div class="navigboxed" id="naviglang" title="English">en</div></div><div id="headerTC">Be Newsletters - Volume 3: 1998</div></div><div id="headerB">Prev: <a href="Issue3-34.html">Issue 3-34, August 26, 1998</a>  Up: <a href="volume3.html">Volume 3: 1998</a>  Next: <a href="Issue3-36.html">Issue 3-36, September 9, 1998</a></div><hr /></div><div class="article"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h2 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="Issue3-35"></a>Issue 3-35, September 2, 1998</h2></div></div></div><div class="sect1"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h2 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="Engineering3-35"></a>Be Engineering Insights: An Introduction to the Input Server</h2></div><div xmlns:d="http://docbook.org/ns/docbook"><span xmlns="http://www.w3.org/1999/xhtml" class="author">By <span class="firstname">Hiroshi</span> <span class="surname">Lockheimer</span></span></div></div></div><p>
One of the many upcoming changes in the BeOS is in the world of input
devices and events. The Input Server, slated to debut in R4, is a server
that deals with all things "input." Specifically, it serves three
functions: manages input devices such as keyboards and mice; hosts a
stream of events that those devices generate; and dispatches those events
that make it through the stream.
</p><div class="sect2"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="id731695"></a>Managing Input Devices</h3></div></div></div><p>
The Input Server is a pretty dumb piece of software. (Cue to Alex: roll
your eyes and say, "What do you expect Hiroshi, you wrote it.") On its
own, the server doesn't know how a keyboard or a mouse works; it relies
on <code class="classname">BInputServerDevice</code> add-ons to tell it.
</p><p>
<code class="classname">BInputServerDevice</code> is a base class from which all input device add-ons
must derive. It provides the basic framework of virtual hook functions
and non-virtual member functions that the Input Server uses to
communicate with an add-on, and that the add-on can use to talk back to
the server. To give a sneak peak of the API, some of the virtuals include
<code class="methodname">InitCheck()</code>, <code class="methodname">Start()</code>,
<code class="methodname">Stop()</code>, and <code class="methodname">Control()</code>.
The common sequence of the life of an input device is this:
</p><div class="orderedlist"><ol><li><p>
The Input Server loads an add-on and constructs its
<code class="classname">BInputServerDevice</code>-derived object.
</p></li><li><p>
The Input Server calls <code class="methodname">InitCheck()</code> on the object. The object
determines whether it is capable of doing its job—that is,
generating input events.
</p></li><li><p>
This task may involve the object sniffing around for hardware it
can drive, or looking for a kernel device driver in
<code class="filename">/dev</code>. If the
object is happy, it registers with the Input Server any input
device(s) it finds, and returns <code class="constant">B_NO_ERROR</code>. An error return causes the
Input Server to promptly destruct the object and unload the add-on.
</p></li><li><p>
At some point in time, someone will tell the input devices
registered with the Input Server to <code class="methodname">Start()</code>. The system automatically
starts keyboards and mice at boot time. Any other type of device (an
"undefined" input device that the system doesn't have any special
knowledge about) can be started by an application using new API in the
Interface Kit.
</p></li><li><p>
A registered device, whether it has been started or not, may be
<code class="methodname">Control()</code>-ed at any time. Think of <code class="methodname">Control()</code>
as the <code class="function">ioctl()</code> equivalent
in input device parlance. Examples of system-defined control messages
include keymap changes and mouse speed changes.
</p></li></ol></div></div><div class="sect2"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="id731820"></a>Generating Input Events</h3></div></div></div><p>
Once a <code class="classname">BInputServerDevice</code>-derived object's input device is up and
running, its primary task is to generate input events. These events are
expressed as <code class="classname">BMessages</code>. For example, a keyboard input device will most
likely generate <code class="constant">B_KEY_DOWN</code> and <code class="constant">B_KEY_UP</code> messages. Similarly, a mouse
input device will probably generate <code class="constant">B_MOUSE_UP</code>, <code class="constant">B_MOUSE_DOWN</code>, and
<code class="constant">B_MOUSE_MOVED</code> events.
</p><p>
There is nothing that prevents an input device from putting arbitrary
data in any of the <code class="classname">BMessage</code>s it generates. So, for example, a tablet may
generate the aforementioned mouse events with extra data such as pressure
and proximity. Any information packed into the <code class="classname">BMessage</code>s is delivered
unmolested by the input server.
</p><p>
When an event is ready to be shipped off, an input device enqueues it
into the Input Server's event stream. Some <code class="classname">BHandler</code>
(most likely a <code class="classname">BView</code>)
down the line eventually receives the event by way of the usual hook
functions such as <code class="methodname">KeyDown()</code>, <code class="methodname">MouseDown()</code>,
and <code class="methodname">MouseMoved()</code>.
</p></div><div class="sect2"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="id731904"></a>The Input Event Stream</h3></div></div></div><p>
The Input Server's event stream is open for inspection and alteration by
anyone in the system. This is achieved through another set of add-ons
called <code class="classname">BInputServerFilter</code>. Like
<code class="classname">BInputServerDevice</code>, <code class="classname">BInputServerFilter</code> is
a base class for input filter add-ons to the Input Server.
</p><p>
An input filter add-on is privy to all the events that pass through the
Input Server's event stream. A filter may inspect, alter, generate, or
completely drop input events. It's similar in some ways to the Interface
Kit's <code class="classname">BMessageFilter</code>, but much more low-level.
A <code class="classname">BInputServerFilter</code> sees
all events that exist in the system; <code class="classname">BMessageFilter</code>s are associated with
a specific <code class="classname">BLooper</code> and thus see only the events
targeted to its <code class="classname">BLooper</code>.
Also, filters in the Input Server can generate additional events in place
of, or in addition to, the original input event that it was invoked with.
</p></div><div class="sect2"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="id731961"></a>Conclusion</h3></div></div></div><p>
With the introduction of loadable input device objects, the Input Server
enables the BeOS to be used with a wide variety of input devices (and
more than one of them at once too). And with the advent of input filters,
the Input Server opens the door to a new class of tricks, hacks, and
(gulp) pranks for the creative developer. It's going to be fun.
</p></div></div><hr class="pagebreak" /><div class="sect1"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h2 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="Engineering3-35-2"></a>Be Engineering Insights: Kernel Driver Tips and Traps</h2></div><div xmlns:d="http://docbook.org/ns/docbook"><span xmlns="http://www.w3.org/1999/xhtml" class="author">By <span class="firstname">Trey</span> <span class="surname">Boudreau</span></span></div></div></div><p>
This is my first Newsletter article, so let me introduce myself. I'm Trey
Boudreau, and I write graphics drivers at Be. Or not exactly "at" Be,
since I'm one of a few Be employees not located in either Menlo Park or
Paris.
</p><p>
That's it for the introduction—now some content...
</p><p>
As anybody who's been around the BeOS awhile knows, graphics drivers are
app_server add-ons and not kernel drivers. So why is the graphics guy
writing about kernel drivers? Because in R4 all graphics drivers have a
kernel driver component, as well as a user space add-on (called an
accelerant).
</p><p>
I could talk about writing R4 graphics drivers, but since you don't have
R4 yet that wouldn't be too useful. Instead, how about some handy tips
for writing kernel drivers, since I've been doing a lot of that lately.
I'll assume you've read the Be Book Device Drivers chapter -
<a class="link bebook" href="../BeBook/DeviceDrivers-2.html">DeviceDrivers.html</a> -
even if you haven't written a device driver yet.
</p><div class="sect2"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="id732048"></a>Thread Safety and Such</h3></div></div></div><p>
Even though we don't come right out and say it, the exported entry points
to your driver are guaranteed to be executed sequentially. Said another
way, the functions <code class="function">init_hardware()</code>,
<code class="function">init_driver()</code>, <code class="function">uninit_driver()</code>,
<code class="function">publish_devices()</code>, and <code class="function">find_device()</code>
are only executed one at time, so
there's no need to protect them from one another. On the other hand, all
the hook functions must be thread safe. Specifically, <code class="function">open_hook()</code> must
properly handle simultaneous open attempts.
</p></div><div class="sect2"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="id732088"></a>Interrupt Handlers and Multiple Devices</h3></div></div></div><p>
The PowerPC-based machines we support cannot chain (or share) interrupts,
but Intel-based machines can. The <acronym class="acronym">API</acronym> for installing and removing
handlers in R3.x makes installing interrupt handlers on Intel hardware in
the presence of multiple supported devices more complicated than it first
appears. Here's the API (from
<code class="filename">KernelExport.h</code>):
</p><pre class="programlisting c">
typedef <span class="type">bool</span> (*<span class="type">interrupt_handler</span>)(<span class="type">void *</span><code class="parameter">data</code>);

<span class="type">long</span> <code class="function">install_io_interrupt_handler</code>(
  <span class="type">long</span>   <code class="varname">interrupt_number</code>,
  <span class="type">interrupt_handler</span> <code class="varname">handler</code>,
  <span class="type">void   *</span><code class="varname">data</code>,
  <span class="type">ulong</span>  <code class="varname">flags</code>);

<span class="type">long</span> <code class="function">remove_io_interrupt_handler</code>(
  <span class="type">long</span>   <code class="varname">interrupt_number</code>,
  <span class="type">interrupt_handler</span> <code class="varname">handler</code>);
</pre><p>
And here's the scenario:
</p><div class="orderedlist"><ol><li><p>
PCI device A gets IRQ X.
</p></li><li><p>
PCI device B gets IRQ X.
</p></li><li><p>
Program opens device A, driver installs interrupt handler with
device specific data A.
</p></li><li><p>
Program opens device B, driver installs interrupt handler with
device specific data B.
</p></li><li><p>
Program closes device B, driver removes interrupt handler.
</p></li></ol></div><p>
Notice that <code class="function">remove_io_interrupt_handler()</code> doesn't take a
<span class="type">void* data</span>, so
there's no way to know which handler to remove. The implementation of
remove is such that the first entry in the chain matching the handler is
removed—in this case the handler for device A. As a result the handler
for device A is never called, even though device A is still open, and the
handler for B to be called even though the device is closed.
</p><p>
The basic solution is to write the interrupt handler to handle all your
supported devices that have the same interrupt number with a single
installation of the handler. The easiest way to do this is to install the
interrupt handler at driver initialization time, and remove it at driver
uninitialization. The more difficult way is to install it at device open
and remove at device close, making sure you don't install it twice or
remove it before it's finished.
</p><p>
Now the good news. In R4, the prototype for the remove function will
change to
</p><pre class="programlisting c">
<span class="type">long</span> <code class="function">remove_io_interrupt_handler</code>(
  <span class="type">long</span>   <code class="varname">interrupt_number</code>,
  <span class="type">interrupt_handler</span> <code class="varname">handler</code>,
  <span class="type">void   *</span><code class="varname">data</code>);
</pre><p>
This change is not source compatible but is binary compatible. The remove
function first walks the list trying to match handler *and* data (which
should always work for drivers using the new API). If no match is found,
it walks the list again attempting to match only the handler.
</p></div><div class="sect2"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="id732307"></a>Debugging Interrupt Handlers</h3></div></div></div><p>
While we're on the subject of interrupt handlers, here are some tips to
help debug them. In his Developer's Workshop article
</p><p>
<a class="xref" href="Issue3-21.html#DevWorkshop3-21" title="Developers' Workshop: Welcome to the Cow...Debugging Device Drivers">Developers' Workshop: Welcome to the Cow...Debugging Device Drivers</a>
</p><p>
Victor Tsou talked about using kernel debugger commands to help in the
postmortem afterglow. He mentioned using <code class="function">k<code class="function">printf</code>()</code> to output info while
in the debugger.
</p><p>
It's useful to note that <code class="function">k<code class="function">printf</code>()</code> also works in the interrupt handler.
If your device is generating interrupts at a decent rate, you can flood
the serial port with *lots* of output using <code class="function">k<code class="function">printf</code>()</code>, so use it
sparingly. Because it's possible to share interrupts on Intel platforms,
you may want to have one variable that counts trips through the handler
(whether for your device or not) and one variable for each device which
might generate an interrupt.
</p><p>
In your kernel debugger command output, include the current values of the
total trips and individual hits for each of your devices. Whenever you
want to check the status of your driver, press
<span class="keysym">Alt</span>+<span class="keysym">SysReq</span> on Intel
machines (<span class="keysym">Command</span>+<span class="keysym">PowerKey</span>
on Power Macs) to drop into the debugger. On a
BeBox, just tap the debugger button on the front panel.
</p></div><div class="sect2"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="id732394"></a>write_pci_config() Bug on Intel</h3></div></div></div><p>
Unfortunately, we introduced a bug in R3.1 for Intel regarding
<code class="function">write_pci_config()</code>. When calling
<code class="function">write_pci_config()</code> with a size of 1 or 2
bytes, the other bytes in the 32-bit aligned word (i.e., the ones you
wanted to leave unchanged) are zeroed. Here's an example: You want to
change the value of the PCI configuration space byte at offset 0x41. The
byte at offset 0x41 is part of a 32-bit word starting at offset 0x40.
When you call
</p><pre class="programlisting c">
<code class="function">write_pci_config</code>(<code class="varname">bus</code>,<code class="varname">dev</code>,<code class="varname">fun</code>,0x41,1,<code class="varname">val</code>)
</pre><p>
the bytes at offsets 0x40, 0x42, and 0x43 are zeroed. The work around for
this problem is to do a read-modify-write on the 32-bit aligned word:
</p><pre class="programlisting c">
<span class="type">uint32</span> <code class="varname">val</code> = <code class="varname">something</code>;
<span class="type">uint32</span> <code class="varname">tmp</code> = <code class="function">read_pci_config</code>(<code class="varname">bus</code>,<code class="varname">dev</code>,<code class="varname">fun</code>,0x40,4);
<code class="varname">tmp</code> &amp;= 0xffff00ff;
<code class="varname">tmp</code> |= <code class="varname">val</code> &lt;&lt; 8;
<code class="function">write_pci_config</code>(<code class="varname">bus</code>,<code class="varname">dev</code>,<code class="varname">fun</code>,0x40,4,<code class="varname">tmp</code>);
</pre><p>
This will be fixed in R4, but I don't know if we'll provide a fix for
R3.2+ We'll post a notice about the update if we do.
</p></div><div class="sect2"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="id732526"></a>The Obligatory R4 Teaser</h3></div></div></div><p>
No Newsletter article this close to the R4 release would be complete
without a teaser about new features. In addition to the new
module/bus-based drivers (described by Arve Hjønnevåg in his Newsletter
article <a class="xref" href="Issue3-20.html#Engineering3-20" title="Be Engineering Insights: Splitting Device Drivers and Bus Managers">Be Engineering Insights: Splitting Device Drivers and Bus Managers</a>, the driver API
sports a few new hooks: <code class="function">readv()</code>, <code class="function">writev()</code>,
<code class="function">select()</code>, and <code class="function">deselect()</code>.
</p><p>
<code class="function">readv()</code> and <code class="function">writev()</code> support
scatter/gather or vector-based I/O. See your
favorite Linux manpages for reasonable documentation. <code class="function">select()</code> and
<code class="function">deselect()</code> provide support for (you guessed it)
the <code class="function">select()</code> system call.
Details of these features are subject to further changes, so all I can
really report is that they exist.
</p></div><div class="sect2"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="id732587"></a>Thanks for Stopping By</h3></div></div></div><p>
That about wraps up my premier Newsletter article. Let me remind you as
one of the graphics driver guys, if you've got questions about writing
graphics drivers for the BeOS, I'm your man. Drop me a note at
trey@be.com.
</p></div></div><hr class="pagebreak" /><div class="sect1"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h2 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="DevWorkshop3-35"></a>Developers Workshop: BeOS Programming Basics, Part 6</h2></div><div xmlns:d="http://docbook.org/ns/docbook"><span xmlns="http://www.w3.org/1999/xhtml" class="author">By <span class="firstname">Eric</span> <span class="surname">Shepherd</span></span></div></div></div><p>
This week, we're going to relax a little and put together a nice, simple
class for saving program settings to disk. You can download the source
code for this week's project from the Be FTP site:
</p><p>
ftp://ftp/pub/samples/intro/prefs_article.zip
</p><p>
The <code class="classname">BMessage</code> provides a handy container for data. Although its primary
use is for sending data between two pieces of software, its tagged data
item format is ideal for use as a cross-platform data storage mechanism.
Thus we introduce the <code class="classname">TPreferences</code> class, which is derived from <code class="classname">BMessage</code>:
</p><pre class="programlisting cpp">
class <code class="classname">TPreferences</code> : public <code class="classname">BMessage</code> {
  public:
    <code class="methodname">TPreferences</code>(<span class="type">char *</span><code class="parameter">filename</code>);
    <code class="methodname">~TPreferences</code>();

    <span class="type">status_t</span>    <code class="methodname">InitCheck</code>(<span class="type">void</span>);
    <span class="type">status_t</span>    <code class="methodname">SetBool</code>(<span class="type">const char *</span><code class="parameter">name</code>, <span class="type">bool</span> <code class="parameter">b</code>);
    <span class="type">status_t</span>    <code class="methodname">SetInt8</code>(<span class="type">const char *</span><code class="parameter">name</code>, <span class="type">int8</span> <code class="parameter">i</code>);
    <span class="type">status_t</span>    <code class="methodname">SetInt16</code>(<span class="type">const char *</span><code class="parameter">name</code>, <span class="type">int16</span> <code class="parameter">i</code>);
    <span class="type">status_t</span>    <code class="methodname">SetInt32</code>(<span class="type">const char *</span><code class="parameter">name</code>, <span class="type">int32</span> <code class="parameter">i</code>);
    <span class="type">status_t</span>    <code class="methodname">SetInt64</code>(<span class="type">const char *</span><code class="parameter">name</code>, <span class="type">int64</span> <code class="parameter">i</code>);
    <span class="type">status_t</span>    <code class="methodname">SetFloat</code>(<span class="type">const char *</span><code class="parameter">name</code>, <span class="type">float</span> <code class="parameter">f</code>);
    <span class="type">status_t</span>    <code class="methodname">SetDouble</code>(<span class="type">const char *</span><code class="parameter">name</code>, <span class="type">double</span> <code class="parameter">d</code>);
    <span class="type">status_t</span>    <code class="methodname">SetString</code>(<span class="type">const char *</span><code class="parameter">name</code>,
                          <span class="type">const char *</span><code class="parameter">string</code>);
    <span class="type">status_t</span>    <code class="methodname">SetPoint</code>(<span class="type">const char *</span><code class="parameter">name</code>, <code class="classname">BPoint</code> <code class="parameter">p</code>);
    <span class="type">status_t</span>    <code class="methodname">SetRect</code>(<span class="type">const char *</span><code class="parameter">name</code>, <code class="classname">BRect</code> <code class="parameter">r</code>);
    <span class="type">status_t</span>    <code class="methodname">SetMessage</code>(<span class="type">const char *</span><code class="parameter">name</code>,
                           <span class="type">const<code class="classname">BMessage</code> *</span><code class="parameter">message</code>);
    <span class="type">status_t</span>    <code class="methodname">SetFlat</code>(<span class="type">const char *</span><code class="parameter">name</code>,
                        <span class="type">const<code class="classname">BFlattenable</code> *</span><code class="parameter">obj</code>);

  private:
    <code class="classname">BPath</code>      <code class="varname">path</code>;
    <span class="type">status_t</span>    <code class="varname">status</code>;
};
</pre><p>
The most obvious additions here, beyond the normal <code class="classname">BMessage</code>
functionality, are all the
<code class="methodname">SetX()</code>
functions. These let an application explicitly set the value of a tagged
item in the <code class="classname">TPreferences</code> object, without having to determine whether to
call <code class="methodname">AddX()</code> or <code class="methodname">ReplaceX()</code>.
This is very useful when treating a <code class="classname">BMessage</code>
as a data container.
</p><p>
We'll be taking advantage of the fact that a <code class="classname">BMessage</code> is derived from
<code class="classname">BFlattenable</code>. Objects derived from
<code class="classname">BFlattenable</code> can be "flattened" into a
dehydrated format and saved to disk, then later reconstituted
("unflattened") into a duplicate of the original. Flattened objects are
endianess-independent, so we get cross-system compatibility between
PowerPC and Intel absolutely 100% free of charge. As programmers, we like
things that are actually free (and there aren't many).
</p><p>
Let's have a look at the constructor:
</p><pre class="programlisting cpp">
<code class="classname">TPreferences</code>::<code class="methodname">TPreferences</code>(<span class="type">char *</span><code class="parameter">filename</code>) : <code class="classname">BMessage</code>('pref') {
  <code class="classname">BFile</code> <code class="varname">file</code>;

  <code class="varname">status</code> = find_directory(<code class="constant">B_COMMON_SETTINGS_DIRECTORY</code>, &amp;<code class="varname">path</code>);
  if (<code class="varname">status</code> != <code class="constant">B_OK</code>) {
    return;
  }
  <code class="varname">path</code>.<code class="methodname">Append</code>(<code class="parameter">filename</code>);
  <code class="varname">status</code> = <code class="varname">file</code>.<code class="methodname">SetTo</code>(<code class="varname">path</code>.<code class="methodname">Path</code>(), <code class="constant">B_READ_ONLY</code>);
  if (<code class="varname">status</code> == <code class="constant">B_OK</code>) {
    <code class="varname">status</code> = <code class="methodname">Unflatten</code>(&amp;<code class="varname">file</code>);
  }
}
</pre><p>
The constructor's primary responsibility here is to open the preference
file and read in the original settings. First, <code class="function">find_directory()</code> is called
to obtain a <code class="classname">BPath</code> referencing the common settings directory (i.e.,
<code class="filename">/boot/home/config/settings</code>).
If this fails, the <code class="classname">TParameter</code> field <code class="varname">status</code>
is set to the error code and the constructor returns. The application can
use the <code class="methodname">InitCheck()</code> function to determine whether or not the preferences
were read successfully.
</p><p>
If all is well, the preference file name is appended to the path, and the
<code class="classname">BFile</code> is set to read that file. If this succeeds, the file's contents are
unflattened into the <code class="classname">TPreferences</code> object.
</p><p>
The destructor's job is to save the preferences to disk:
</p><pre class="programlisting cpp">
<code class="classname">TPreferences</code>::<code class="methodname">~TPreferences</code>() {
  <code class="classname">BFile</code> <code class="varname">file</code>;

  if (<code class="varname">file</code>.<code class="methodname">SetTo</code>(<code class="varname">path</code>.<code class="methodname">Path</code>(),
    <code class="constant">B_WRITE_ONLY</code> | <code class="constant">B_CREATE_FILE</code>) == <code class="constant">B_OK</code>) {
      <code class="methodname">Flatten</code>(&amp;<code class="varname">file</code>);
  }
}
</pre><p>
This creates a <code class="classname">BFile</code> object, sets the path to the preference file's
pathname (which has been saved in the path field in the <code class="classname">TPreferences</code>
object), and then flattens the <code class="classname">TPreferences</code> data into the file.
</p><p>
The various <code class="methodname">SetX()</code> functions all look about the same, so we'll
arbitrarily look at <code class="methodname">SetBool()</code> as a representative of its kin:
</p><pre class="programlisting cpp">
<span class="type">status_t</span> <code class="classname">TPreferences</code>::<code class="methodname">SetBool</code>(<span class="type">const char *</span><code class="parameter">name</code>, <span class="type">bool</span> <code class="parameter">b</code>) {
  if (<code class="methodname">HasBool</code>(<code class="parameter">name</code>)) {
    return <code class="methodname">ReplaceBool</code>(<code class="parameter">name</code>, 0, <code class="parameter">b</code>);
  }

  return <code class="methodname">AddBool</code>(<code class="parameter">name</code>, <code class="parameter">b</code>);
}
</pre><p>
<code class="methodname">SetBool()</code> accepts an item name and a boolean value to save with that
name. The function begins by calling <code class="methodname">HasBool()</code> to see if a boolean by the
indicated name already exists. If it does, <code class="methodname">ReplaceBool()</code> is used to
replace the existing value. Otherwise, <code class="methodname">AddBool()</code> is called to add a new
boolean with the given name. <code class="constant">B_OK</code> is returned if all is well; otherwise,
an error is returned.
</p><p>
Note that the <code class="classname">TPreferences</code> class doesn't support item arrays; you can
only save one item with a given name. In general, this shouldn't be a
problem.
</p><p>
That's the basics of implementing the <code class="classname">TPreferences</code> class. Now, a simple
example that demonstrates its use. This little program keeps two values
in its preference file: the real-time clock value at which the program
was last run, and the number of times it's been run. When you run the
program, it shows you the current values, then updates them.
</p><p>
The whole program (see <code class="filename">sample.cpp</code>) is contained
in <code class="function">main()</code>. Let's look at
it one bit at a time:
</p><pre class="programlisting cpp">
<code class="classname">TPreferences</code> <code class="varname">prefs</code>("PrefsSample_prefs");   <span class="comment">// Preferences</span>
if (<code class="varname">prefs</code>.<code class="methodname">InitCheck</code>() != <code class="constant">B_OK</code>) {
  <code class="varname">prefs</code>.<code class="methodname">SetInt64</code>("last_used", <code class="function">real_time_clock</code>());
  <code class="varname">prefs</code>.<code class="methodname">SetInt32</code>("use_count", 0);
}
</pre><p>
This code instantiates our <code class="classname">TPreferences</code> object. The preference file's
name is <code class="filename">PrefsSample_prefs</code> (so its full path is
<code class="filename">/boot/home/config/settings/PrefsSample_prefs</code>). Once it's instantiated, we
call <code class="methodname">InitCheck()</code> to see if all is well. If it's not, we initialize the
two values: <code class="varname">last_used</code> is initialized to the current real- time clock
value, and <code class="varname">use_count</code> is set to zero.
Then we call <code class="methodname">PrintToStream()</code> to print out the contents of the
<code class="classname">TPreferences</code> object:
</p><pre class="programlisting cpp">
<code class="varname">prefs</code>.<code class="methodname">PrintToStream</code>();
</pre><p>
Finally, we update the preferences:
</p><pre class="programlisting cpp">
<span class="type">int32</span> <code class="varname">count</code>;
if (<code class="varname">prefs</code>.<code class="methodname">FindInt32</code>("use_count", &amp;<code class="varname">count</code>) != <code class="constant">B_OK</code>) {
  <code class="varname">count</code> = 0;
}
<code class="varname">prefs</code>.<code class="methodname">SetInt64</code>("last_used", <code class="function">real_time_clock</code>());
<code class="varname">prefs</code>.<code class="methodname">SetInt32</code>("use_count", ++<code class="varname">count</code>);
</pre><p>
We call <code class="methodname">FindInt32()</code> to get the current
value of the <code class="varname">use_count</code>
preference. If an error occurs, we set it to zero as a safe alternative.
Then we call <code class="methodname">SetInt64()</code> to set <code class="varname">last_used</code>
to the <code class="function">real_time_clock()</code>
value, and <code class="methodname">SetInt32()</code> to set
<code class="varname">use_count</code> to one greater than the previous
value.
</p><p>
That's all there is to it. Since the <code class="classname">TPreferences</code> destructor
automatically saves the settings, we don't have to do anything else. Go
ahead and compile the project, then run it a few times, and you'll see
that, indeed, the values go up every time you run it.
</p><p>
That's a wrap for this time. We'll move on to our next project in about
six weeks.
</p></div><hr class="pagebreak" /><div class="sect1"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h2 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="Gassee3-35"></a>The Future of the PC Architecture</h2></div><div xmlns:d="http://docbook.org/ns/docbook"><span xmlns="http://www.w3.org/1999/xhtml" class="author">By <span class="firstname">Jean-Louis</span> <span class="surname">Gassée</span></span></div></div></div><p>
Looking back to 1981, when the first
<acronym class="acronym" title="International Business Machines">IBM</acronym>
PC came out, it's hard not to
wonder how far its
<acronym class="acronym" title="Deoxy-ribonucleic Acid">DNA</acronym>
will allow it to grow. Today's dual-processor 450
MHz Pentium II system is a direct descendant of its 8086-based Apple ][
competitor, down to the cassette player interface.
</p><p>
The good news is the PC market grew out of a succession of compatible
developments, both hardware and software. The bad news is today's PC
carries with it a certain amount of baggage. At each step along what now
looks like a glorious road, compromises were made. New technology had to
be grafted onto the existing frame; it had to keep running the old
software and keep supporting the previous generation of hardware devices.
</p><p>
Look at the back of a PC today, or open the box, and you'll see a few
examples. <acronym class="acronym" title="universal Serial Bus">USB</acronym>
ports must co-exist with serial and parallel connectors,
<acronym class="acronym" title="Peripheral Component Interconnect">PCI</acronym>
and older ISA buses fight for space on the motherboard, and these are
but the most visible examples. Other instances, perhaps more painful
ones, are buried in the chipset and the
<acronym class="acronym" title="Basic Input Output System">BIOS</acronym>.
</p><p>
Today's high-end, yet highly affordable dual processor system offers
yesterday's supercomputer power. How much is wasted because of the old
compatibility layers? How fast would this dual-processor system be if it
were built from the ground up with today's technology—and only today's
technology? And how much less would it cost than the current standard?
</p><p>
So far, the market has answered: the benefits of the incremental approach
outweigh its disadvantages. The PS/2 and
<acronym class="acronym" title="Advanced Computing Environment">ACE</acronym> attempts to create a
*better* PC architecture have failed against the evolutionary approach.
But, just as the stock market does not go up forever, just as no tree
reaches the sky, the progressive approach is bound to reach its limit
someday.
</p><p>
And why should we care? Shouldn't we stick to our unfinished knitting?
Certainly, but we can't help lifting our gaze from it and dreaming of
even faster and cheaper hardware, even if we're not really in a position
to influence hardware standards.
</p><p>
Following last week's
<acronym class="acronym" title="Other People's Operating Systems">OPOS</acronym> argument
<a class="xref" href="Issue3-34.html#Gassee3-34" title="OPH and OPOS">OPH and OPOS</a>
though, imagine a situation where Microsoft managed to effectively
dictate a new PC standard running Windows NT 5.0 at the next WinHEC
(Windows Hardware Engineering Conference) and have it embraced by enough
vendors to give it critical mass. Wouldn't everyone, including our little
company, benefit from such a liberating leap?
</p><p>
A truly perplexing perspective.
</p></div></div><div id="footer"><hr /><div id="footerT">Prev: <a href="Issue3-34.html">Issue 3-34, August 26, 1998</a>  Up: <a href="volume3.html">Volume 3: 1998</a>  Next: <a href="Issue3-36.html">Issue 3-36, September 9, 1998</a> </div><div id="footerB"><div id="footerBL"><a href="Issue3-34.html" title="Issue 3-34, August 26, 1998"><img src="images/navigation/prev.png" alt="Prev" /></a> <a href="volume3.html" title="Volume 3: 1998"><img src="images/navigation/up.png" alt="Up" /></a> <a href="Issue3-36.html" title="Issue 3-36, September 9, 1998"><img src="images/navigation/next.png" alt="Next" /></a></div><div id="footerBR"><div><a href="../../index.html"><img src="images/People_24.png" alt="haiku-os.org" title="Visit The Haiku Website" /></a></div><div class="navighome" title="Home"><a accesskey="h" href="index-2.html"><img src="images/navigation/home.png" alt="Home" /></a></div></div><div id="footerBC"><a href="http://www.access-company.com/home.html" title="ACCESS Co."><img alt="Access Company" src="images/access_logo.png" /></a></div></div></div><div id="licenseFooter"><div id="licenseFooterBL"><a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/3.0/" title="Creative Commons License"><img alt="Creative Commons License" style="border-width:0" src="../../../licensebuttons.net/l/by-nc-nd/3.0/88x31.png" /></a></div><div id="licenseFooterBR"><a href="LegalNotice.html">Legal Notice</a></div><div id="licenseFooterBC"><span id="licenseText">This work is licensed under a
          <a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/3.0/">Creative
          Commons Attribution-Non commercial-No Derivative Works 3.0 License</a>.</span></div></div><!-- Fathom -->
<script>
(function(f, a, t, h, o, m){
	a[h]=a[h]||function(){
		(a[h].q=a[h].q||[]).push(arguments)
	};
	o=f.createElement('script'),
	m=f.getElementsByTagName('script')[0];
	o.async=1; o.src=t; o.id='fathom-script';
	m.parentNode.insertBefore(o,m)
})(document, window, '../../../metrics.haiku-os.org/tracker.js', 'fathom');
fathom('trackPageview');
</script>
<!-- / Fathom --></body>
<!-- Mirrored from www.haiku-os.org/legacy-docs/benewsletter/Issue3-35.html by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 05 Aug 2021 01:42:00 GMT -->
</html>
