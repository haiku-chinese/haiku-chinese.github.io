<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<!-- Mirrored from www.haiku-os.org/legacy-docs/benewsletter/Issue3-27.html by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 05 Aug 2021 01:41:55 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- /Added by HTTrack -->
<head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Be Newsletters - Volume 3: 1998</title><link rel="stylesheet" href="be_newsletter.css" type="text/css" media="all" /><link rel="shortcut icon" type="image/vnd.microsoft.icon" href="images/favicon.ico" /><!--[if IE]>
    <link rel="stylesheet" type="text/css" href="be_newsletter_ie.css" />
    <![endif]--><meta name="generator" content="DocBook XSL Stylesheets V1.73.2" /><link rel="start" href="index-2.html" title="Be Newsletters" /><link rel="up" href="volume3.html" title="Volume 3: 1998" /><link rel="prev" href="Issue3-26.html" title="Issue 3-26, July 1, 1998" /><link rel="next" href="Issue3-28.html" title="Issue 3-28, July 15, 1998" /></head><body><div id="header"><div id="headerT"><div id="headerTL"><a accesskey="p" href="Issue3-26.html" title="Issue 3-26, July 1, 1998"><img src="images/navigation/prev.png" alt="Prev" /></a> <a accesskey="u" href="volume3.html" title="Volume 3: 1998"><img src="images/navigation/up.png" alt="Up" /></a> <a accesskey="n" href="Issue3-28.html" title="Issue 3-28, July 15, 1998"><img src="images/navigation/next.png" alt="Next" /></a></div><div id="headerTR"><div id="navigpeople"><a href="../../index.html"><img src="images/People_24.png" alt="haiku-os.org" title="Visit The Haiku Website" /></a></div><div class="navighome" title="Home"><a accesskey="h" href="index-2.html"><img src="images/navigation/home.png" alt="Home" /></a></div><div class="navigboxed" id="naviglang" title="English">en</div></div><div id="headerTC">Be Newsletters - Volume 3: 1998</div></div><div id="headerB">Prev: <a href="Issue3-26.html">Issue 3-26, July 1, 1998</a>  Up: <a href="volume3.html">Volume 3: 1998</a>  Next: <a href="Issue3-28.html">Issue 3-28, July 15, 1998</a></div><hr /></div><div class="article"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h2 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="Issue3-27"></a>Issue 3-27, July 8, 1998</h2></div></div></div><div class="sect1"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h2 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="Engineering3-27"></a>Be Engineering Insights: Porting WinSock Applications to the BeOS</h2></div><div xmlns:d="http://docbook.org/ns/docbook"><span xmlns="http://www.w3.org/1999/xhtml" class="author">By <span class="firstname">Russ</span> <span class="surname">McMahon</span></span></div></div></div><p>
The Windows Sockets <acronym class="acronym" title="Application Programming INterface">API</acronym>,
or just WinSock, has become synonymous with
Microsoft Windows-based network programming. There are literally
thousands of applications that have used WinSock to communicate over
<acronym class="acronym">TCP/IP</acronym> networks. If the application is on NT, Win95, or Windows and it's
connected to the "net" it's a sure bet the application is using WinSock.
</p><p>
This article is a primer on porting the WinSock portions of Microsoft
Windows code over to the BeOS. So now is the time to talk to your Win32
developer friends (admit it—you have a few) and get that cool Internet
application ported to the BeOS.
</p><p>
First, a bit of history. Back in the dark ages of Windows development
(3.0) there was a major push to get PCs connected to each other, not just
in the local area but also to the larger world outside. <acronym class="acronym">TCP/IP</acronym> and a much
smaller Internet already did just that, but not for Microsoft Windows
users.
</p><p>
Enter the <acronym class="acronym">TCP/IP</acronym> vendors. Each offered a
Windows-based <acronym class="acronym">TCP/IP</acronym> stack, but
with no a standard API to program to, developers had to choose which
vendor to go with, and often had to support multiple <acronym class="acronym">TCP/IP</acronym> stacks. Then
along came the WinSock specifications, a single networking <acronym class="acronym">API</acronym> that all
the major stack vendors including Microsoft agreed to. Application
writers could now program to one <acronym class="acronym">API</acronym> and have the application run on any
vendor's <acronym class="acronym">TCP/IP</acronym> implementation. The dark ages of network programing for
Windows were over, sort of.
</p><p>
The WinSock specification was based on the Berkeley Sockets interface
popular in the <acronym class="acronym">BSD</acronym> (Berkeley Software Distribution) version of UNIX. But
UNIX is a multitasking system, and blocking a process does not totally
hog the <acronym class="acronym">CPU</acronym> and keep it from running other processes. When WinSock was
created, however, Windows was a non-preemptive, single-tasking <acronym class="acronym">OS</acronym>.
Blocking a process completely locked up the system, and the only remedy
was the infamous hard reboot.
</p><p>
Developers went to great lengths to yield control to other processes.
Asynchronous <acronym class="acronym">API</acronym>s and message callbacks that would yield the <acronym class="acronym">CPU</acronym> and be
good citizens in the Windows world were built into the WinSock
specifications. They were given the prefix <acronym class="acronym">WSA</acronym>, for Windows Sockets
Asynchronous. Many developers still use the asynchronous calls even now,
although NT and WinX are preemptive multitasking systems that support
blocking calls without locking up the entire system.
</p><p>
BeOS Networking, like WinSock, modeled the programming interface after
Berkeley Sockets to provide developers with a well-defined and understood
programming interface. The BeOS, however, is a preemptive multitasking
system, so there was no need to include the asynchronous calls provided
in WinSock. Developers writing network applications for the BeOS simply
used the Sockets interface, as described in many UNIX books, to connect
to TCP/IP networks.
</p><p>
It's interesting to note that both BeOS and WinSock provide application
support for sockets in dynamic link libraries. For WinSock the calls are
in <code class="filename">WinSock.dll</code> or
<code class="filename">WSock32.dll</code>, with
<code class="filename">WinSock.h</code> being the main header. With
BeOS networking the calls are in <code class="filename">LibNet.so</code>
and the main header file is
Socket.h.
</p><p>
Where am I going with this? Well, it should be fairly clear that the two
interfaces have a lot in common, so much of the porting will be just
copying the network chunks of code and recompiling. The biggest obstacle
is getting around a WinSock API beast called <code class="function">WSAAsyncSelect()</code>. This is
the call WinSock developers use to yield <acronym class="acronym">CPU</acronym> control during long network
activity. The basic function of <code class="function">WSAAsyncSelect()</code>
is to give the <acronym class="acronym">TCP/IP</acronym>
stack enough information to notify the network application of some
network event of interest. The main parameters given to <code class="function">WSAAsyncSelect()</code>
are a callback procedure handle, and flags that define the network events
the application is interested in being notified about.
</p><p>
Okay enough background. Now let's do a simple port, nothing fancy or
overly ambitious this time—we'll save porting the sample
<acronym class="acronym" title="HyperText Transport Protocol">HTTP</acronym> server
for a future article. For this port I grabbed a WinSock sample
application off the <acronym class="acronym">MSDN</acronym> (Microsoft Developers Network) CD. The sample is
a simple server that listens and accepts client connections. It receives
a small string sent by the client, returns the string, and closes the
client connection.
</p><p>
I ported the sample by directly copying much of the networking code into
my BeOS application, then used threads instead of <code class="function">WSAAsyncSelect()</code> to
handle the client connections. I purposely left out error return codes
and much of the "nitty gritty" detail to focus on the porting task at
hand. For testing the server I used <span class="application">Telnet</span> to connect to the example
server, then sent a small string. For example,
</p><pre class="screen">
$telnet 10.12.13.45 50000
checking example sever ip: 10.12.13.45 port: 50000
</pre><p>
As can be seen below, the code that opens a socket, binds to a specified
port, and then listens for incoming client connections is almost
identical in both WinSock and the BeOS. I removed the typedefs, but the
actual types are the same.
</p><p>
A quick scan of <code class="filename">WinSock.h</code>
tells all. If the code is built and run at this
point, the server will be up and running, and listening for incoming
client connections. Port 50000 is just a random listening port number I
picked. In the listen call I use a backlog of 5, fine for this example.
Getting Windows code running on the BeOS is breeze!
</p><pre class="programlisting c">
<span class="comment">/********** WinSock sample window procedure **********/</span>
<span class="type">LONG</span> <span class="type">APIENTRY</span> <code class="methodname">MainWndProc</code>(
      <span class="type">HWND</span> <code class="parameter">hWnd</code>,      <span class="comment">/* window handle  */</span>
      <span class="type">UINT</span> <code class="parameter">message</code>,   <span class="comment">/* type of message  */</span>
      <span class="type">UINT</span> <code class="parameter">wParam</code>,    <span class="comment">/* additional information */</span>
      <span class="type">LONG</span> <code class="parameter">lParam</code>)    <span class="comment">/* additional information  */</span>
{
  <span class="type">SOCKADDR_IN</span> <code class="varname">local_sin</code>;
  <span class="type">SOCKADDR_IN</span> <code class="varname">acc_sin</code>;
  <span class="type">SOCKET</span> <code class="varname">sock</code>;

  switch (<code class="parameter">message</code>) {

  case <code class="constant">WM_CREATE</code>: {
    <code class="varname">local_sin</code>.<code class="varname">sin</code>.<code class="varname">sin_family</code> = <code class="constant">AF_INET</code>;
    <code class="varname">local_sin</code>.<code class="varname">sin</code>.<code class="varname">sin_addr</code>.<code class="varname">s_addr</code> = <code class="constant">INADDR_ANY</code>;
    <span class="comment">/* hard coded port, example only */</span>
    <code class="varname">local_sin</code>.<code class="varname">sin</code>.<code class="varname">sin_port</code> = <code class="function">htons</code>(50000);

    <code class="varname">sock</code> = <code class="function">socket</code>(<code class="constant">AF_INET</code>, <code class="constant">SOCK_STREAM</code>, 0);
    <code class="function">bind</code>(<code class="varname">sock</code>, (struct <span class="type">sockaddr*</span>) &amp;<code class="varname">local_sin</code>,
      <code class="function">sizeof</code>(<code class="varname">local_sin</code>));
    <code class="function">listen</code>(<code class="varname">sock</code>, 5);

     <span class="comment">/* tell us when a client has connected to our */</span>
     <span class="comment">/* listening socket.                          */</span>
    <code class="function">WSAAsyncSelect</code>( <code class="varname">sock</code>, <code class="parameter">hWnd</code>, <code class="constant">WSA_ACCEPT</code>, <code class="constant">FD_ACCEPT</code>);

    break;
   }

  case <code class="constant">WSA_ACCEPT</code>:
    <span class="comment">/* wParam is the listening socket */</span>
    <span class="type">int</span> <code class="varname">len</code> = <code class="function">sizeof</code>( <code class="varname">acc_sin</code> );
    <code class="varname">sock</code> = <code class="function">accept</code>( (<span class="type">unsigned int</span>) <code class="parameter">wParam</code>,
      (struct <span class="type">sockaddr*</span>) &amp;<code class="varname">acc_sin</code>, (<span class="type">int *</span>) &amp;<code class="varname">len</code> );
    <code class="function">WSAAsyncSelect</code>( <code class="varname">sock</code>, <code class="parameter">hWnd</code>, <code class="constant">WSA_READ</code>,
      <code class="constant">FD_READ</code> | <code class="constant">FD_CLOSE</code> );
    break;

  case <code class="constant">WSA_READ</code>:
    <span class="type">char</span> <code class="varname">recvbuf</code>[ 256];
    if (<code class="function">WSAGETSELECTEVENT</code>(<code class="parameter">lParam</code>) == <code class="constant">FD_READ</code>) {
      <span class="type">int</span> <code class="varname">cnt</code> =
        <code class="function">recv</code>((<span class="type">unsigned int</span>) <code class="parameter">wParam</code>, <code class="varname">recvbuf</code>, 256 , 0);
      <code class="varname">recvbuf</code>[<code class="varname">cnt</code>] = '\0';
      <code class="function">send</code>((<span class="type">unsigned int</span>) <code class="parameter">wParam</code>, <code class="varname">recvbuf</code>,
        <code class="function">strlen</code>(<code class="varname">recvbuf</code>), 0 );
      <code class="function">closesocket</code>((<span class="type">unsigned int</span>) <code class="parameter">wParam</code>);
    }
    else <span class="comment">/* FD_CLOSE */</span>
      <code class="function">closesocket</code>((<span class="type">unsigned int</span>)<code class="parameter">wParam</code>);

    break;
  ...
   } <span class="comment">/* switch */</span>
}
</pre><p>
Remember that I said the <code class="function">WSAAsyncSelect()</code> call was an obstacle to our
port plans? Well, here is where we climb over it. We need to take the
networking functionality from the Windows procedure and map that to the
BeOS.
</p><p>
In the Windows sample, multiple client connections are handled in the
<code class="constant">WSA_ACCEPT</code> message. <code class="function">Accept()</code>
returns the client connection and then
<code class="function">WSAAsyncSelect()</code> sets up a callback for received data.
In <code class="constant">WSA_READ</code> the data is received and then sent back to
the client.
</p><p>
Threads are used to do the same activity in the BeOS. The <code class="function">accept()</code> call
blocks, and when a client wishes to make a connection, a thread is
spawned and passed the new connection. The new connection is passed by
value to ensure the connection does not get over-written during the
spawning of the thread. This means the connection is an integer pointer,
and needs to be freed in the thread. Within the thread the client data is
received and sent back. After the client connection all client activity
is controlled in the thread.
</p><pre class="programlisting c">
<span class="comment">/********** BeOS Networking **********/</span>
...

struct <span class="type">sockaddr_in</span> <code class="varname">local_sin</code>;
struct <span class="type">sockaddr_in</span> <code class="varname">acc_sin</code>;
<span class="type">int</span>  <code class="varname">sock</code>;
<span class="type">int*</span> <code class="varname">acc_sock</code>;
<span class="type">thread_id</span> <code class="varname">new_thread</code>;

<code class="varname">local_sin</code>.<code class="varname">sin</code>.<code class="varname">sin_family</code> = <code class="constant">AF_INET</code>;
<code class="varname">local_sin</code>.<code class="varname">sin</code>.<code class="varname">sin_addr</code>.<code class="varname">s_addr</code> = <code class="constant">INADDR_ANY</code>;
<code class="varname">local_sin</code>.<code class="varname">sin</code>.<code class="varname">sin_port</code> = <code class="function">htons</code>(50000);

<code class="varname">sock</code> = <code class="function">socket</code>(<code class="constant">AF_INET</code>, <code class="constant">SOCK_STREAM</code>, 0);
<code class="function">bind</code>(<code class="varname">sock</code>, (struct <span class="type">sockaddr*</span>) &amp;<code class="varname">local_sin</code>,
  sizeof(<code class="varname">local_sin</code>));
<code class="function">listen</code>(sock, 5);

for (;;) {
  <span class="type">int</span> <code class="varname">len</code> = sizeof(<code class="varname">acc_addr</code>);
  <code class="varname">acc_sock</code> = (<span class="type">int*</span>)<code class="function">malloc</code>(sizeof(int)); <span class="comment">// do not overwrite</span>
  *<code class="varname">acc_sock</code> = <code class="function">accept</code>(<code class="varname">sock</code>,
    (struct <span class="type">sockaddr*</span>) &amp;<code class="varname">acc_addr</code>, &amp;<code class="varname">len</code>);

  <code class="varname">new_thread</code> = <code class="function">spawn_thread</code>(<code class="varname">new_accept</code>, "new accept",
    <code class="constant">B_LOW_PRIORITY</code>, <code class="varname">acc_sock</code>);
  <code class="function">resume_thread</code>(<code class="varname">new_thread</code>);
}

<span class="comment">/* thread function */</span>
<span class="type">int32</span> <code class="function">new_accept</code>(<span class="type">void*</span> <code class="parameter">data</code>)
{
  <span class="type">char</span> <code class="varname">recvbuf</code>[256];
  <span class="type">int</span> <code class="varname">acc_sock</code>;

  <code class="varname">acc_sock</code> = *((<span class="type">int*</span>)<code class="parameter">data</code>);
  <code class="function">free</code>(<code class="parameter">data</code>);

  <span class="type">int</span> <code class="varname">cnt</code> = <code class="function">recv</code>(<code class="varname">acc_sock</code>, <code class="varname">recvbuf</code>, 256, 0);
  <code class="varname">recvbuf</code>[<code class="varname">cnt</code>] = '\0';
  <code class="function">send</code>(<code class="varname">acc_sock</code>, <code class="varname">recvbuf</code>, <code class="function">strlen</code>(<code class="varname">recvbuf</code>), 0);
  <code class="function">closesocket</code>(<code class="varname">acc_sock</code>);
}
</pre><p>
Well, that's it for now, other duties call. I know I went through the
information pretty quickly, so if you have any questions, concerns, or
ideas about porting WinSock apps to the BeOS, please let me know.
</p></div><hr class="pagebreak" /><div class="sect1"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h2 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="Engineering3-27-2"></a>Be Engineering Insights: Outsmarting the Scheduler</h2></div><div xmlns:d="http://docbook.org/ns/docbook"><span xmlns="http://www.w3.org/1999/xhtml" class="author">By <span class="firstname">Ficus</span> <span class="surname">Kirkpatrick</span></span></div></div></div><p>
Operating systems that can execute multiple tasks simultaneously
generally do it in one of two ways—"The Your System Freezes When You
Do Something As Ridiculously Simple As Starting A Program Way," and "The
Right Way," respectively. It was a tough decision, but BeOS implements
the latter of the two.
</p><p>
This is done by asking the system to wake up the kernel every so often in
order to make scheduling decisions. When the system starts up, we program
a timer to deliver an interrupt to the CPU at some interval, so the
kernel can check on the system and crack some heads if the situation
demands it. We'll call this the clock interrupt.
</p><p>
Under BeOS, the clock interrupt occurs once every millisecond. The
scheduler checks to see if any threads are ready to wake up from a
<code class="function">snooze()</code> call or if it's time to preempt a thread that's been running too
long. So, if you try to snooze for 250 microseconds, you might not
actually wake up until 1 ms later, plus any context switching overhead.
If you're lucky and you were put on the sleep queue 250 microseconds or
so before the next clock interrupt—and no one else at a higher
priority is waiting to run—you'll wake up at the time you expected.
Unfortunately, though, you can't depend on it.
</p><p>
Why doesn't Be increase the frequency of the clock interrupt? Because
there's a fine line between more accurate snoozing and spending all your
<acronym class="acronym">CPU</acronym> cycles deciding whose turn it is to run, and we'd like to investigate
some more before changing the behavior of the scheduler. So for the time
being, you're stuck with 1 ms <code class="function">snooze()</code> granularity. That is, of course,
unless you have a free spirit, a free evening, and a free timer interrupt.
</p><p>
Well, I had both a timer interrupt and a Newsletter article to write, and
so I give you the "wakeup" driver:
</p><p>
ftp://ftp.be.com/pub/samples/drivers/obsolete/wakeup.zip
</p><p>
When opened, this driver will program the real-time clock on the ISA bus
to begin generating an interrupt every 244 microseconds. Your user-level
thread that wants to wake up this often does this:
</p><pre class="programlisting c">
<span class="type">int</span> <code class="varname">fd</code> = <code class="function">open</code>("/dev/misc/wakeup", 0);

<code class="function">set_thread_priority</code>(<code class="function">find_thread</code>(<code class="constant">NULL</code>),
  <code class="constant">B_REAL_TIME_PRIORITY</code>);

while (...) {
  <code class="function">read</code>(<code class="varname">fd</code>, <code class="varname">some_buffer</code>, 0);
  <code class="function">do_fun_stuff</code>();
}

<code class="function">close</code>(<code class="varname">fd</code>);    <span class="comment">/* don't forget! */</span>
</pre><p>
Despite the misleading name, calling <code class="function">read()</code> on the wakeup device does not
actually return any data, but rather blocks the reading thread on a
semaphore. When the driver receives a timer interrupt, it releases this
semaphore. Then, courtesy of the reading thread's real-time priority, the
thread is immediately unblocked and you can <code class="function">do_your_fun_stuff()</code>, after
having waited only a quarter of a millisecond.
</p><p>
Unfortunately, there is a problem. Interrupt handlers are supposed to
call <code class="function">release_sem_etc()</code> with
<code class="constant">B_DO_NOT_RESCHEDULE</code> as one of the flags.
Normally, releasing a semaphore gets you rescheduled, but it isn't safe
to be rescheduled inside an interrupt handler.
</p><p>
Consider the following course of events: Your handler is called by the
interrupt dispatcher. It releases a semaphore, causing a reschedule. The
user program that has the device open is switched to, and it calls
<code class="function">close()</code> on the device's file descriptor.
</p><p>
Since no one else has the device open at this point, the driver is
unloaded by the kernel. Some time later, the thread that your interrupt
handler was executing in is scheduled. The code it was executing in is
now unloaded, leaving it with an invalid instruction pointer. Since it is
running in kernel space, the entire system will almost certainly crash.
</p><p>
In order for the driver to work, the thread that handles the interrupt
has to be rescheduled when it releases the semaphore. Otherwise, the
interrupt handler just returns and, that's right, the reader thread can
end up waiting an entire millisecond to be scheduled, which doesn't help.
</p><p>
The only 100%-reliable way to solve this problem is to commit a gross
hack. It may not be what you wanted to do, but outsmarting the scheduler
is already experimenting on the dark side. So, how do you guarantee that
your interrupt handler will have somewhere to land when it returns from
release_sem? Well, you have to leak some memory. Here's the solution:
</p><pre class="programlisting c">
<span class="comment">/* globally declared */</span>
static <span class="type">uchar *</span><code class="varname">hack_area</code>;
static <span class="type">uchar</span> <code class="varname">springboard</code>[] =
  "\xb8\x00\x00\x00\x00"      <span class="comment">/* mov eax, ... */</span>
  "\x50"                      <span class="comment">/* push eax     */</span>
  "\xe8\x00\x00\x00\x00"      <span class="comment">/* call ...     */</span>
  "\x58"                      <span class="comment">/* pop eax      */</span>
  "\xb8\x01\x00\x00\x00"      <span class="comment">/* mov eax, 1   */</span>
  "\xc3";                     <span class="comment">/* ret          */</span>

<span class="comment">/* in wakeup_open() */</span>
if ((<code class="varname">aid</code> = <code class="function">find_area</code>("wakeup hack")) &lt; 0) {
  <span class="comment">/* if the area doesn't exist, create it */</span>
  <code class="function">create_area</code>("wakeup hack", &amp;<code class="varname">hack_area</code>,
      <code class="constant">B_ANY_KERNEL_ADDRESS</code>, <code class="constant">B_PAGE_SIZE</code>,
      <code class="constant">B_FULL_LOCK</code>, <code class="constant">B_READ_AREA</code>|<code class="constant">B_WRITE_AREA</code>);
} else {
  <span class="comment">/* otherwise just reuse it—we are only single-open */</span>
  <code class="function">get_area_info</code>(<code class="varname">aid</code>, &amp;<code class="varname">ai</code>);
  <code class="varname">hack_area</code> = (<span class="type">uchar *</span>)<code class="varname">ai</code>.<code class="varname">address</code>;
}

<span class="comment">/* copy the springboard code into the area */</span>
<code class="function">memcpy</code>(<code class="varname">hack_area</code>, <code class="varname">springboard</code>, <code class="function">sizeof</code>(springboard));

<span class="comment">/* patch the springboard code to have the relocated address
 * of release_sem, as well as the correct sem_id to pass to it
 */</span>
*(<span class="type">sem_id *</span>)(<code class="varname">hack_area</code> + 1) = <code class="varname">wakeup_sem</code>;
*(<span class="type">uint32 *</span>)(<code class="varname">hack_area</code> + 7) =
    ((<span class="type">uint32</span>)<code class="varname">release_sem</code> - (<span class="type">uint32</span>)<code class="varname">hack_area</code> - 11);
</pre><p>
What we've done is copied the machine code for a "springboard"
into <code class="function">release_sem()</code> to a locked area, and patched that
code with the correct <span class="type">sem_id</span> and address of
<code class="function">release_sem()</code>. The interrupt handler releases the
semaphore through the springboard rather than directly to
<code class="function">release_sem()</code>, and we have a guaranteed place to
return to, even if the driver has been unloaded.
</p><p>
An unfortunate side effect of this is that we have to write the interrupt
handler in assembly language:
</p><pre class="programlisting c">
__declspec(naked)  <span class="comment">/* don't create a stack frame */</span>
static <span class="type">bool</span>
<code class="function">wakeup_handler</code>(<span class="type">void *</span><code class="parameter">data</code>)
{
    asm {
    <span class="comment">/* acknowledge the timer interrupt */</span>
    push  RTC_REGC
    call  rtc_read
    pop   eax

    <span class="comment">/* jump to the release_sem springboard */</span>
    mov   eax, hack_area
    jmp   eax

    <span class="comment">/* we should never reach this point, as
     * the springboard should send us back
     * to our caller
     */</span>
    ret
  }
}
</pre><p>
Because we have to restore any registers that were modified inside the
interrupt handler in the springboard code, we can't leave it to the
compiler's discretion to decide which ones to save and use in the
interrupt handler.
</p><p>
Another important aspect of making this work is not creating a new stack
frame in the interrupt handler. This will make the "ret" instruction in
the springboard code jump back into the tender, loving, and most of all,
*safe* hands of the interrupt handler's caller. It's a horrible hack, it
leaks a page of locked memory, but desperate times call for desperate
measures, and at least we reuse the page on subsequent opens.
</p><p>
This is only one example of outsmarting the normal clock interrupt,
though. You could make an ultra-snooze driver that gives you one-off
high-granularity sleeping, or you could put more logic into the driver
for deciding when to wake up the reader. For example, you could set the
<acronym class="acronym" title="Real-Time Clock">RTC</acronym> interrupt rate to
114 microseconds and only release the semaphore on
every third one.
</p><p>
There are also alternate approaches to this periodic wakeup application.
In my implementation, the driver makes an attempt to let the reader catch
up if it is unable to keep pace with the interrupts. You may want to
guarantee the reader a minimum sleep time. This is easily implemented by
setting a flag in <code class="function">read()</code> to indicate that someone is waiting, and
checking that flag in the interrupt handler before releasing the
semaphore.
</p><p>
Careful readers will note that this driver will not work on the PowerPC
because of its use of Intel assembly language. However, with some
modification, you should be able to make it work on a BeBox. It won't
work on a Mac without more modifying, because the Mac has no ISA bus,
which is where the real-time clock we use to generate the interrupts
sits. But if you know of a timer I haven't found, or you have some
hardware that will generate the interrupts for you, the modifications
you'll need to make are trivial.
</p><p>
If you're interested in learning more about the scheduler, Cyril
Meurillon, Master of the Be Kernel Dominion, wrote about it in Issue 37
of the Be Newsletter:
</p><p>
<a class="xref" href="Issue1-37.html#Engineering1-37" title="Be Engineering Insights: The Kernel Scheduler and Real-Time Threads">Be Engineering Insights: The Kernel Scheduler and Real-Time Threads</a>
</p><p>
The need for better timing without hacks like this is a known deficiency,
but things will improve for R4. Look for detailed information about this
in a future Newsletter.
</p><p>
Finally, this example is meant to be a mere starting point for
exploration. I'd be interested to know what you find out along the way.
</p></div><hr class="pagebreak" /><div class="sect1"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h2 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="DevWorkshop3-27"></a>Developers' Workshop: Slumming It, or Making the Most of a db Situation</h2></div><div xmlns:d="http://docbook.org/ns/docbook"><span xmlns="http://www.w3.org/1999/xhtml" class="author">By <span class="firstname">Victor</span> <span class="surname">Tsou</span></span></div></div></div><p>
Last night, while out taking my daily constitutional, I found myself face
to face with none other than the esteemed Dr. B. Banner.
</p><p>
"Good evening," I greeted my erstwhile neighbor, who grunted a curt
response. "You're looking a bit green tonight; I hope nothing's wrong," I
added, somewhat alarmed by his bilious coloring.
</p><p>
"If you must know, I'm having trouble debugging my gamma ray modelling
program," he said irritably. I trembled as his clothes seemed to shrink.
"The lack of a source level debugger is making me positively ANGRY," he
continued.
</p><p>
I quickly administered first aid, giving him a few tips on debugging
user-level code and soon he was once again the good doctor we all know
and love, anxious to return to his research. In the hope of averting any
future developer transformations, Dr. Banner has generously shared his
personal notes of our conversation.
</p><p>
The debug server provides the default user-level debugger on the BeOS.
The debugger can be called in a number of ways:
</p><div class="orderedlist"><ol><li><p>
Following a program crash, the debugger will be brought up on the
offending instruction.
</p></li><li><p>
The <code class="function">debugger()</code> function, defined in , programmatically invokes the
debugger on the calling thread.
</p></li><li><p>
The <span class="application">db</span> command-line program can be used to either debug an existing
thread or begin a debugging session on a new program. It takes the
thread number or the name of the executable to debug as an argument.
</p></li></ol></div><p>
The debugger is somewhat more capable than its kernel-level counterpart;
for example, it allows you to set breakpoints and single-step. For a full
list of available commands, type "help" at the debugger's command prompt.
</p><p>
While it only displays information at the assembly level, the debugger
understands symbols in <code class="filename">xMAP</code> files.
<code class="filename">xMAP</code>s for the system libraries are included in the
<code class="filename">/optional</code> folder of the installation CD and should be copied to
<code class="filename">/system/lib</code>. To generate
<code class="filename">xMAP</code>s for your own images, pass the   -map 
option to the linker followed by the name of the
<code class="filename">xMAP</code> to generate (typically the application name
followed by <code class="filename">.xMAP</code>). If you're using the BeIDE, you can
achieve the same effect by checking the "Generate Link Map"
linker option in the project settings dialog.
</p><p>
While debugging, you'll typically know the name of the function you're
examining (by looking up the symbol associated with the current eip/pc)
but not the precise source line. Again, for those who read the article
concerning debugging device drivers:
</p><p>
<a class="xref" href="Issue3-21.html#DevWorkshop3-21" title="Developers' Workshop: Welcome to the Cow...Debugging Device Drivers">Developers' Workshop: Welcome to the Cow...Debugging Device Drivers</a>
</p><p>
the combination of the  -g  and
  -machinecodelist  mwcc options will reward
you with an interlaced source/assembly dump of your code, allowing you to
quickly associate eip/pc values with source lines.
</p><p>
Along similar lines, the <span class="application">pedump</span> (for x86)
and <span class="application">pefdump</span> (for PowerPC)
programs disassemble and report import, export, and dependency
information for executables, add-ons, and libraries. These tools are
<code class="filename">xMAP</code>-aware and their output is more readable
when the appropriate <code class="filename">xMAP</code>s
are present. The import/export information is particularly useful and may
be used to quickly check if a program was compiled correctly.
</p><p>
For example, if the <span class="application">Tracker</span> refuses to load an add-on, a quick check with
pedump/pefdump may reveal an improperly exported <code class="function">process_refs()</code>. The
dependency information can help identify the libraries an application
requires; no longer shall the "Not an executable" error message leave you
scratching your head.
</p><p>
The <code class="filename">/bin</code> directory
contains a variety of additional tools helpful for
debugging while your application is running. Among these are several
programs that display information about kernel constructs. A sampling of
the available programs and the information they reveal:
</p><div class="orderedlist"><ol><li><p>
ps: Display thread info
</p><ul class="itemizedlist"><li><p>
thread—the thread id
</p></li><li><p>
name—the name of the thread
</p></li><li><p>
state—running (run), ready (rdy), suspended (sus), sleeping
(zzz), in receive_data() (msg), or waiting on a semaphore (sem)
</p></li><li><p>
prio—thread priority
</p></li><li><p>
user—time, in milliseconds, the thread has spent executing
user code
</p></li><li><p>
kernel—time, in milliseconds, the thread has spent executing
kernel code
</p></li><li><p>
semaphore—semaphore the thread is waiting to acquire
</p></li></ul></li><li><p>
listarea: Display area info
</p><ul class="itemizedlist"><li><p>
id—area id
</p></li><li><p>
name—area name
</p></li><li><p>
address—address of the area in the address space of the team
that created it
</p></li><li><p>
size—in bytes of the area
</p></li><li><p>
allocated—number of bytes currently in physical memory
</p></li><li><p>
#-cow—copy on write count
</p></li><li><p>
#-in—number of times any of the pages in the area have been
swapped in
</p></li><li><p>
#-out—number of times any of the pages in the area have been
swapped out
</p></li></ul></li><li><p>
listport: Display port info
</p><ul class="itemizedlist"><li><p>
id—port id
</p></li><li><p>
name—port name
</p></li><li><p>
capacity—length of port's message queue
</p></li><li><p>
queued—number of messages currently in the queue
</p></li></ul></li><li><p>
listsem: Display semaphore info
</p><ul class="itemizedlist"><li><p>
id—sem id
</p></li><li><p>
name—semaphore name
</p></li><li><p>
count—semaphore's current value
</p></li></ul></li></ol></div></div><hr class="pagebreak" /><div class="sect1"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h2 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="Gassee3-27"></a>About This Space...</h2></div><div xmlns:d="http://docbook.org/ns/docbook"><span xmlns="http://www.w3.org/1999/xhtml" class="author">By <span class="firstname">Jean-Louis</span> <span class="surname">Gassée</span></span></div></div></div><p>
Jean-Louis Gassée is hard at working researching the usefulness of BeOS
cooking software in Alsace, France. A wine cellar inventory application
may also be required...
</p></div></div><div id="footer"><hr /><div id="footerT">Prev: <a href="Issue3-26.html">Issue 3-26, July 1, 1998</a>  Up: <a href="volume3.html">Volume 3: 1998</a>  Next: <a href="Issue3-28.html">Issue 3-28, July 15, 1998</a> </div><div id="footerB"><div id="footerBL"><a href="Issue3-26.html" title="Issue 3-26, July 1, 1998"><img src="images/navigation/prev.png" alt="Prev" /></a> <a href="volume3.html" title="Volume 3: 1998"><img src="images/navigation/up.png" alt="Up" /></a> <a href="Issue3-28.html" title="Issue 3-28, July 15, 1998"><img src="images/navigation/next.png" alt="Next" /></a></div><div id="footerBR"><div><a href="../../index.html"><img src="images/People_24.png" alt="haiku-os.org" title="Visit The Haiku Website" /></a></div><div class="navighome" title="Home"><a accesskey="h" href="index-2.html"><img src="images/navigation/home.png" alt="Home" /></a></div></div><div id="footerBC"><a href="http://www.access-company.com/home.html" title="ACCESS Co."><img alt="Access Company" src="images/access_logo.png" /></a></div></div></div><div id="licenseFooter"><div id="licenseFooterBL"><a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/3.0/" title="Creative Commons License"><img alt="Creative Commons License" style="border-width:0" src="../../../licensebuttons.net/l/by-nc-nd/3.0/88x31.png" /></a></div><div id="licenseFooterBR"><a href="LegalNotice.html">Legal Notice</a></div><div id="licenseFooterBC"><span id="licenseText">This work is licensed under a
          <a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/3.0/">Creative
          Commons Attribution-Non commercial-No Derivative Works 3.0 License</a>.</span></div></div><!-- Fathom -->
<script>
(function(f, a, t, h, o, m){
	a[h]=a[h]||function(){
		(a[h].q=a[h].q||[]).push(arguments)
	};
	o=f.createElement('script'),
	m=f.getElementsByTagName('script')[0];
	o.async=1; o.src=t; o.id='fathom-script';
	m.parentNode.insertBefore(o,m)
})(document, window, '../../../metrics.haiku-os.org/tracker.js', 'fathom');
fathom('trackPageview');
</script>
<!-- / Fathom --></body>
<!-- Mirrored from www.haiku-os.org/legacy-docs/benewsletter/Issue3-27.html by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 05 Aug 2021 01:41:55 GMT -->
</html>
