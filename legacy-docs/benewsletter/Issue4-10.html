<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<!-- Mirrored from www.haiku-os.org/legacy-docs/benewsletter/Issue4-10.html by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 05 Aug 2021 01:42:04 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- /Added by HTTrack -->
<head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Be Newsletters - Volume 4: 1999</title><link rel="stylesheet" href="be_newsletter.css" type="text/css" media="all" /><link rel="shortcut icon" type="image/vnd.microsoft.icon" href="images/favicon.ico" /><!--[if IE]>
    <link rel="stylesheet" type="text/css" href="be_newsletter_ie.css" />
    <![endif]--><meta name="generator" content="DocBook XSL Stylesheets V1.73.2" /><link rel="start" href="index-2.html" title="Be Newsletters" /><link rel="up" href="volume4.html" title="Volume 4: 1999" /><link rel="prev" href="Issue4-9.html" title="Issue 4-9, March 3, 1999" /><link rel="next" href="Issue4-11.html" title="Issue 4-11, March 17, 1999" /></head><body><div id="header"><div id="headerT"><div id="headerTL"><a accesskey="p" href="Issue4-9.html" title="Issue 4-9, March 3, 1999"><img src="images/navigation/prev.png" alt="Prev" /></a> <a accesskey="u" href="volume4.html" title="Volume 4: 1999"><img src="images/navigation/up.png" alt="Up" /></a> <a accesskey="n" href="Issue4-11.html" title="Issue 4-11, March 17, 1999"><img src="images/navigation/next.png" alt="Next" /></a></div><div id="headerTR"><div id="navigpeople"><a href="../../index.html"><img src="images/People_24.png" alt="haiku-os.org" title="Visit The Haiku Website" /></a></div><div class="navighome" title="Home"><a accesskey="h" href="index-2.html"><img src="images/navigation/home.png" alt="Home" /></a></div><div class="navigboxed" id="naviglang" title="English">en</div></div><div id="headerTC">Be Newsletters - Volume 4: 1999</div></div><div id="headerB">Prev: <a href="Issue4-9.html">Issue 4-9, March 3, 1999</a>  Up: <a href="volume4.html">Volume 4: 1999</a>  Next: <a href="Issue4-11.html">Issue 4-11, March 17, 1999</a></div><hr /></div><div class="article"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h2 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="Issue4-10"></a>Issue 4-10, March 10, 1999</h2></div></div></div><div class="sect1"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h2 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="Engineering4-10"></a>Be Engineering Insights: BeIDE Add-on API</h2></div><div xmlns:d="http://docbook.org/ns/docbook"><span xmlns="http://www.w3.org/1999/xhtml" class="author">By <span class="firstname">John</span> <span class="surname">Dance</span></span></div></div></div><p>
A week or so ago, I needed to look into a program that was partially
generated by the tools <span class="application">bison</span> and <span class="application">flex</span>
(<span class="application">yacc</span>/<span class="application">lex</span>). The program was built
with a makefile, since the <span class="application">BeIDE</span> can't handle
<span class="application">bison</span>/<span class="application">flex</span> as part of the
build...or can it? I figured that since <span class="application">gcc</span>
and <span class="application">mwcc</span> are actually handled
as add-ons in the <span class="application">BeIDE</span>, you should be able to handle the limited needs
of <span class="application">bison</span>/<span class="application">flex</span> the same way.
</p><p>
The <span class="application">BeIDE</span> comes with a shell tool add-on that lets you specify shell
scripts to be run during steps of the build. This could actually be used
for running <span class="application">bison</span>/<span class="application">flex</span>,
but the shell script would be executed on every
build. Since <span class="application">flex</span> and <span class="application">bison</span>
produce files that I'll use as part of my
source, I didn't want them running on every build. I could write the
shell script to check whether <span class="application">flex</span>/<span class="application">bison</span>
actually need to run, but it
would still be less than optimal...and besides, it wouldn't give me
enough to write about in this article.
</p><p>
As I was thinking about writing an add-on for <span class="application">flex</span>
and then for <span class="application">bison</span>, I
realized that I didn't want to write multiple add-ons at all. In fact, I
wanted an add-on that would work for both <span class="application">flex</span>
and <span class="application">bison</span>, and that could
also be easily extended for <span class="application">mwbres</span>,
<span class="application">rez</span>, or a host of other tools of this
sort. But how to do this? The <span class="application">BeIDE</span> add-on architecture allows a single
add-on to specify more than one builder. Given that, I decided that I
should be able to factor out a minimal amount of specific code for each
tool. I went ahead and built a simple generic translator add-on that I
then modified to handle these multiple tools. It can also be easily
extended as I encounter more tools of these types that I would like to
use.
</p><p>
The BeIDE supports editor and builder add-ons. I'll leave the editor
add-on architecture for another article. The generic translator project
can be found at ftp://ftp.be.com/pub/samples/beide/translator.zip. It
would be more instructive to look at the source as you're reading the
article. Unfortunately, R4 did not include the headers needed for writing
<span class="application">BeIDE</span> add-ons. Until you get your copy of R4.1, the headers and textual
documentation for the add-on API can be found at
</p><p>
ftp://ftp.be.com/pub/samples/beide/Plugin_API.zip.
</p><p>
As the <span class="application">BeIDE</span> starts up, it looks at all the add-ons in a known location
and calls two important functions:
</p><pre class="programlisting cpp">
extern "C"
<span class="type">status_t</span> <code class="function">MakePlugInView</code>(<span class="type">int32</span> <code class="parameter">inIndex</code>, <code class="classname">BRect</code> <code class="parameter">inRect</code>, <span class="type"><code class="classname">MPlugInPrefsView</code>*</span>&amp;
<code class="parameter">outView</code>)

extern "C"
<span class="type">status_t</span> <code class="function">MakePlugInBuilder</code>(<span class="type">int32</span> <code class="parameter">inIndex</code>, <span class="type"><code class="classname">MPlugInBuilder</code>*&amp;</span> <code class="parameter">outBuilder</code>)
</pre><p>
These two functions return the <code class="classname">MPlugInBuilder</code>
and <code class="classname">MPlugInPrefsView</code> that
do the work and communicate with the <span class="application">BeIDE</span>.
The <code class="classname">MPlugInBuilder</code> is a
wrapper for the external tool. It is used to specify what tool will be
run, at what stage of the build the tool is used, what parameters to pass
to the tool, and finally, how to interpret output from the tool. The
<code class="classname">MPlugInPrefsView</code> provides the user interface for getting and setting
options for running the tool. In some cases an add-on will provide
multiple <code class="classname">MPlugInPrefsViews</code>.
</p><p>
In the functions above, the <code class="parameter">inIndex</code> parameter allows me to create more
than one view and more than one builder. Both functions will be called
with an incrementing <code class="parameter">inIndex</code> until they return something other than
<code class="constant">B_NO_ERROR</code>. To make this example simple, I don't even support preference
settings. That will be left as an exercise for the reader. Don't you hate
it when authors write that? Now I know why they do. They don't want to do
the work themselves.
</p><p>
Writing an <code class="classname">MPlugInBuilder</code> is a straightforward process. (especially when
you don't worry about user preferences). There are about 16 member
functions that must be overridden to create a concrete <code class="classname">MPlugInBuilder</code>
class. Many of them can be written in just a few lines of code. Remember
that I decided my add-on would support a variety of translation tools.
This means that I need some way to customize a shared body of code for
each individual builder. We are using C++, right? Then why not a class?
The main work of the <code class="classname">MPlugInBuilder</code> is handled
by <code class="classname">GenericBuilder</code>, which
does as much work as possible before delegating specific needs to a
<code class="classname">BuildHelper</code> it owns. <code class="classname">MakePlugInBuilder</code>
wants to create a <code class="classname">MPlugInBuilder</code>
object; I create a <code class="classname">GenericBuilder</code> in each case but pass each one a
specific helper class. Here is my <code class="classname">MakePlugInBuilder</code>:
</p><pre class="programlisting cpp">
extern "C"
<span class="type">status_t</span>
<code class="function">MakePlugInBuilder</code>(<span class="type">int32</span> <code class="parameter">inIndex</code>, <span class="type"><code class="classname">MPlugInBuilder</code>*&amp;</span> <code class="parameter">outBuilder</code>)
{
  <span class="type">long</span> <code class="varname">result</code>;

  switch (<code class="parameter">inIndex</code>) {
    case 0:
      <code class="parameter">outBuilder</code> = new <code class="classname">GenericBuilder</code>(new <code class="classname">FlexHelper</code>);
      <code class="varname">result</code> = <code class="constant">B_OK</code>;
      break;

    case 1:
      <code class="parameter">outBuilder</code> = new <code class="classname">GenericBuilder</code>(new <code class="classname">BisonHelper</code>);
      <code class="varname">result</code> = <code class="constant">B_OK</code>;
      break;

    case 2:
      <code class="parameter">outBuilder</code> = new <code class="classname">GenericBuilder</code>(new <code class="classname">ResHelper</code>);
      <code class="varname">result</code> = <code class="constant">B_OK</code>;
      break;

    default:
      <code class="varname">result</code> = <code class="constant">B_ERROR</code>;
      break;
  }
  return <code class="varname">result</code>;
}
</pre><p>
I support three tools: <span class="application">flex</span>, <span class="application">bison</span>,
and <span class="application">mwbres</span>. But you can easily see
how to extend this to other tools by writing a new <code class="classname">BuildHelper</code> and adding
an additional case. To get a feel for writing an <code class="classname">MPlugInBuilder</code>, it would
be best to go look at <code class="filename">GenericBuilder.cpp</code>.
</p><p>
The concrete <code class="classname">BuildHelper</code> classes
(<code class="classname">FlexHelper</code>, <code class="classname">BisonHelper</code>,
and <code class="classname">ResHelper</code>)
override six member functions that deal with actions or information
specific to each individual tool. I'll talk about just three of these
methods here.
</p><p>
One of the main jobs of the <code class="classname">MPlugInBuilder</code> is to create the argument list
for running the tool. If I had a <code class="classname">MPlugInViewer</code>, this is where I would
retrieve and interpret the options in the <code class="classname">BMessage</code> that was created with
the <code class="classname">MPlugInViewer</code>. The <span class="application">BeIDE</span>
asks the add-on to fill in a <code class="classname">BList</code> with a
<span class="type">char*</span> for each option. The Plugin_API documentation says that each string
must be copied, since the <code class="classname">BList</code> adopts them and later will free them.
Since <code class="function">free</code> is used, I use <code class="function">strdup</code> rather than
<code class="code">new char[]</code>.
</p><pre class="programlisting cpp">
<span class="type">status_t</span> <code class="classname">FlexHelper</code>::<code class="methodname">BuildArgv</code>(<span class="type"><code class="classname">BList</code> &amp;</span><code class="parameter">inArgv</code>, <span class="type">const char *</span><code class="parameter">filePath</code>)
{
  <code class="classname">BString</code> <code class="varname">outputName</code>;
  <code class="varname">this</code>-&gt;<code class="methodname">MakeOutputFileName</code>(<code class="parameter">filePath</code>, <code class="varname">outputName</code>);

  <code class="varname">outputName</code>.<code class="methodname">Prepend</code>("-o");

  <code class="varname">inArgv</code>.<code class="methodname">AddItem</code>(<code class="function">strdup</code>(<code class="varname">outputName</code>.<code class="methodname">String</code>()));
  <code class="varname">inArgv</code>.<code class="methodname">AddItem</code>(<code class="function">strdup</code>(<code class="parameter">filePath</code>));

  return <code class="constant">B_OK</code>;
}
</pre><p>
Notice that <code class="methodname">BuildArgv</code> uses another helper method,
<code class="methodname">MakeOutputFileName</code>.
Each <code class="classname">BuildHelper</code> class creates an output file name based on its input
file name, with a different extension. For example:
</p><pre class="screen">
flex: .l -&gt; .cpp
bison: .y -&gt; .cpp
mwbres: .r -&gt; .rsrc
</pre><p>
The new class <code class="classname">BString</code> can really be helpful for string manipulations. To
create the output file we just take the input file and replace the
extension:
</p><pre class="programlisting cpp">
<code class="classname">FlexHelper</code>::<code class="methodname">MakeOutputFileName</code>(<span class="type">const char *</span><code class="parameter">filePath</code>, <span class="type"><code class="classname">BString</code> &amp;</span>
<code class="parameter">outputName</code>)
{
  <code class="parameter">outputName</code> = <code class="parameter">filePath</code>;
  <code class="parameter">outputName</code>.<code class="methodname">ReplaceLast</code>(".l", ".cpp");
}
</pre><p>
What happens when tools have errors? All output is captured by the <span class="application">BeIDE</span>
and then sent to the add-on by calling
</p><pre class="programlisting cpp">
<code class="classname">MPlugInBuilder</code>::<code class="methodname">ParseMessageText</code>(<span class="type">const char *</span><code class="parameter">inText</code>, <span class="type"><code class="classname">BList</code> &amp;</span><code class="parameter">outList</code>)
</pre><p>
<code class="methodname">ParseMessageText</code> has the job of figuring out what
is in the message and creating <code class="classname">ErrorMessage</code>s that
are then added to <code class="parameter">outList</code>. Any
<code class="classname">ErrorMessage</code>s in <code class="parameter">outList</code>,
will be displayed in the Message Window. It's very simple to create
"text only" error messages. Just take each line of text and stuff
it in a new <code class="classname">ErrorMessage</code>. However, it's much nicer
to communicate the file and line information so that the user can navigate
from that error message to the spot in their source with the problem.
</p><p>
Looking at the type of tools that I wanted to support, I saw they had a
similar style for error messages. Here is an error from
<span class="application">flex</span>, <span class="application">bison</span>, and
<span class="application">mwbres</span>:
</p><pre class="screen">
"test.l", line 123: EOF encountered inside an action
("test.y", line 84) error: invalid $ value
File test.r Line 6 # parse error near 'include'
</pre><p>
Since I didn't want to write N different parsers, I had
<code class="classname">GenericBuilder</code>::<code class="methodname">ParseMessageText</code> be in charge of breaking the message up
into individual lines and passing each individual line to the
<code class="classname">BuildHelper</code>. (If a tool has multiple line errors,
<code class="classname">GenericBuilder</code>::<code class="methodname">ParseMessageText</code> will have to be overridden.) The base
class <code class="classname">BuildHelper</code> provides a few methods to parse lines that follow a
format like this:
</p><pre class="screen">
something &lt;filename&gt; something &lt;linenumber&gt;
something message
</pre><p>
(Here I am talking about <span class="application">flex</span> and
<span class="application">bison</span> and I write the grammar like
that...sheesh!) This means that the different concrete <code class="classname">BuildHelper</code>
classes can implement the parsing in one line. All they have to do is
specify the tokens (the "something" stuff) before and after the file name
and line number.
</p><p>
Once the add-on is built, how do you use it? The add-on needs to live in
the <code class="filename">BeIDE</code> directory under
<code class="filename">plugins/Prefs_add_ons</code>. Once installed, use the
Settings/Target preferences to connect file types and extensions to the
tools. To build my project that used both <span class="application">flex</span>
and <span class="application">bison</span> I added the
following targets:
</p><pre class="screen">
Extension: l
Tool: flex
Flags: Precompile Stage

Extension: y
Tool: bison
Flags: Precompile Stage
</pre><p>
I then added the <code class="filename">foo.yy.l</code> and
<code class="filename">foo.tab.y</code> files to the project. Since
<span class="application">flex</span> and <span class="application">bison</span> are
used to produce files that are then compiled as part of the project, I also
added the files they produce: <code class="filename">foo.yy.cpp</code> and
<code class="filename">foo.tab.cpp</code> to the project. The
<span class="application">BeIDE</span> has now been successfully enhanced to work
with <span class="application">flex</span> and <span class="application">bison</span>.
Once I wrote and debugged the <code class="classname">GenericBuilder</code> and
<code class="classname">FlexHelper</code>, it took me about 5 minutes to write and
test the <code class="classname">BisonHelper</code> and
<code class="classname">ResHelper</code>. I'm sure many developers will think up
lots of creative uses for the <span class="application">BeIDE</span> add-on API.
</p></div><hr class="pagebreak" /><div class="sect1"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h2 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="Engineering4-10-2"></a>Be Engineering Insights: Automating Myself into a New Line of Work</h2></div><div xmlns:d="http://docbook.org/ns/docbook"><span xmlns="http://www.w3.org/1999/xhtml" class="author">By <span class="firstname">Steven</span> <span class="surname">Black</span></span></div></div></div><p>
My father used to tell me stories about how he tried to create systems
that took care of themselves so well that no human intervention was
needed. He's had at least one job that, according to him, he succeeded
getting to run itself so well that he had nothing to do and left out of
boredom.
</p><p>
I try to do the same, although even when I think I have something taking
care of itself, there are always more changes to fold in, new features to
test, new conditions to take into account. So far, I can't foresee any
time in the future when what I do could get boring.
</p><p>
Baron Arnold told you that a newer, better release of the <span class="application">InputRecorder</span>
would be available in March with my newsletter article
<a class="xref" href="Issue4-4.html#Engineering4-4-2" title="Be Engineering Insights: Worn Out Rhymes">Be Engineering Insights: Worn Out Rhymes</a>.
This is so. He also mentioned that it would contain source code. This is
also true.
</p><p>
The source has been cleaned up a lot since last month, along with the
user interface. A memory leak in the input filter was fixed. And now you
may even be able to run multiple recorders at the same time, though that
hasn't really been tested much.
</p><p>
While the original author used <code class="classname">BResources</code> to store the record data, I
chose another format—a simple, plain file structure. I implemented all
three forms in my <code class="classname">MessageWriter</code> class, so you can explore and play with
all the options. (The attribute- and resource-based methods need to be
modified slightly and recompiled, but they are implemented.)
</p><p>
I decided not to use attributes to store the input records for several
reasons. The first one is that I don't really need to, since I don't need
to randomly locate input events in the file (I treat it as a simple
stream). The second is that there's currently no easy way to tell how
large a file's attributes are (with <span class="application">InputRecorder</span> the files can be large).
Finally, a simpler file format is easier to transfer. (Zip files are
limited to 64k of attributes per file, which can easily be exceeded when
recording input. The Zap format doesn't have this restriction, but isn't
as common.)
</p><p>
A reminder: We do not recommend using <code class="classname">BResources</code> as general purpose data
storage; we recommend using attributes instead. <code class="classname">BResources</code> were designed
specifically for storing application resources.
</p><p>
One reason for the delay in getting the <span class="application">InputRecorder</span> (especially as
source) to you has been that some input server-related parts aren't quite
finished. Some device and filter elements may be changing, breaking
compatibility, at some future date, in order to improve them. Some of
these things may still be subject to change, although I've convinced
Those On High that it would be great let developers have access to the
<span class="application">InputRecorder</span>.
</p><p>
The source this week is amazingly straightforward. The headers for the
input filter stuff are in
<code class="filename">/boot/develop/headers/be/add-ons/input_server/</code>,
where there are three files:
<code class="filename">InputServerDevice.h</code>,
<code class="filename">InputServerFilter.h</code>, and
<code class="filename">InputServerMethod.h</code>.
</p><p>
Input scripting uses only two of the three input_server add-ons. It uses
a device to write input messages to the input_server, and a filter to
read input_messages from the input_server. Both use ports to talk to the
user-level program.
</p><p>
It should be clear to some of you that the design of the
<code class="classname">InputRecorderDevice</code> is such that it will pass along any message its port
receives directly to the input_server. This means, for example, that you
could create plug-ins for your favorite scripting language that let you
arbitrarily script input.
</p><p>
Here in the <acronym class="acronym" title="Quality Assurance">QA</acronym>
Lab we use a simple, straightforward little tool to do
just that—I'll tell you about it in a later article. It contains
within it the details of the kinds of messages devices can send. It
contains many arcane facts that in some cases I just guessed about, based
on how our devices appear do it and what did and didn't work. That's why
it needs to be looked at carefully before it's released, to ensure that
all the information it contains is accurate.
</p><p>
As an example, one of my favorite scripts that use this tool is called
'normalactions' because it contains things most everyone does at the same
time. It utilizes four workspaces: one to send/receive e-mail to/from
itself; one to compile and run the sample code; one to browse the web
with NetPositive; and one to periodically run audio, which continues
playing while everything else is going on. It uses a couple of helper
programs to do assist in the synchronization issues—things like
ensuring that the active application is what I expect it to be.
</p><p>
So you see, the long trek toward my dream of a fully automated
<acronym class="acronym">QA</acronym>, where
all the <acronym class="acronym">QA</acronym> engineers sit back drinking coffee and watching subprocesses
kill machines and fetch engineers is on the way. Not in the near future,
but it's coming slowly. Maybe one day <acronym class="acronym">QA</acronym> will become so boring that I'll
start looking for a new line of work... though somehow that doesn't seem
likely.
</p></div><hr class="pagebreak" /><div class="sect1"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h2 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="DevWorkshop4-10"></a>Developers' Workshop: Media Kit Basics: Build Your Own Mixer For Fun And
Profit!</h2></div><div xmlns:d="http://docbook.org/ns/docbook"><span xmlns="http://www.w3.org/1999/xhtml" class="author">By <span class="firstname">Owen</span> <span class="surname">Smith</span></span></div></div></div><p>
I heard a rapidly approaching Canyonero, the deadliest of sport utility
vehicles, in the parking lot yesterday, and once again recognized the
sound of doom. And sad to say, I was a convenient target for it.
</p><p>
"You know, those audio sample apps you're coming up with are pretty
lame," spat Morgan le Be, BeOS hacker and mistress of the black arts,
bringing her smoking 'Ero to a halt against the red curb. "Who plays only
one sound at a time these days?"
</p><p>
"Well, you can hook up your sounds to the system mixer..."
</p><p>
"Uh-uh, buster—I want a mixer, just like the system mixer, but for my
own private use."
</p><p>
The gauntlet was down, and for the first time, I knew how to parry Ms. le
Be's attack. Just a few minutes' explanation, and she was satisfied.
</p><p>
And so I say to you, O, True Believers: Heed the dark magick of the Media
Kit. Somewhere in the bowels of the Media Add-On Server dwells a dormant
mixer node, as awesome in its slumber as a hibernating polar bear,
waiting for you to harness its power.
</p><div class="sect2"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="id771132"></a>Me and Sir Mix-A-Lot</h3></div></div></div><p>
This week's sample code shows how you, too, can build a mixer. It's fast,
easy, and KitchenAid approved. However, please note that the mixer add-on
will not support this until R4.1, though the techniques I demonstrate are
indispensable to any application that has to deal with media add-ons.
Your URL for today is
</p><p>
ftp://ftp.be.com/pub/samples/media_kit/MixALot.zip
</p><p>
<span class="application">Mix-A-Lot</span> is a simple app that borrows the sound
playback mechanism from <span class="application">SoundCapture</span> to play
your super-phat grooves. Unlike <span class="application">SoundCapture</span>,
this one constantly loops your favorite sounds and allows you to mix up to
four sounds simultaneously.
</p><p>
How do you use it? Simple: fire it up and drag a sound file from the
<span class="application">Tracker</span> into one of the icon docks at the top of
the <span class="application">Mix-A-Lot</span> window. The sound will start
promptly, and continue to play in a loop until you drag it off the dock. A
new sound dragged onto an already occupied dock replaces the old sound.
</p><p>
The classes <code class="classname">MixerManager</code> and
<code class="classname">Channel</code> do most of the important work in this app.
<code class="classname">MixerManager</code> is responsible for instantiating the
mixer and hooking it up. <code class="classname">Channel</code> represents an input
connection to the mixer, and is responsible for instantiating input sources
and connecting them to the mixer.
</p><p>
You'll also notice the standard set of mixer controls in the <span class="application">Mix-A-Lot</span>
window. If you paid attention during last week's Workshop, you'll already
have a good idea where those controls come from. If not, revisit Mr.
Tate, and be enlightened:
</p><p>
<a class="xref" href="Issue4-9.html#DevWorkshop4-9" title="Developers' Workshop: ParameterWebs and Nodes and Controls, Oh My!">Developers' Workshop: ParameterWebs and Nodes and Controls, Oh My!</a>
</p></div><div class="sect2"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="id771228"></a>Adding It On</h3></div></div></div><p>
The magic behind this mixer madness is the Media Roster's ability to
instantiate media add-ons for you. Media add-ons are code modules that
can provide media services to any BeOS application. You can find them in
two locations:
<code class="filename">/boot/beos/system/add-ons/media/</code> and
<code class="filename">/boot/home/config/add-ons/media/</code>.
</p><p>
Here are some facts about Media Add-Ons:
</p><ul class="itemizedlist"><li><p>
Media add-ons load dynamically; like any BeOS add-on, they're loaded
when they are needed. The application doing the loading in this case is
an important part of the BeOS media system, called—appropriately
enough—the Media Add-On Server.
</p></li><li><p>
Media add-ons know how to instantiate media nodes, and support an
interface to do so when the Media Add-On Server demands it.
</p></li><li><p>
Media add-ons support an interface that tells the Media Add-On Server
what kinds of media nodes they can instantiate. Many media add-ons deal
with only one kind of node—for example, the BeOS mixer add-on only
supports the mixer node. However, a media add-on can support as many
different kinds of media nodes as it wishes. For example, you might
want to write a codec add-on that contains both an encoder and a
decoder node for a particular format.
</p></li><li><p>
Media add-ons generally have one purpose: to instantiate media nodes
that any application can use, without the application having to know
any of the messy details of the node's implementation. For this reason,
media add-ons are generally self-contained. For instance, there is a
Video Window node coming in R4.1 that, when it's instantiated, creates
its own window and view to display the video that it receives. All you
need to do to take advantage of this node is hook it up to an
appropriate video source—the Video Window takes care of the rest.
</p></li></ul></div><div class="sect2"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="id771296"></a>Mixing It Up</h3></div></div></div><p>
As I hinted at above, the BeOS system mixer node is provided by none
other than the Mixer Media Add-On. But there's nothing to stop you from
getting access to the mixer add-on as well and instantiating your own
mixer. That's exactly what <span class="application">Mix-A-Lot</span> does.
</p><p>
To find the system mixer, you need to know what kinds of media nodes are
at your disposal. This information is provided by objects called dormant
media nodes. You can query the Media Roster to get a list of dormant
nodes that are available to the system and specify any of the following
criteria for your query:
</p><ul class="itemizedlist"><li><p>
whether it supports a particular media format in its outputs or
inputs;
</p></li><li><p>
whether it matches a particular name;
</p></li><li><p>
whether it matches a particular node kind.
</p></li></ul><p>
The last criterion is the one we'll use. The <span class="type">node_kind</span> is a set of
flags that a media node uses to inform the Media Roster about its
particular characteristics. There are several predefined kinds that help
to categorize the nodes you'll encounter—for example, a node whose
kind includes <code class="constant">B_TIME_SOURCE</code> derives from
<code class="classname">BTimeSource</code>, and a node whose
kind includes <code class="constant">B_PHYSICAL_OUTPUT</code> represents a physical output of your
system, like audio output. Conveniently enough, there is also a type
defined for the mixer node: <code class="constant">B_SYSTEM_MIXER</code>. (The kind of this particular
node is somewhat misleading, because it applies to any instance of the
audio mixer node, not just the system mixer that you access via the Audio
preference panel.)
</p><p>
Once we know the kind we're looking for, finding the mixer node is
trivial, especially since there's exactly one add-on right now that fits
our criterion. <code class="classname">BMediaRoster</code>::<code class="methodname">GetDormantNodes()</code> is the function that does
the work for us. It returns a list of information about each dormant node
it finds; this information is encapsulated in a structure called
<span class="type">dormant_node_info</span>.
</p><pre class="programlisting cpp">
<span class="type">status_t</span> <code class="varname">err</code>;
<span class="type">dormant_node_info</span> <code class="varname">mixer_dormant_info</code>;
<span class="type">int32</span> <code class="varname">mixer_count</code> = 1;

<code class="varname">err</code> = <code class="classname">BMediaRoster</code>::<code class="methodname">Roster</code>()-&gt;<code class="methodname">GetDormantNodes</code>(
    &amp;<code class="varname">mixer_dormant_info</code>, &amp;<code class="varname">mixer_count</code>, 0, 0, 0,
    <code class="constant">B_SYSTEM_MIXER</code>, 0);
</pre><p>
What do we do with this <span class="type">dormant_node_info</span>? Well, we can use it to get
more information about the dormant node (called the <span class="type">flavor_info</span>), or we
can use it to create an instance of that particular dormant node. We'll
do the latter through the function
<code class="classname">BMediaRoster</code>::<code class="methodname">InstantiateDormantNode()</code>,
which takes a <span class="type">dormant_node_info</span>
and gives us the <span class="type">media_node</span> that's been instantiated:
</p><pre class="programlisting cpp">
<span class="type">media_node</span> <code class="varname">mixer_node</code>;
if (<code class="varname">err</code> == <code class="constant">B_OK</code>) {
    <code class="varname">err</code> = <code class="classname">BMediaRoster</code>::<code class="methodname">Roster</code>()-&gt;<code class="methodname">InstantiateDormantNode</code>(
        <code class="varname">mixer_dormant_info</code>, &amp;<code class="varname">mixer_node</code>);
}
</pre></div><div class="sect2"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="id771528"></a>Screaming in Digital</h3></div></div></div><p>
The only thing you need to know from here is how to hook the mixer up.
</p><p>
The mixer node supports an arbitrary number of inputs—this means that
you can always get as many free inputs for the mixer as you want, via
<code class="classname">BMediaRoster</code>::<code class="methodname">GetFreeInputsFor()</code>.
Here's what you should know about mixer
inputs:
</p><ul class="itemizedlist"><li><p>
Each input's media format must be <code class="constant">B_MEDIA_RAW_AUDIO</code>.
</p></li><li><p>
Each input must be 1 or 2 channels.
</p></li><li><p>
For best performance results, leave each input's buffer size and byte
order unspecified; the mixer will set them to their optimal values.
</p></li></ul><p>
The mixer node supports exactly one output, which provides—surprise!
-- the audio mix. For the system mixer, this output is usually plugged
straight into the audio output node. For <span class="application">Mix-A-Lot</span>, we take the output of
our audio mixer and plug it into the system mixer. The salient features
of the mixer output are these:
</p><ul class="itemizedlist"><li><p>
The output's media format is <code class="constant">B_MEDIA_RAW_AUDIO</code>.
</p></li><li><p>
The output's raw audio format must be <code class="constant">B_MEDIA_SHORT</code>
or <code class="constant">B_MEDIA_FLOAT</code>.
</p></li><li><p>
The output must be 1 or 2 channels.
</p></li><li><p>
The output must be host-endian.
</p></li><li><p>
Again, for best performance results, leave the output's buffer size
unspecified.
</p></li></ul><p>
I leave you with this challenge: How about adding stop and play buttons
for better playback control? Or perhaps you can evolve this modest looper
into a latter day Echoplex? Go forth and twist <span class="application">Mix-A-Lot</span> to your own
sordid ends! Or, as my childhood hero was fond of exclaiming: "C'mon
Flash, let's go catch them Duke boys!"
</p></div></div><hr class="pagebreak" /><div class="sect1"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h2 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="Gassee4-10"></a>The First Media Kit Conference</h2></div><div xmlns:d="http://docbook.org/ns/docbook"><span xmlns="http://www.w3.org/1999/xhtml" class="author">By <span class="firstname">Jean-Louis</span> <span class="surname">Gassée</span></span></div></div></div><p>
About a year ago, at our developers' conference in Santa Clara, we
formally unveiled the first version of the BeOS for the Intel
architecture. This year, on April 9-10, we'll have our first Media Kit
conference—an even more momentous event than our 1998 entry into the
world of x-86 hardware.
</p><p>
Not that we didn't enjoy the occasion. For me, developer conferences are
always a happy time. I get to meet the people who, in a very real sense,
"make" the platform. The people who commit an incredible amount of time,
energy, and creativity to our product. We get vigorous feedback,
encouragement, and great ideas.
</p><p>
I've often thought that, in our business, you know you've done something
right when your platform is perverted. By which I mean—before other
interpretations are suggested—that programmers or normal people use
your product in ways you hadn't thought of. One reason you hadn't thought
of them is the myopia you get from seeing your product all the time.
Another reason is that developers represent so many different areas of
interest and expertise—whereas, to a hammer everything looks like a
nail.
</p><p>
The best part of having your platform "perverted" is seeing that the
product is rich enough for others to extract more uses than you'd
initially foreseen. For example, the creators of the Macintosh didn't
think of it as the engine of what became Desktop Publishing, DTP. The
concept had no meaning at the time, just as home computing was ridiculed
as a fad. In retrospect it all seems logical and preordained: if you have
a great user interface, good fonts, and an easy-to-use laser printer,
you'll create DTP.
</p><p>
Ah, but it wasn't so obvious beforehand, and retroactively amused
witnesses remember contorted positioning statements suggested by the
experts of the day. One of the best was "Graphics Based Business
Systems." I trust that I'll be equally amused and humbled someday by a
few of my own suggestions for our little company.
</p><p>
So, we had a good time last year, complete with an enthusiastic speech
from Intel's Claude L'Eglise and a quasi slip-up from yours truly
recounting a recent meeting with Andy Grove. At the time, we had an
agreement with Intel to keep their investment in Be confidential—it
was disclosed last November at Comdex. As I proceeded to describe a
meeting where I came to thank Andy for his support and to give him a
couple of black Be T-shirts—and photocopies of Intel's stock
certificates fresh from the closing one hour earlier, my colleagues grew
a little agitated. I realized the blunder I was about to make and
abruptly moved to another topic.
</p><p>
This year, we'll reveal the secrets of the Media Kit. OS platforms are
sometimes compared to musical instruments, with rendering power as well
as expressive power. In our case, to stretch the metaphor a bit, we could
say that basic BeOS features such as symmetric multiprocessing, pervasive
multithreading, and a 64-bit journaled file system give it rendering
power. The Media Kit, on the other hand, gives the BeOS expressive power,
the ability to write new music—that is, new applications that aren't
necessarily as easy to write, or perhaps impossible, on other sets of
APIs.
</p><p>
We've often referred to the BeOS as the Media OS. The Media Kit is the
means by which what was the promise of new OS technology can now be
expressed in new applications that address both the creation and the
consumption of digital media.
</p><p>
I look forward to meeting you at this conference and to seeing surprising
new applications down the road.
</p></div></div><div id="footer"><hr /><div id="footerT">Prev: <a href="Issue4-9.html">Issue 4-9, March 3, 1999</a>  Up: <a href="volume4.html">Volume 4: 1999</a>  Next: <a href="Issue4-11.html">Issue 4-11, March 17, 1999</a> </div><div id="footerB"><div id="footerBL"><a href="Issue4-9.html" title="Issue 4-9, March 3, 1999"><img src="images/navigation/prev.png" alt="Prev" /></a> <a href="volume4.html" title="Volume 4: 1999"><img src="images/navigation/up.png" alt="Up" /></a> <a href="Issue4-11.html" title="Issue 4-11, March 17, 1999"><img src="images/navigation/next.png" alt="Next" /></a></div><div id="footerBR"><div><a href="../../index.html"><img src="images/People_24.png" alt="haiku-os.org" title="Visit The Haiku Website" /></a></div><div class="navighome" title="Home"><a accesskey="h" href="index-2.html"><img src="images/navigation/home.png" alt="Home" /></a></div></div><div id="footerBC"><a href="http://www.access-company.com/home.html" title="ACCESS Co."><img alt="Access Company" src="images/access_logo.png" /></a></div></div></div><div id="licenseFooter"><div id="licenseFooterBL"><a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/3.0/" title="Creative Commons License"><img alt="Creative Commons License" style="border-width:0" src="../../../licensebuttons.net/l/by-nc-nd/3.0/88x31.png" /></a></div><div id="licenseFooterBR"><a href="LegalNotice.html">Legal Notice</a></div><div id="licenseFooterBC"><span id="licenseText">This work is licensed under a
          <a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/3.0/">Creative
          Commons Attribution-Non commercial-No Derivative Works 3.0 License</a>.</span></div></div><!-- Fathom -->
<script>
(function(f, a, t, h, o, m){
	a[h]=a[h]||function(){
		(a[h].q=a[h].q||[]).push(arguments)
	};
	o=f.createElement('script'),
	m=f.getElementsByTagName('script')[0];
	o.async=1; o.src=t; o.id='fathom-script';
	m.parentNode.insertBefore(o,m)
})(document, window, '../../../metrics.haiku-os.org/tracker.js', 'fathom');
fathom('trackPageview');
</script>
<!-- / Fathom --></body>
<!-- Mirrored from www.haiku-os.org/legacy-docs/benewsletter/Issue4-10.html by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 05 Aug 2021 01:42:04 GMT -->
</html>
