<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<!-- Mirrored from www.haiku-os.org/legacy-docs/benewsletter/Issue3-45.html by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 05 Aug 2021 01:42:03 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- /Added by HTTrack -->
<head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Be Newsletters - Volume 3: 1998</title><link rel="stylesheet" href="be_newsletter.css" type="text/css" media="all" /><link rel="shortcut icon" type="image/vnd.microsoft.icon" href="images/favicon.ico" /><!--[if IE]>
    <link rel="stylesheet" type="text/css" href="be_newsletter_ie.css" />
    <![endif]--><meta name="generator" content="DocBook XSL Stylesheets V1.73.2" /><link rel="start" href="index-2.html" title="Be Newsletters" /><link rel="up" href="volume3.html" title="Volume 3: 1998" /><link rel="prev" href="Issue3-44.html" title="Issue 3-44, November 4, 1998" /><link rel="next" href="Issue3-46.html" title="Issue 3-46, November 18, 1998" /></head><body><div id="header"><div id="headerT"><div id="headerTL"><a accesskey="p" href="Issue3-44.html" title="Issue 3-44, November 4, 1998"><img src="images/navigation/prev.png" alt="Prev" /></a> <a accesskey="u" href="volume3.html" title="Volume 3: 1998"><img src="images/navigation/up.png" alt="Up" /></a> <a accesskey="n" href="Issue3-46.html" title="Issue 3-46, November 18, 1998"><img src="images/navigation/next.png" alt="Next" /></a></div><div id="headerTR"><div id="navigpeople"><a href="../../index.html"><img src="images/People_24.png" alt="haiku-os.org" title="Visit The Haiku Website" /></a></div><div class="navighome" title="Home"><a accesskey="h" href="index-2.html"><img src="images/navigation/home.png" alt="Home" /></a></div><div class="navigboxed" id="naviglang" title="English">en</div></div><div id="headerTC">Be Newsletters - Volume 3: 1998</div></div><div id="headerB">Prev: <a href="Issue3-44.html">Issue 3-44, November 4, 1998</a>  Up: <a href="volume3.html">Volume 3: 1998</a>  Next: <a href="Issue3-46.html">Issue 3-46, November 18, 1998</a></div><hr /></div><div class="article"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h2 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="Issue3-45"></a>Issue 3-45, November 11, 1998</h2></div></div></div><div class="sect1"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h2 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="Engineering3-45"></a>Be Engineering Insights: That BeOS is one baaad mother-[Shut your mouth!]
...just talking 'bout BeOS</h2></div><div xmlns:d="http://docbook.org/ns/docbook"><span xmlns="http://www.w3.org/1999/xhtml" class="author">By <span class="firstname">George</span> <span class="othername">"The Animal"</span> <span class="surname">Hoffman</span></span></div></div></div><p>
Jesse "The Body" Ventura is now the governor of Minnesota. He has, so
far, upped his mark on history from being the only gubernatorial
candidate to use the theme from "Shaft" in his campaign ads to also being
the only former pro wrestler to be elected governor. To all of us here at
Be, Jesse "The Body" is a shining example of a third-party candidate who
can beat the odds to win out over the incumbent and deliver what his
constituents really want. All it takes is some gumption, a great product,
and a fab set of pects. Between JLG and the rest of us here at Be, I
think we've got what it takes. Jesse, we salute you!
</p><p>
The app server has been vastly restructured in BeOS Release 4. Or, to put
it another way, the restructuring that I began in Release 3 has been
largely completed in R4. The app server is about 25,000 lines of code
slimmer. Of the remaining code, probably less than 40% of it has not
either been modified significantly or replaced with new code. For the
graphics team, R4 is certainly the most significant release we've been
involved in.
</p><p>
Much as I would love to brag about all the great stuff that's changed
internally for the better, I'll restrain myself. Suffice it to say that
the R4 app server is fundamentally much more robust, scalable, and sexy.
It's also faster—in some extreme cases, several orders of magnitude
faster.
</p><p>
That said, the features that we've introduced in R4 are not really so
innovative per se. For the most part they're features that other
operating systems already have, in one form or another. In this way, R4
has been sort of a "catch-up" release for the app server team, expanding
our feature set to better support applications that are coming online to
access the performance BeOS gives them.
</p><p>
"Yeah, blah, blah, blah. How about a feature list, dude?" OK. Those of
you with copies of the beta, follow along at home! For the rest of you,
don't worry, you'll see it soon enough.
</p><div class="sect2"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="id755099"></a>Much More Parallel</h3></div></div></div><p>
Some people with old S3 and Cirrus Logic video cards experienced hard
system freezes with earlier versions of the R4 beta. These freezes prove
that the incredibly buff new R4 graphics driver architecture (designed
and implemented by our own Trey "Ball-Buster" Boudreau) is working
correctly—too well, in the case of these cards. Prior to R4, the
locking done when a view was drawing was coarse-grained; no two threads
could draw to the frame buffer at the same time.
</p><p>
In R4, any number of threads can draw to the frame buffer simultaneously.
The only resource locked for exclusive access is the acceleration engine,
and that is locked only for the time required to feed the rendering
commands through the FIFO; synchronizing with the engine is intelligent
and is done only when absolutely necessary. This will be of particular
use in R5, when we plan to start accelerating many more calls than we do
now.
</p><p>
For R4, this means that the graphics system should be far more scalable
when using cards that support the new driver model.
</p></div><div class="sect2"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="id755135"></a>Faster Views</h3></div></div></div><p>
<code class="classname">BView</code>s, in all previous releases, have been too heavyweight for many
applications. A major valid complaint has been that <code class="classname">BView</code>s are too slow
when there are a large number of them in a window. In R4, views are much
faster. Although a full drawing context is still stored with every <code class="classname">BView</code>
-- and so the memory usage has not decreased—the major bottlenecks in
resizing, moving, and updating large numbers of views have been pinned
and beaten into submission.
</p><p>
One of those was recalculating the clipping region of the parent view.
All applications will benefit from optimizations made to these
calculations. For those who need more speed though, there is a new view
transaction API. This consists of two methods,
<code class="classname">BWindow</code>::<code class="methodname">BeginViewTransaction()</code> and
<code class="classname">BWindow</code>::<code class="methodname">EndViewTransaction()</code>. The
view system will behave as before without these calls, but if you bracket
resizing and moving of views between these two calls, the parent's
clipping region is not recalculated until the call to
<code class="methodname">EndViewTransaction()</code>.
</p><p>
These calls also do implicit <code class="methodname">DisableUpdates()</code>
and <code class="methodname">EnableUpdates()</code>. The
result is a dramatic increase in performance; the parent's clipping
region is updated once, rather than many intermediate times, and only one
update event is shot off at the end of the process. It's not uncommon for
a window with a large number of sibling views (say, a parent with 500
children) to see a 10x speedup without any changes to the source, and a
100x speedup when using the new API.
</p><p>
It's my explicit intention with the addition of this API to support
client-side layout libraries. R5 will probably see a major reduction in
memory usage for most views, with pieces of the rendering state allocated
only on demand.
</p></div><div class="sect2"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="id755220"></a>Views Can Draw on Children</h3></div></div></div><p>
Another favorite feature request has been to allow parent views to draw
on top of their children; i.e., do not exclude the children of a view
from that view's clipping region. R4 allows this and provides API to
support it.
</p><p>
To enable this behavior in a view, you must set the
<code class="constant">B_DRAW_ON_CHILDREN</code> flag. (I initially called this flag
<code class="constant">B_SCRIBBLE_ON_PRESCHOOLERS</code>, but our documentation guy
Doug "Hellfire" Fulton nixed that.) Setting this flag has two
effects: the view no longer excludes its children from its clipping region;
and a new, virtual <code class="classname">BView</code>::<code class="methodname">DrawAfterChildren()</code>, is
called after all the children of a view have had their own
<code class="methodname">Draw()</code> methods called on an update. This lets the
update mechanism correctly manage this new behavior. For instance,
<code class="methodname">DrawAfterChildren()</code> could draw a line from the
center of one child view to the center of another; because it is called
after the <code class="methodname">Draw()</code> methods of those individual
views, its drawing goes on top of whatever those views draw.
</p><p>
It's worth noting that using <code class="constant">B_TRANSPARENT_COLOR</code> as
the view color of a child of a parent that sets this flag allows some
interesting effects, previously impossible to achieve with views. For
instance, the parent can choose to fill itself with a tiled bitmap pattern,
and the child can draw itself with a bitmap using
<code class="constant">B_OP_OVER</code> or the new <code class="constant">B_OP_ALPHA</code>,
or even set an arbitrary clipping region and draw. This effectively allows
a limited form of non-rectangular views. The only thing missing is the
ability to clip the parent around an arbitrary child shape.
</p><p>
Also, a parent region with <code class="constant">B_DRAW_ON_CHILDREN</code> enabled never needs to
recalculate its clipping region when a child resizes or moves, for
obvious reasons. So even if your parent never draws anything, it can be a
slight performance win in some cases to set this flag for views with
large numbers of children.
</p></div><div class="sect2"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="id755312"></a>Arbitrary Clipping Regions</h3></div></div></div><p>
R4 introduces the long-awaited ability to clip to an arbitrary shape,
rather than the resolution-dependent, awkward
<code class="classname">BRegion</code>s. It's now possible to clip to either the
region of a <code class="classname">BPicture</code> or the inverse of that region.
The new <code class="classname">BView</code> methods that allow this are called --
startlingly—<code class="methodname">ClipToPicture()</code> and
<code class="methodname">ClipToInversePicture()</code>. Just build a
<code class="classname">BPicture</code> the way you normally would and then use it
in a call to these methods.
</p><pre class="programlisting cpp">
<span class="type">void</span> <code class="methodname">ClipToPicture</code>(<span class="type"><code class="classname">BPicture</code> *</span><code class="parameter">picture</code>,
                   <code class="classname">BPoint</code> <code class="parameter">where</code> = <code class="constant">B_ORIGIN</code>,
                   <span class="type">bool</span> <code class="parameter">sync</code> = <code class="constant">true</code>);

<span class="type">void</span> <code class="methodname">ClipToInversePicture</code>(<span class="type"><code class="classname">BPicture</code> *</span><code class="parameter">picture</code>,
                          <code class="classname">BPoint</code> <code class="parameter">where</code> = <code class="constant">B_ORIGIN</code>,
                          <span class="type">bool</span> <code class="parameter">sync</code> = <code class="constant">true</code>);
</pre><p>
There are many advantages to using this new clipping API.
<code class="classname">BPicture</code>s are stored as collections of drawing
commands. They are thus by nature in a vector format, and scale well for
resolution-independent output, such as printing. Because
<code class="classname">BPicture</code>s are server-side objects, the app server
can cache the complex arbitrary regions that a
<code class="classname">BPicture</code> can produce, so using the same
<code class="classname">BPicture</code> for the same clipping task repeatedly is fairly fast.
Also, as a completely intentional surprise bonus, it's easy to create a
clipping mask for an object. For instance, I can disable clipping, draw
picture A, then call <code class="methodname">ClipToInversePicture(A)</code> and
draw everything "underneath" A.
</p><p>
When your clipping region is simple and resolution dependent (i.e.,
probably most of the time), it's still a good idea to use <code class="classname">BRegion</code>
clipping (<code class="methodname">ConstrainClippingRegion()</code> calls)
because they incur much less
overhead.
</p><p>
Setting the <code class="parameter">sync</code> parameter to <code class="constant">true</code>
guarantees that the call to the app
server will complete by the time the method call returns. You should do
this if you plan, for instance, to delete your <code class="classname">BPicture</code> object afterwards.
</p><p>
The rules for <code class="classname">BRegion</code> clipping also apply to picture
clipping. A <code class="classname">BRegion</code> clipping area replaces a
<code class="classname">BPicture</code> clipping region within the same state stack
level, and vice versa.
</p></div><div class="sect2"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="id755515"></a>Alpha-Blended Rendering</h3></div></div></div><p>
Mmmmm...alpha.
</p><p>
<code class="constant">B_OP_ALPHA</code> has been added to the list of drawing modes. This alpha blends
all primitives based on several parameters which can be set with the new
<code class="methodname">SetBlendingMode()</code> call:
</p><pre class="programlisting cpp">
<span class="type">void</span> <code class="methodname">SetBlendingMode</code>(<span class="type">source_alpha</span> <code class="parameter">srcAlpha</code>, <span class="type">alpha_function</span> <code class="parameter">alphaFunc</code>);
</pre><p>
The possible values for the source alpha source (the source from which
the source alpha for the blending operation is obtained) are
<code class="constant">B_CONSTANT_ALPHA</code> and <code class="constant">B_PIXEL_ALPHA</code>.
<code class="constant">B_CONSTANT_ALPHA</code> tells the app server you want
to use the alpha value of the color you're drawing with as the source
alpha for the operation. <code class="constant">B_PIXEL_ALPHA</code> instead uses the alpha value of
the source pixel of the bitmap you're blitting. This is only meaningful
for <code class="constant">B_RGBA15</code> and <code class="constant">B_RGBA32</code> bitmaps,
as the alpha value is considered fully
opaque for all other bitmaps. Conversely, this parameter is always
considered to be B_CONSTANT_ALPHA for non-bitmap blitting, as there is no
source pixel.
</p><p>
For example, if I have a <code class="constant">B_RGBA32</code> bitmap of Jesse "The Body" Ventura,
with the alpha at a constant 240 for the entire bitmap except for Jesse's
dangerous, piercing eyes, which have alpha values of zero but are
otherwise correct pixels, blitting Mr. Ventura with <code class="constant">B_PIXEL_ALPHA</code> will
result in a slightly translucent Jesse with completely transparent holes
where his eyes should be. However, blitting Jesse with <code class="constant">B_CONSTANT_ALPHA</code>
and the high color alpha set to 128 will result in a half-transparent
Jesse, with his eyes looking no more or less transparent than the rest of
him.
</p><p>
The alpha function is trickier. I'll leave the full explanation for the
Be Book, but the quick version is that there are two possible values,
<code class="constant">B_ALPHA_OVERLAY</code> and <code class="constant">B_ALPHA_COMPOSITE</code>.
<code class="constant">B_ALPHA_OVERLAY</code> is the one you're
thinking of; it follows the conventions of the most popular OpenGL alpha
blending mode. It should be used most of the time, and all of the time
when blitting to the screen. <code class="constant">B_ALPHA_COMPOSITE</code> is slower, and is intended
for compositing primitives onto a bitmap that has transparency which must
be preserved. For instance, the translucent bitmap the R4 Tracker drags
when moving or copying files is created using <code class="constant">B_ALPHA_COMPOSITE</code>. For the
most part, if you need this, you know who you are. For more detailed
information, check out the Be Book.
</p></div><div class="sect2"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="id755662"></a>Asynchronous Controls</h3></div></div></div><p>
Part of the app server restructuring includes a new event model. In the
past, we recommended polling the mouse with
<code class="methodname">GetMouse()</code> in the
<code class="methodname">MouseDown()</code> method of your views in order to track
the mouse cursor or discover when a button is released. The reason was that
there was no way to guarantee that the view that received a
<code class="methodname">MouseDown()</code> would receive the corresponding
<code class="methodname">MouseUp()</code>, or for that matter, intermediate
<code class="methodname">MouseMoved()</code> events for tracking purposes.
</p><p>
R4 makes <code class="methodname">GetMouse()</code> polling more or less obsolete. Input and other types
of app server events are now much smarter. They know how important they
are (or aren't), and how to route themselves to whoever needs them. There
is new API for telling them they're wanted:
</p><pre class="programlisting cpp">
<span class="type">status_t</span> <code class="methodname">SetEventMask</code>(<span class="type">uint32</span> <code class="parameter">mask</code>, <span class="type">uint32</span> <code class="parameter">options</code>=0);
<span class="type">status_t</span> <code class="methodname">SetMouseEventMask</code>(<span class="type">uint32</span> <code class="parameter">mask</code>, <span class="type">uint32</span> <code class="parameter">options</code>=0);
</pre><p>
<code class="methodname">SetEventMask()</code> is effective until you disable it
by calling it again with <code class="parameter">mask</code> set to zero.
<code class="methodname">SetMouseEventMask()</code> is effective until the next
<code class="methodname">MouseUp()</code>. The <code class="parameter">mask</code>
parameter for each call contains flags for the events you wish to receive.
The only types right now are <code class="constant">B_POINTER_EVENTS</code> and
<code class="constant">B_KEYBOARD_EVENTS</code>, which are fairly self-explanatory.
</p><p>
The "options" parameter provides extra information about how you want to
route events. <code class="constant">B_LOCK_WINDOW_FOCUS</code>, which is only valid when using
<code class="methodname">SetMouseEventMask()</code>, prevents the window focus from changing, either from a
focus-follows-mouse user moving the mouse outside the window or from
another window requesting the focus, until the <code class="methodname">MouseUp()</code>.
<code class="constant">B_SUSPEND_VIEW_FOCUS</code>
prevents <code class="constant">B_KEYBOARD_EVENTS</code>, which are normally dispatched to the
window's focused view, from being sent there. This prevents, for
instance, any typing you do while holding the mouse down on a checkbox
from being sent to a text view of the same window that still has the
focus. <code class="constant">B_NO_POINTER_HISTORY</code> tells the app server that you want only the
most recent <code class="methodname">MouseMoved()</code> events, preventing a backlog of events from
queuing up for views that take a long time to process events.
</p><p>
As a result of these changes there is a new <code class="parameter">transit</code>
flag that can be passed to <code class="methodname">MouseMoved()</code>:
<code class="constant">B_OUTSIDE_VIEW</code>. This is for the case when the pointer
is outside the view but the view has subscribed to pointer events. Also,
<code class="methodname">MouseUp()</code> events are now properly dispatched.
</p><p>
Also, some support methods have been added to the <code class="classname">BControl</code> class to make
writing an asynchronous control easier and some API to <code class="classname">BWindow</code> to enable
asynchronous Interface Kit controls in a given window. See the Be Book
for details.
</p></div><div class="sect2"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="id755873"></a>Background Bitmaps</h3></div></div></div><p>
One long-overdue feature in the Release 4 <span class="application">Tracker</span> is the ability to place
a bitmap on the Desktop. As most developers know, it's trivial to draw a
bitmap into a view in the BeOS, so why did it take so long to implement
desktop bitmaps? It's not because Pavel "Sizzlin'" Cisler, our <span class="application">Tracker</span>
engineer, is slow and has trouble finding his way to work in the morning.
All those rumors are almost entirely unfounded.
</p><p>
The reason is that although it was possible to draw bitmaps, it wasn't
possible to do it immediately. There was a delay before the update
mechanism kicked in, and in the meantime the view filled with a
background color. But if you drew a bitmap over this color, there was a
great deal of flicker. Setting the view color to transparent helped, but
there was still a delay, and on a loaded system there would be "window
droppings" while the update waited to be scheduled. You may have seen a
similar effect on Windows NT.
</p><p>
The solution we came up with is a general one, which provides for
background bitmaps on any view, and gives tiling and positional options.
The API is parallel to the <code class="methodname">SetViewColor()</code> calls:
</p><pre class="programlisting cpp">
<span class="type">void</span> <code class="methodname">SetViewBitmap</code>(<span class="type">const<code class="classname">BBitmap</code> *</span><code class="parameter">bitmap</code>,
                   <code class="classname">BRect</code> <code class="parameter">srcRect</code>,
                   <code class="classname">BRect</code> <code class="parameter">dstRect</code>,
                   <span class="type">uint32</span> <code class="parameter">followFlags</code> = <code class="constant">B_FOLLOW_TOP</code>|<code class="constant">B_FOLLOW_LEFT</code>,
                   <span class="type">uint32</span> <code class="parameter">options</code> = <code class="constant">B_TILE_BITMAP</code>);

<span class="type">void</span> <code class="methodname">SetViewBitmap</code>(<span class="type">const<code class="classname">BBitmap</code> *</span><code class="parameter">bitmap</code>,
                   <span class="type">uint32</span> <code class="parameter">followFlags</code> = <code class="constant">B_FOLLOW_TOP</code>|<code class="constant">B_FOLLOW_LEFT</code>,
                   <span class="type">uint32</span> <code class="parameter">options</code> = <code class="constant">B_TILE_BITMAP</code>);

<span class="type">void</span> <code class="methodname">ClearViewBitmap</code>();
</pre><p>
The window manager fills an exposed or invalidated view with the given
bitmap at nearly the same time it would have filled it with the
background color. The only time a delay occurs is when the bitmap is not
in physical RAM and needs to be swapped in. The version without a source
and destination rectangle assumes the upper-left corner at (0,0) and no
scaling. <code class="methodname">ClearViewBitmap()</code> removes any current view bitmap.
</p><p>
The follow flags work just as they do with views. The <code class="parameter">option</code> flags right
now are only for specifying tiling options. <code class="constant">B_TILE_BITMAP</code>, the default,
tiles vertically and horizontally, while <code class="constant">B_TILE_BITMAP_X</code> and
<code class="constant">B_TILE_BITMAP_Y</code>, astonishingly, tile either horizontally or vertically,
respectively. For tiling cases, the destination rect you give is still
obeyed, and the bitmap is tiled outward from there.
</p><p>
The bitmap you pass to these calls is referenced by the app server as the
background for that view, but no copies are made. Therefore, it's legal
and recommended to use the same bitmap for more than one view if the
views in question have the same background. It's also legal to delete the
bitmap while it's the background of one or more views. The app server
keeps a reference count and clean ups the bitmap when all views using it
either choose another background or are deleted.
</p><p>
This behavior means that changes you make to a bitmap after setting it as
the background of a view are seen when the view is next refreshed and the
bitmap is blitted to the screen.
</p></div><div class="sect2"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="id756085"></a>New BShape API</h3></div></div></div><p>
The <code class="classname">BShape</code> class is more or less an encapsulation of
a Postscript- style path. A <code class="classname">BShape</code> is composed of
any number of connected or disjointed, open or closed polygons, described
by line segments and quadratic Bezier curves. They can be stroked or filled
in a <code class="classname">BView</code>, and, by drawing them into a
<code class="classname">BPicture</code> and using
<code class="methodname">ClipToPicture()</code>, they can be clipped to.
</p><pre class="programlisting cpp">
<span class="type">void</span> <code class="methodname">StrokeShape</code>(<span class="type"><code class="classname">BShape</code> *</span><code class="parameter">shape</code>,
                 <span class="type">pattern</span> <code class="parameter">p</code> = <code class="constant">B_SOLID_HIGH</code>);

<span class="type">void</span> <code class="methodname">FillShape</code>(<span class="type"><code class="classname">BShape</code> *</span><code class="parameter">shape</code>,
               <span class="type">pattern</span> <code class="parameter">p</code> = <code class="constant">B_SOLID_HIGH</code>);
</pre><p>
One difference with filled <code class="classname">BShape</code>s is that, unlike
other filled primitives, they don't include edge pixels; that is, they do
not assume the outside edge is stroked with a one-pixel-wide brush. This
gives them some nice properties, including the ability to abut two
<code class="classname">BShape</code>s, with no overlap or gap between them. I
recommend using them whenever possible for high-precision or
resolution-independent drawing.
</p><p>
<code class="classname">BShape</code>s also have accessor methods that let you read
or modify points in a <code class="classname">BShape</code>. Modification can be
done inline, since <code class="classname">BShape</code>s are completely
client-side objects, allowing for easy translation or rotation of a shape.
Because <code class="classname">BShape</code>s are composed entirely of lines and
Beziers, they are invariable under all linear transformations. (You can
perform nonlinear transformations, of course, but don't expect your shapes
to look right afterwards!)
</p></div><div class="sect2"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="id756222"></a>Exposed Font Glyph Information</h3></div></div></div><p>
In R4 it's possible to retrieve the shape of a particular font glyph from
the system-wide font library. <code class="classname">BShape</code>s serve as the delivery mechanism for
glyphs. The API is a new method of <code class="classname">BFont</code>:
</p><pre class="programlisting cpp">
<span class="type">void</span> <code class="methodname">GetGlyphShapes</code>(<span class="type">const char</span> <code class="parameter">charArray</code>[],
                    <span class="type">int32</span> <code class="parameter">numChars</code>,
                    <span class="type"><code class="classname">BShape</code> *</span><code class="parameter">glyphShapeArray</code>[]) const;
</pre><p>
You allocate the <code class="classname">BShape</code>s, it does the rest. You can use the escapement
information returned by other <code class="classname">BFont</code> methods to place your shapes for
drawing. Because <code class="classname">BShape</code>s allow easy transformations, it's now possible to
transform and distort text easily.
</p></div><div class="sect2"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="id756300"></a>So Where's the Code?</h3></div></div></div><p>
I'd planned to write all this fancy sample code for y'all to demonstrate
many of these new features, but...uh...I didn't. Too busy fixing bugs
during R4 beta testing. I will, however, probably write up some sample
code and put it into the Developer Library in a few weeks. Until then,
it's up to you guys. I expect wonders! Get to work. Make Jesse proud.
</p></div></div><hr class="pagebreak" /><div class="sect1"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h2 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="Engineering3-45-2"></a>Be Engineering Insights: Are You Experienced?</h2></div><div xmlns:d="http://docbook.org/ns/docbook"><span xmlns="http://www.w3.org/1999/xhtml" class="author">By <span class="firstname">Matt</span> <span class="surname">Bogosian</span></span></div></div></div><p>
As the fog rolls over the mountains and threatens to envelop the Stanford
Dish in a thick, cottony blanket, the setting sun breaks through for the
first time on this brisk November day in Menlo Park, casting lukewarm
light across the tree tops, and painting sharply contrasting shadows
against the ubiquitous office-beige walls of my repo-depot erector set of
a cube. I am a Be engineer.
</p><p>
So my day continues into the night in the countdown to Release 4. After
spending my summers here as an intern, I've recently joined the Be team
full time, with a mission to maintain what is known as "the Installation
Experience." Welcome to the BeOS, may I take your order?
</p><p>
They (in the proverbial sense) say that one never gets a second chance to
make a first impression. Just as your first handshake can tell the father
of the girl you're dating that you're not a complete moron and are worthy
of spending time in a well-lit, crowded place with his little princess,
the installation process is frequently the first real exposure new users
have to our product. That's why we'd like to make it as smooth and
pleasurable as possible. This is what now rests on my shoulders.
</p><p>
There are two essential goals in writing almost any piece of software:
simplicity and utility. In many cases "simple" is synonymous with
"intuitive." I like to use a completely unscientific metric for
quantifying simplicity in terms of the number of instructions read and
number of mistakes made before one has a comfortable basic working
knowledge of a given tool.
</p><p>
User manuals are rarely read. Therefore, it's important that a tool
(however well-documented) have a base functionality and interface that
allows users to "jump right in" and start being productive with a minimal
amount of knowledge. This is easy if a program doesn't do much, but it
becomes more difficult with a feature-rich everything-but-
the-virtual-sink utility.
</p><p>
The trick is to present a tool's features in a logical, intuitive way. If
a word processor requires users to learn a new scripting language --
documented only on an obscure overseas BBS whose number is listed on the
CD-ROM on which the program is distributed—in order to change a font
size, chances are that the interface could use some rethinking. The tool
may be useful—it may let you capitalize every other letter of every
third word in paragraphs beginning with the phrase, "It was the best
of..."—but that functionality (however useful) will be hidden from
most users if the interface is cryptic. Even expert users will be
reluctant to use your features if they are inaccessible; intuitive
interfaces are not just for neophytes.
</p><p>
In the case of the BeOS installer, these goals are two-fold. We'd not
only like the BeOS to be easy to acquire, configure, and run, but we also
want our developers to make a similar first impression. This is why I've
undertaken the task of giving our installation utilities a major
overhaul. My goal is to provide a more feature-rich set of tools that are
easy to use for both developers and end users.
</p><p>
We've got the simplicity, now it's time to add some features. The current
BeOS Installer is the result of efforts to maintain the ease of
installing the OS. The notion of the "one button install" is a powerful
one, and I believe it should be maintained. One badly needed feature that
seems to be missing from the vocabulary of BeOS installers, however, is
an "uninstall." Another welcome feature would be the ability to back out
in the middle of an installation without affecting the volume onto which
the package is being installed. From a developer's standpoint, I'd like
to see more flexibility than just a "standard" install and an "optional"
install. These are a few of many improvements that could be made.
</p><p>
I've just recently joined the team, so watch for an installation overhaul
in Release 5. This gives you plenty of time to send in your feature
requests (what do you want to install today?). Let me know if there's
anything you can't live without or would find useful in a package
creation or installation utility, and I'll worry about making it fun and
accessible. You can e-mail your suggestions/comments/requests to
&lt;mattb@be.com&gt;. As my Desktop background continually reminds me, I only
have two more releases to buy one of these:
</p><p>
<a class="ulink" href="http://www.yamaha-motor.com/sport/products/modelimage/8/1/0/image.aspx">http://www.yamaha-motor.com/sport/products/modelimage/8/1/0/image.aspx</a><br />
[Editors' note: Hopefully this is the correct URL as the page has moved between 1998 and 2006]
</p><p>
So I guess I'd better get back to work.
</p></div><hr class="pagebreak" /><div class="sect1"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h2 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="DevWorkshop3-45"></a>Developers' Workshop: Sounding Off With the New Media Kit</h2></div><div xmlns:d="http://docbook.org/ns/docbook"><span xmlns="http://www.w3.org/1999/xhtml" class="author">By <span class="firstname">Eric</span> <span class="surname">Shepherd</span></span></div></div></div><p>
It was one year ago this week that I wrote my first Be Newsletter
article, called "Sounds That Go Bump in the Night." In it, I explained
how to play sound under the Preview Release 2 and Release 3 Media Kit.
That was by subscribing to the audio stream, then filling buffers with
16-bit stereo audio data as it passes through your stream hook function.
</p><p>
Now we're on the brink of unleashing the new and improved BeOS Release 4
Media Kit, and it's a whole new ballgame. This article covers the new
Media Kit's audio capabilities, with a special focus on updating existing
applications to use the new API.
</p><p>
If you're not familiar with the Release 3 Media Kit, you don't really
need to know how to update your applications, but if you're curious, you
can read my two articles on sound playback in Release 3:
</p><p>
<a class="xref" href="Issue2-45.html#DevWorkshop2-45" title="Developers' Workshop: Sounds That Go Bump In the Night">Developers' Workshop: Sounds That Go Bump In the Night</a>
</p><p>
<a class="xref" href="Issue3-3.html#DevWorkshop3-3" title="Developers' Workshop: Daddy, Where Does Sound Come From?">Developers' Workshop: Daddy, Where Does Sound Come From?</a>
</p><p>
Sound playback in the Release 4 Media Kit is done with the
<code class="classname">BSound</code> and <code class="classname">BSoundPlayer</code>
classes. <code class="classname">BSound</code> represents a sound (either on disk
or in memory), and <code class="classname">BSoundPlayer</code> provides functions
for playing sound, either by playing a <code class="classname">BSound</code>, or by
receiving buffers that you can fill in with audio data and pass along.
</p><p>
The former method is the easiest to use for new applications. Depending
on the needs of your Release 3 Media Kit application, it may be easier to
use <code class="classname">BSound</code> and <code class="classname">BSoundPlayer</code>
together than the second method, which in
many ways is similar to the previous Media Kit's stream hook function
method for playing sounds.
</p><p>
Under Release 3, your sound playing code always involves a hook function
that receives buffers from the Audio Server, fills them with data, and
passes them along down the audio stream. This is usually overkill,
especially if all you're doing is playing a sound from disk (see
<a class="xref" href="Issue3-3.html#DevWorkshop3-3" title="Developers' Workshop: Daddy, Where Does Sound Come From?">Developers' Workshop: Daddy, Where Does Sound Come From?</a> for sample code on how this was done in
Release 3).
</p><p>
Here's code that plays a sound from disk using the Release 4 Media Kit:
</p><pre class="programlisting cpp">
#include &lt;MediaDefs.h&gt;
#include &lt;Sound.h&gt;
#include &lt;SoundPlayer.h&gt;
#include &lt;Entry.h&gt;
#include &lt;Path.h&gt;

<span class="type">void</span> <code class="function">playsound</code>(<span class="type">char *</span><code class="parameter">path</code>) {
  <span class="type"><code class="classname">BSound</code> *</span><code class="varname">sound</code>;
  <code class="classname">BSoundPlayer</code> <code class="varname">player</code>;
  <span class="type">entry_ref</span> <code class="varname">ref</code>;
  <code class="classname">BEntry</code> <code class="varname">entry</code>(<code class="parameter">path</code>, <code class="constant">true</code>);
  <code class="classname">BSoundPlayer</code>::<span class="type">play_id</span> <code class="varname">id</code>;


  if (<code class="varname">entry</code>.<code class="methodname">InitCheck</code>() == <code class="constant">B_OK</code>) {
    if (<code class="varname">entry</code>.<code class="methodname">GetRef</code>(&amp;<code class="varname">ref</code>) == <code class="constant">B_OK</code>) {
      <code class="varname">sound</code> = new <code class="classname">BSound</code>(&amp;<code class="varname">ref</code>);
      if (<code class="varname">sound</code>-&gt;<code class="methodname">InitCheck</code>() == <code class="constant">B_OK</code>) {
        <code class="varname">player</code>.<code class="methodname">Start</code>();
        <code class="varname">player</code>.<code class="methodname">SetVolume</code>(1.0);
        <code class="varname">id</code> = <code class="varname">player</code>.<code class="methodname">StartPlaying</code>(<code class="varname">sound</code>);
        <code class="varname">sound</code>-&gt;<code class="methodname">ReleaseRef</code>();
        <code class="varname">player</code>.<code class="methodname">WaitForSound</code>(<code class="varname">id</code>);
      }
    }
  }
}
</pre><p>
This function accepts a pathname as input, and plays the sound in the
specified file. It doesn't return until playback is complete. Let's see
how it works.
</p><p>
The most interesting local variables here are the
<span class="type"><code class="classname">BSound</code>*</span> and the <code class="varname">id</code>
variable. <span class="type"><code class="classname">BSound</code>*</span> is a pointer to the
<code class="classname">BSound</code> object that represents the
sound on disk, <code class="classname">BSoundPlayer</code>, which is the object that handles playing the
sound. The <code class="varname">id</code> variable, of type
<span class="type"><code class="classname">BSoundPlayer</code>::play_id</span>, contains the ID
number assigned to the sound by the <code class="classname">BSoundPlayer</code> when we start playing it.
</p><p>
The first thing it does is obtain an <span class="type">entry_ref</span> for the path (using
<code class="methodname">BEntry::GetRef()</code>). Then a <code class="classname">BSound</code>
object is instantiated, using that <span class="type">entry_ref</span>. This sets up
the <code class="classname">BSound</code> object to reference that file. There's also
a form of the <code class="classname">BSound</code> constructor for creating sounds that are kept in
memory.
</p><p>
Once the sound is instantiated, and we've checked to be sure it was done
successfully, we start up the <code class="classname">BSoundPlayer</code> by
calling <code class="methodname">Start()</code>, set the
volume to maximum by calling <code class="methodname">SetVolume()</code>, and then start playing the
sound using the <code class="methodname">StartPlaying()</code> function.
</p><p>
The <code class="classname">BSoundPlayer</code> class can play as many sounds as you want (as long as
every sound you play through a given <code class="classname">BSoundPlayer</code> is at the same sampling
rate). That's why <code class="methodname">StartPlaying()</code> returns an ID number. If you want to
check the status of a sound, or stop it, you use that ID number to
specify which sound you're interested in. For instance, you might want to
call <code class="methodname">IsPlaying()</code> to determine if the sound is still playing.
</p><p>
Once the sound has been started, we call
<code class="methodname">BSound::ReleaseRef()</code> on the sound to mark the
sound to be deleted once playback is finished. That means that as soon as
the <code class="classname">BSoundPlayer</code> is done with the sound, the
<code class="classname">BSound</code> object is automatically deleted. Then we call
<code class="classname">BSoundPlayer</code>::<code class="methodname">WaitForSound()</code> to wait until the
sound has finished playing.
</p><p>
If we wanted the <code class="function">playsound()</code> function to be
asynchronous, we would just remove the call to
<code class="methodname">WaitForSound()</code>, since we've arranged for
<code class="classname">BSound</code>s to be deleted automatically when they're
done playing.
</p><p>
That's the easy way to play sound in the R4 Media Kit. But what if your
playback needs are more involved? Maybe your code needs to adjust the
sound during playback, or your sounds are generated on the fly. The
<code class="classname">BSoundPlayer</code> class can help you there, too.
</p><p>
<code class="classname">BSoundPlayer</code> supports the ability to specify a play buffer function that
is called for every buffer that passes through the sound player's node.
This lets you fill these buffers with whatever sound data you want. You
create a <code class="classname">BSoundPlayer</code> for this purpose by either specifying the play
buffer function when you instantiate the <code class="classname">BSoundPlayer</code>, or by calling
<code class="classname">BSoundPlayer</code>::<code class="methodname">SetBufferPlayer()</code> or
<code class="classname">BSoundPlayer</code>::<code class="methodname">SetCallbacks()</code>. You can
also specify a cookie (application-specific data) that is passed to the
play buffer function each time it's called.
</p><p>
In this example, we'll use stereo floating-point audio at 44.1kHz (this
is the preferred format in the R4 Media Kit; floating-point audio is used
internally, so by using it in your applications you can reduce overhead
by preventing unnecessary format conversions). We'll create a play buffer
function that plays a continuous triangle wave. The cookie tracks where
we are in the wave across calls to the play buffer function. Here's the
structure for the cookie:
</p><pre class="programlisting cpp">
typedef struct <span class="type">cookie_record</span> {
  <span class="type">float</span> value;
  <span class="type">float</span> direction;
} <span class="type">cookie_record</span>;
</pre><p>
The main program instantiates the <code class="classname">BSoundPlayer</code> and handles running the
sound. Since we're using the Media Kit's native sound format, we don't
have to specify a media raw audio format structure to tell it what format
to use. If we wanted to use, say, 16-bit stereo, we'd have to provide a
media raw audio format structure to the <code class="classname">BSoundPlayer</code> constructor.
</p><p>
Keep in mind that Be reserves the right to change the default format. In
fact, it's almost guaranteed to change over time as the Media Kit
evolves, so you shouldn't assume that floating- point 44.1kHz stereo is
the default. If you care, you should set it explicitly.
</p><pre class="programlisting cpp">
<span class="type">cookie_record</span> <code class="varname">cookie</code>;
<code class="varname">cookie</code>.<code class="varname">value</code> = 0.0;
<code class="varname">cookie</code>.<code class="varname">direction</code> = 1.0;
<code class="classname">BSoundPlayer</code> <code class="function">player</code>("wave player", <code class="varname">BufferProc</code>, <code class="constant">NULL</code>,
  &amp;<code class="varname">cookie</code>);
</pre><p>
We now have a <code class="classname">BSoundPlayer</code> that's tied to a play buffer function called
<code class="methodname">BufferProc()</code>. It receives a pointer to our cookie each time it's called.
</p><p>
Here's some simple code that starts and stops the tone:
</p><pre class="programlisting cpp">
<code class="varname">player</code>.<code class="methodname">Start</code>();
<code class="varname">player</code>.<code class="methodname">SetHasData</code>(<code class="constant">true</code>);
<code class="function">getchar</code>();      <span class="comment">/* wait until return is hit */</span>
<code class="varname">player</code>.<code class="methodname">Stop</code>();
</pre><p>
The <code class="classname">BBufferPlayer</code>::<code class="methodname">Start()</code> and
<code class="classname">BBufferPlayer</code>::<code class="methodname">Stop()</code> functions start and
stop the playback, as in the previous example. The <code class="methodname">SetHasData()</code> function
is new: it tells the <code class="classname">BSoundPlayer</code> that our play buffer function is in
fact ready to generate audio data. Your play buffer function won't be
called until this has been done. When you don't have sound to play, you
should call <code class="code"><code class="methodname">SetHasData</code>(<code class="constant">false</code>)</code>
so the Media Kit doesn't keep calling your
play buffer function when there's no sound to play; this improves
performance.
</p><p>
Now let's have a look at the <code class="methodname">BufferProc()</code>:
</p><pre class="programlisting cpp">
<span class="type">void</span> <code class="methodname">BufferProc</code>(<span class="type">void *</span><code class="parameter">theCookie</code>, <span class="type">void *</span><code class="parameter">buffer</code>, <span class="type">size_t</span> <code class="parameter">size</code>,
       <span class="type">constmedia_raw_audio_format &amp;</span><code class="parameter">format</code>) {
  <span class="type">size_t</span> <code class="varname">i</code>, <code class="varname">j</code>;
  <span class="type">float *</span><code class="varname">buf</code> = (<span class="type">float *</span>) <code class="parameter">buffer</code>;
  <span class="type">size_t</span> <code class="varname">float_size</code> = <code class="parameter">size</code>/4;
  <span class="type">uint32</span> <code class="varname">channel_count</code> = <code class="parameter">format</code>.<code class="varname">channel_count</code>;
  <span class="type">cookie_record *</span><code class="varname">cookie</code> = (<span class="type">cookie_record *</span>) <code class="parameter">theCookie</code>;


  if (<code class="parameter">format</code>.<code class="varname">format</code> !=
        <span class="type">media_raw_audio_format</span>::<code class="constant">B_AUDIO_FLOAT</code>) {
    return;
  }


  for (<code class="varname">i</code>=0; <code class="varname">i</code>&lt;<code class="varname">float_size</code>; <code class="varname">i</code>+=<code class="varname">channel_count</code>) {
    for (<code class="varname">j</code>=0; <code class="varname">j</code>&lt;<code class="varname">channel_count</code>; <code class="varname">j</code>++) {
      <code class="varname">buf</code>[<code class="varname">i</code>+<code class="varname">j</code>] = <code class="varname">cookie</code>-&gt;<code class="varname">value</code>;
    }
    if ((<code class="varname">cookie</code>-&gt;<code class="varname">direction</code> == 1.0) &amp;&amp;
        (<code class="varname">cookie</code>-&gt;<code class="varname">value</code> &gt;= 1.0)) {
      <code class="varname">cookie</code>-&gt;<code class="varname">direction</code> = -1.0;
    }
    else if ((<code class="varname">cookie</code>-&gt;<code class="varname">direction</code> == -1.0) &amp;&amp;
             (<code class="varname">cookie</code>-&gt;<code class="varname">value</code> &lt;= -1.0)) {
      <code class="varname">cookie</code>-&gt;<code class="varname">direction</code> = 1.0;
    }
    <code class="varname">cookie</code>-&gt;<code class="varname">value</code> += <code class="varname">cookie</code>-&gt;<code class="varname">direction</code>*(1.0/64.0);
  }
}
</pre><p>
This function (if you're familiar with the Release 3 Media Kit) is the R4
equivalent of the enter stream hook function used when you subscribe to a
<code class="classname">BDACStream</code> to pump audio buffers into the stream. The key difference is
that in this case, the buffers are yours and yours alone; you should
replace their contents with your own data. In Release 3, you received
buffers containing data provided by other applications that were playing
sounds.
</p><p>
The code begins by setting up some local variables. A local pointer to
the audio buffer is created, of type <span class="type">float*</span>, since that's the format of
the data we'll store in the buffer. We compute <span class="type">float</span> size, the number of
<span class="type">float</span>s in the buffer, and we fetch the channel count out of the media raw
audio format structure we receive that describes the audio format. We
also set up a pointer to the cookie of the correct type.
</p><p>
Then we check to be sure that the buffer's audio format is in fact
floating-point by comparing its format to the value
<span class="type">media_raw_audio_format</span>::<code class="constant">B_AUDIO_FORMAT</code>.
If it doesn't match, we return without doing
anything.
</p><p>
Then we enter a loop that fills out the buffer with data. How this works
isn't really important. You can replace this code with whatever you want
in order to provide the sound you require. The only interesting thing to
note is that parameters for building the audio are pulled from the
cookie, and updated values are stored back into its fields before the
<code class="methodname">BufferProc()</code> returns.
</p><p>
If your Release 3 Media Kit application simply plays sound, you should be
able to use one of these two methods to update your R4 Media Kit
application easily. If your code is straightforward, and plays sounds
unaltered, you may find it easier to use the BSound and BSoundPlayer
combination to perform the audio. If your enter stream hook function is
more complex, performing audio generation on the fly, the play buffer
mechanism should let you update your application without much effort.
</p><p>
About the only applications that can't readily be updated to the R4 Media
Kit by using these two classes are those that filter the audio output by
other applications, or applications that record audio. For these, you'll
have to look deeper into the Media Kit.
</p></div><hr class="pagebreak" /><div class="sect1"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h2 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="Gassee3-45"></a>More Notes From the Road: BeOS in Tokyo</h2></div><div xmlns:d="http://docbook.org/ns/docbook"><span xmlns="http://www.w3.org/1999/xhtml" class="author">By <span class="firstname">Jean-Louis</span> <span class="surname">Gassée</span></span></div></div></div><p>
As I write this, we're in a conference room in Hitachi's Personal
Computer Division headquarters, near Shin Ochanomizu in Tokyo, just steps
away from the geek Mecca of Akihabara. We're working on the last details
of presentations to introduce three Hitachi Flora Prius systems bundled
with Gobe Productive and Adamation Personal Studio applications for the
BeOS, in a partition next to the standard Windows 98 binaries.
</p><p>
This event is a little more complicated than usual, but it's a happy one
nonetheless. Some time ago, we made a commitment to the Japanese market,
based on reasons and emotions I've discussed in prior columns. Japan is,
after all, the birthplace of much digital media technology. It is a
market of technophiles and, in contradiction to the conservative
stereotype affixed to its culture, fairly comfortable with unproven ideas.
</p><p>
It also didn't hurt that a number of us at Be are unabashed Japanophiles.
Singling out anyone's contribution in integrated work such as ours could
be unfair to the rest of the team, but today's occasion reminds me that
we wouldn't be here without one of our engineers, Hiroshi Lockheimer, who
made sure we have a truly Japanese version of the BeOS.
</p><p>
From where I sit, I can see Bob Hearn, Gobe's CTO, entering Japanese
text in a Productive document for his demo. One of the complications
mentioned earlier involved flying Bob out of Hawaii, hours after his
sister-in-law's wedding. Stephan Adams also made the trip to introduce
Personal Studio. All of us, including Jim Cook, Michael McBride, and
myself, along with spare equipment and software in a broken case, a
translator and a number of our Hitachi hosts, are now rehearsing a four
company presentation in two languages (and more accents). Our audience is
dailies in the morning and magazines in the afternoon.
</p><p>
The good news is that Hitachi PR people are running around looking for a
bigger room—it looks like we'll have more media people than originally
planned. Or else our Hitachi friends know the rule regarding the number
of seats in the room before a presentation: stack half the chairs in a
corner and make a spectacle of putting them back when the available ones
are filled. That way the presentation starts with an audience that thinks
it's larger than planned. Or, if only half the people you expected show
up, you don't start with a group of people wondering why the other half
haven't bothered to attend.
</p><p>
The preparation is meticulous and high tech. Hitachi requests a change in
my presentation, I scribble it on a piece of paper; Morita-san, the
translator, edits a slide on his PowerBook, and e-mails the changes. The
new color-printed hand-outs are produced somewhere else in Tokyo. I
notice he's using a tiny Kenwood wireless phone—at ISDN speed, I'm
told—from the inside of a reinforced concrete building. Unlike a
dedicated modem such as the Ricochet, this uses a standard digital phone.
It appears faster, more reliable, and more common than what we enjoy
today in the US or in Europe.
</p><p>
Hitachi and our Japanese distributor, Plat'Home, have supported the BeOS
from the beginning of its market life. Month after month, Plat'Home has
generated a disproportionately high percentage of our sales volume. They
also introduced us to Hitachi, leading to the present joint effort.
Interestingly, after taking a long look at the BeOS and at the
marketplace, Hitachi came to its own conclusions—remarkably similar to
ours—regarding what they call "media creation and browsing," the
respective capabilities of Windows 98 and of the BeOS, and their
coexistence.
</p><p>
During Hitachi's pre-introduction briefings to selected media, one
question was asked repeatedly: Why does Hitachi, a very conservative
company, make such an unconventional move? This is more the style of Sony.
</p><p>
Somehow, this seemed to make Hitachi executives happy.
</p></div></div><div id="footer"><hr /><div id="footerT">Prev: <a href="Issue3-44.html">Issue 3-44, November 4, 1998</a>  Up: <a href="volume3.html">Volume 3: 1998</a>  Next: <a href="Issue3-46.html">Issue 3-46, November 18, 1998</a> </div><div id="footerB"><div id="footerBL"><a href="Issue3-44.html" title="Issue 3-44, November 4, 1998"><img src="images/navigation/prev.png" alt="Prev" /></a> <a href="volume3.html" title="Volume 3: 1998"><img src="images/navigation/up.png" alt="Up" /></a> <a href="Issue3-46.html" title="Issue 3-46, November 18, 1998"><img src="images/navigation/next.png" alt="Next" /></a></div><div id="footerBR"><div><a href="../../index.html"><img src="images/People_24.png" alt="haiku-os.org" title="Visit The Haiku Website" /></a></div><div class="navighome" title="Home"><a accesskey="h" href="index-2.html"><img src="images/navigation/home.png" alt="Home" /></a></div></div><div id="footerBC"><a href="http://www.access-company.com/home.html" title="ACCESS Co."><img alt="Access Company" src="images/access_logo.png" /></a></div></div></div><div id="licenseFooter"><div id="licenseFooterBL"><a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/3.0/" title="Creative Commons License"><img alt="Creative Commons License" style="border-width:0" src="../../../licensebuttons.net/l/by-nc-nd/3.0/88x31.png" /></a></div><div id="licenseFooterBR"><a href="LegalNotice.html">Legal Notice</a></div><div id="licenseFooterBC"><span id="licenseText">This work is licensed under a
          <a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/3.0/">Creative
          Commons Attribution-Non commercial-No Derivative Works 3.0 License</a>.</span></div></div><!-- Fathom -->
<script>
(function(f, a, t, h, o, m){
	a[h]=a[h]||function(){
		(a[h].q=a[h].q||[]).push(arguments)
	};
	o=f.createElement('script'),
	m=f.getElementsByTagName('script')[0];
	o.async=1; o.src=t; o.id='fathom-script';
	m.parentNode.insertBefore(o,m)
})(document, window, '../../../metrics.haiku-os.org/tracker.js', 'fathom');
fathom('trackPageview');
</script>
<!-- / Fathom --></body>
<!-- Mirrored from www.haiku-os.org/legacy-docs/benewsletter/Issue3-45.html by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 05 Aug 2021 01:42:03 GMT -->
</html>
