<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<!-- Mirrored from www.haiku-os.org/legacy-docs/benewsletter/Issue5-3.html by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 05 Aug 2021 01:59:36 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- /Added by HTTrack -->
<head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Be Newsletters - Volume 5: 2000</title><link rel="stylesheet" href="be_newsletter.css" type="text/css" media="all" /><link rel="shortcut icon" type="image/vnd.microsoft.icon" href="images/favicon.ico" /><!--[if IE]>
    <link rel="stylesheet" type="text/css" href="be_newsletter_ie.css" />
    <![endif]--><meta name="generator" content="DocBook XSL Stylesheets V1.73.2" /><link rel="start" href="index-2.html" title="Be Newsletters" /><link rel="up" href="volume5.html" title="Volume 5: 2000" /><link rel="prev" href="Issue5-2.html" title="Issue 5-2, January 12, 2000" /><link rel="next" href="Issue5-4.html" title="Issue 5-4, January 26, 2000" /></head><body><div id="header"><div id="headerT"><div id="headerTL"><a accesskey="p" href="Issue5-2.html" title="Issue 5-2, January 12, 2000"><img src="images/navigation/prev.png" alt="Prev" /></a> <a accesskey="u" href="volume5.html" title="Volume 5: 2000"><img src="images/navigation/up.png" alt="Up" /></a> <a accesskey="n" href="Issue5-4.html" title="Issue 5-4, January 26, 2000"><img src="images/navigation/next.png" alt="Next" /></a></div><div id="headerTR"><div id="navigpeople"><a href="../../index.html"><img src="images/People_24.png" alt="haiku-os.org" title="Visit The Haiku Website" /></a></div><div class="navighome" title="Home"><a accesskey="h" href="index-2.html"><img src="images/navigation/home.png" alt="Home" /></a></div><div class="navigboxed" id="naviglang" title="English">en</div></div><div id="headerTC">Be Newsletters - Volume 5: 2000</div></div><div id="headerB">Prev: <a href="Issue5-2.html">Issue 5-2, January 12, 2000</a>  Up: <a href="volume5.html">Volume 5: 2000</a>  Next: <a href="Issue5-4.html">Issue 5-4, January 26, 2000</a></div><hr /></div><div class="article"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h2 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="Issue5-3"></a>Issue 5-3, January 19, 2000</h2></div></div></div><div class="sect1"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h2 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="Engineering5-3"></a>Be Engineering Insights: A Simple Network Discovery Protocol</h2></div><div xmlns:d="http://docbook.org/ns/docbook"><span xmlns="http://www.w3.org/1999/xhtml" class="author">By <span class="firstname">Alfred</span> <span class="surname">Landrum</span></span></div></div></div><p>
Imagine yourself in a completely dark room. You can't see anything, but
you know other people are around you, because you can hear them talking.
Occasionally, two people try to talk at the same time. This is followed
by a short pause, and then the talking begins again. The conversations
you hear are bizarre, almost nonsensical, like this:
</p><div class="literallayout"><p>"Hank! This is Howard! I have some data for you: #$@#$@%@"<br />
"Joe! This is Al! What time is it?"<br />
"Howard! This is Hank! I acknowledge data #$@#$@%@".<br />
"Al! This is Joe! The time is January 3, 2000, 14:45 hours"<br />
"Everyone! This is Jason! I'm here!"<br />
</p></div><p>
This is one way I picture the network: A noisy dark room, with lots of
shouting.
</p><p>
Our task for today is finding out who's in this room with you.
</p><p>
There are many applications that need a list of the people in this dark
room. The MS Windows Network Neighborhood and the Macintosh Chooser are
well known examples. They build a list of computers that are providing
some kind of resource to other computers. In this article, I'll talk
through one approach for network discovery, and you can find the source
code for an implementation here:
&lt;ftp://ftp.be.com/pub/samples/network_kit/netdisc.zip&gt;
</p><p>
Let's close our eyes, and put ourselves mentally in the dark room...
</p><p>
The first thing we'll do is to announce our presence. The last thing
we'll do is to announce that we're leaving. Between our entrance and
egress, we'll announce our existence every so often; if we suddenly drop
off the network, everyone else will eventually notice. This is quite
literally a heartbeat—if the others don't hear it, they assume we have
died. If we announce too often, we waste bandwidth; too infrequently, and
we'll show up in the other members' list long after we die. If we wait 5
minutes, and our announcement message is 100 bytes long, our protocol
consumes .3 bytes per second per computer, which is entirely acceptable.
</p><p>
After we announce our presence, we'd like to fulfill our purpose and find
out who else is around. We could wait a while, and eventually we'd hear
everyone announce themselves. You probably don't want to wait that long.
And, we need to remember that we may be the only one present, so we may
never hear from anyone.
</p><p>
A naive way is to ask everyone to announce themselves at once. Obviously,
this is hard on the network and, given the choice, it'd be easier if
someone just handed us a list of computers, rather than trying to compile
one ourselves. If we had a designated "special" computer, that we knew of
beforehand, we could just ask it. This is a centralized solution, with
all the normal centralized problems: What if your special computer is
down? What if it can't deal with the barrage of requests it gets?
</p><p>
We could have the special computer chosen dynamically, through some type
of election protocol. This is, in my opinion, worse. Election protocols
are hard to implement, and harder to debug. This is not the answer
either. What's left is a solution that doesn't depend on a single
computer, whether statically or dynamically specified as "special."
</p><p>
Let me convince you that you already know the solution to this problem.
Imagine, if you will, that you're at a party, conversing with friends.
You're feeling comfortable, and the conversation is easy. Suddenly, a
person, whom none of you know, walks up to your group, and without
pausing to listen to the conversation, blurts out loudly, "What are you
talking about?" (Are you picturing this? Concentrate.) Now, what happens?
</p><p>
In my experience (which I hope crosses cultural boundaries), there is a
pregnant pause, as you and your friends try to decide whether to ignore
the impolite intrusion. Then, someone in your group hesitantly offers the
topic of conversation. This is our solution! In my analysis, here's what
happened. Immediately after the outburst, everyone stops talking. There's
a small amount of time when the members of your group look at each other,
waiting to see if someone else says something, until finally someone
does. Depending on how sociable your friends are, someone may answer
quickly, or no one may answer at all. If no one answers, and if the
annoying person wants the answer badly, they'll repeat themselves. Got it?
</p><p>
So, first you announce your presence on the network. Then, you broadcast
a packet that means, "Who's there?" Every member individually decides
whether or not they'll be the one to reply. Before they reply, they'll
wait a bit to see if someone else has already done so. If someone else
replies, there's no need to transmit. [An issue with this bit of the
protocol is how to deal with other members who have just come up. Check
the source code.]
</p><p>
How do the members decide whether they'll reply? Looking back at the
party example, if your group is fairly large, there's a reasonable
expectation that someone (and not you) will answer first. If your group
is small, then there's a greater chance that you would have to answer.
</p><p>
So, whether you answer depends on the size of your group. Practically,
you could decide that you have a 1/N chance of responding, where N is the
size of the group. Or, you could increase that (by some constant factor)
to ensure that a timely reply is made. If the "Who's there?" question is
repeated, then you know that no one replied, and you increase your chance
of responding. Eventually, the questioner will get a reply, which will be
the list of current members.
</p></div><hr class="pagebreak" /><div class="sect1"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h2 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="Engineering5-3-2"></a>Be Engineering Insights: Good MediaFile Behavior</h2></div><div xmlns:d="http://docbook.org/ns/docbook"><span xmlns="http://www.w3.org/1999/xhtml" class="author">By <span class="firstname">Dave</span> <span class="surname">Bort</span></span></div></div></div><div class="sect2"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="id435712"></a>PART I: tcode externals (the little part)</h3></div></div></div><p>
In my work with the media codecs, I've found the <span class="application">tcode</span> utility to be an
invaluable tool. You may have seen it sitting around in
</p><p>
/boot/optional/sample-code/media_kit/MediaFile/transcode/tcode.cpp
</p><p>
on your R4.5 CD, and you may have even played with it. In any case, I've
got a new version for you here. Although it should compile and run on
R4.5, it won't do you much good (except as an example of things to come)
as the Maui codec add-ons have changed a lot.
</p><p>
&lt;ftp://ftp.be.com/pub/samples/media_kit/transcode_r5.zip&gt;
</p><pre class="screen">
tcode [-info][-start frame-num][-end frame-num]
      [-avi|-qt|-quicktime|-wav|-aiff|-mp3]
      [-v &lt;encoder_name&gt;][-a &lt;encoder_name&gt;]
      &lt;filename&gt; [&lt;output&gt;]
</pre><p>
But what does it do? <span class="application">tcode</span> takes an input media file (e.g., QuickTime)
with some sort of media encoding (e.g., IMA audio, Cinepak video) and
translates (transcodes) it into a possibly different format/encoding
(e.g., AVI file, raw audio, Indeo5 video). Of course, the proper
encoders/decoders (codecs) need to be installed on your system to do so,
and tcode can help you there as well with its   -info 
switch. Here's what I have on my system:
</p><pre class="screen">
$ tcode -info

Audio IFF format (AIFF) (AIFF, id 788608)
    Video Encoders:
    Audio Encoders:
        Raw Audio / raw-audio (9)
AVI File Format (avi, id 788609)
    Video Encoders:
        Cinepak Compression / cinepak (0)
        DV Compression by Canopus Inc. / dv (1)
        Indeo5 Video / iv50 (3)
        Photo-JPEG Compression / pjpeg (8)
        Raw Video / raw-video (9)
    Audio Encoders:
        Raw Audio / raw-audio (9)
MP3 Audio File Format (mp3, id 788610)
    Video Encoders:
    Audio Encoders:
        BladeEnc MP3 Encoder / mp3 (6)
QuickTime File Format (quicktime, id 787264)
    Video Encoders:
        Cinepak Compression / cinepak (0)
        DV Compression by Canopus Inc. / dv (1)
        Indeo5 Video / iv50 (3)
        Photo-JPEG Compression / pjpeg (8)
        Raw Video / raw-video (9)
    Audio Encoders:
        IMA Adaptive PCM / ima4 (2)
        Microsoft Adaptive PCM / ms-adpcm (7)
        Raw Audio / raw-audio (9)
RIFF Audio File Format (WAV) (wav, id 788705)
    Video Encoders:
    Audio Encoders:
        Microsoft Adaptive PCM / ms-adpcm (7)
        Raw Audio / raw-audio (9)
</pre><p>
At the outer level are the supported file formats, and at the inner level
are the installed encoders. Each format/encoder has a pretty name (e.g.,
"AVI File Format") and a short name (e.g., "avi").
<span class="application">tcode</span> refers to the
add-ons using their short names. The add-ons themselves live in
<code class="filename">/boot/beos/system/add-ons/media/{decoders,encoders, extractors,writers}</code>
or in a similar place under <code class="filename">/boot/home/config/add-ons</code>, so the
extra-curious can poke around in there.
</p><p>
Using the above example where we have a QuickTime file <code class="filename">csquares.mov</code> and
want to translate it into a raw-audio/Indeo5 AVI file, the command line is
</p><pre class="screen">
tcode -avi -a raw-audio -v iv50 csquares.mov csquares.avi
</pre><p>
which, after some churning, will produce the new AVI file <code class="filename">csquares.avi</code>.
You can open it with MediaPlayer and it'll look and sound just like the
original, except that it's now in an entirely different format. Crazy.
</p><p>
Note that <code class="command">tcode -info</code> only displays a list of the installed
encoders/writers. BeOS can read more formats than it can write, so tcode
could take an MPEG1 or <code class="filename">.au</code> file as input and create a QuickTime or AIFF
as output. Looking at the installed add-ons will give you a good idea of
what <span class="application">tcode</span> can accept as input.
</p><p>
Another important point is that not all file formats can accept all
encodings. Our AVI writer, for example, only accepts raw audio, so if you
want encoded audio with a movie you need to use QuickTime. And even then,
you're stuck with IMA-encoded audio if you want to be able to play the
movie on another platform.
</p><p>
Speaking of which, <span class="application">tcode</span> allows you to create some format/encoding
combinations that will play on BeOS but won't play on Windows or MacOS.
For instance, to save space I <span class="application">tcode</span>d a raw-audio/Cinepak AVI into an
IMA/Indeo5 QuickTime, but didn't have any luck playing it under Win95.
</p><p>
You'll also notice the  -start  and
  -end  switches to <span class="application">tcode</span>. They allow
you to specify the starting and ending video frames of the transcode, in
case you'd like the output to be a clip of the input. These aren't as
intuitive as they may seem, but they get the job done. First, they'll
only work if the input file has a video stream and if you've specified
the   -v  option on the command line. Second, audio is only handled
properly if you've specified the   -a  option.
</p><p>
If you'd like to keep the encodings the same and simply produce a
shortened file, you'll still need to specify the encodings explicitly.
This is necessary because tcode needs to decode and re-encode the video
stream in order to find the specified frames when it's dealing with
keyframe-based encodings like MPEG1 and Cinepak. Still, it beats the
built-in Linux video editing suite [dd(1)] hands-down.
</p><p>
It would be possible to avoid this step for formats without keyframes
(e.g., Indeo5 or DV) but the simplicity of the transcode loop was too
nice to ruin with special cases (i.e., I was lazy). Of course, <span class="application">tcode</span>
could be modified to do all of this format duplication internally, but
that's exercise-for-the-reader stuff.
</p></div><div class="sect2"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="id435931"></a>PART IIa: tcode internals (the medium part)</h3></div></div></div><div class="sect3"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="id435938"></a>Dramatis Personae</h4></div></div></div><div class="sect4"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h5 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="id435944"></a>Terms:</h5></div></div></div><table class="variablelist"><tbody><tr><td><p><span class="term">Writers:</span></p></td><td><p>
Add-ons that know how to generate a specific file-format. We
have writers for AIFF, AVI, QuickTime, and WAV.
</p></td></tr><tr><td><p><span class="term">Extractors:</span></p></td><td><p>
Add-ons that know how to parse a specific file-format. We
have extractors for AIFF, AU, AVI, AVR, DV, MPEG1, QuickTime, and WAV.
</p></td></tr><tr><td><p><span class="term">Encoders:</span></p></td><td><p>
Add-ons that can convert raw audio or video into encoded
data. We have encoders for Cinepak, DV, IMA, Indeo5, mp3, MS-ADPCM, and
Photo-JPEG. There is also a null encoder for raw data; it's good for
avoiding special cases in some encode loops.
</p></td></tr><tr><td><p><span class="term">Decoders:</span></p></td><td><p>
Add-ons that can convert encoded media data into raw audio or
video. We have decoders for Apple Video, CCITT-ADPCM, Cinepak, DV (audio
and video), IMA, Indeo5, MPEG1 (audio and video), MS-ADPCM, MS RLE, MS
Video, Photo-JPEG, and ulaw. There is also a null decoder for raw data.
</p></td></tr></tbody></table></div><div class="sect4"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h5 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="id436017"></a>Classes:</h5></div></div></div><table class="variablelist"><tbody><tr><td><p><span class="term"><code class="classname">BMediaFile</code>:</span></p></td><td><p>
This class represents a file containing media, either for
reading or writing. Media streams within the file are accessed using
<code class="classname">BMediaTrack</code>s. (<code class="filename">MediaFile.h</code>)
</p></td></tr><tr><td><p><span class="term"><code class="classname">BMediaTrack</code>:</span></p></td><td><p>
Represents a stream of media data, usually audio or video.
Is used for both reading and writing. (<code class="filename">MediaTrack.h</code>)
</p></td></tr></tbody></table></div><div class="sect4"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h5 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="id436076"></a>Structures:</h5></div></div></div><table class="variablelist"><tbody><tr><td><p><span class="term"><span class="type">media_format</span>:</span></p></td><td><p>
The most-used (and -abused) beast in the Media Kit. This
struct and its ilk describe the format of a media stream. At the top
level is the 'type' field, which is usually set to one of
<code class="constant">B_MEDIA_RAW_AUDIO</code>, <code class="constant">B_MEDIA_ENCODED_AUDIO</code>,
<code class="constant">B_MEDIA_RAW_VIDEO</code>, or
<code class="constant">B_MEDIA_ENCODED_VIDEO</code>. Depending on the type, an element of the union 'u'
is used to further describe the media, such as <code class="varname">u.raw_audio</code> or
<code class="varname">u.encoded_video</code>. (<code class="filename">MediaDefs.h</code>)
</p></td></tr><tr><td><p><span class="term"><span class="type">media_file_format</span>:</span></p></td><td><p>
Describes a file format (writer) such as AVI or
QuickTime. It contains various names for the file type as well as some
minimal indications of what can be written to the file.
(<code class="filename">MediaDefs.h</code>)
</p></td></tr><tr><td><p><span class="term"><span class="type">media_codec_info</span>:</span></p></td><td><p>
Describes a codec (encoder/decoder) such as Indeo5 or
mp3. It contains pretty and short names for the codec as well as an ID
pointing to the encoder/decoder add-on it represents.
(<code class="filename">MediaFormats.h</code>)
</p></td></tr></tbody></table></div><div class="sect4"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h5 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="id436184"></a>Functions:</h5></div></div></div><table class="variablelist"><tbody><tr><td><p><span class="term"><code class="function">get_next_file_format(<span class="type">int32 *</span><code class="parameter">cookie</code>, <span class="type">media_file_format *</span><code class="parameter">mfi</code>)</code>:</span></p></td><td><p>
Walks through the installed writers, filling in the <span class="type">media_file_format</span>
each time. To find a specific writer, check one of the name fields;
<code class="varname">short_name</code> is usually best, although <code class="varname">mime_type</code>
and <code class="varname">file_extension</code> should
do the job as well. (<code class="filename">MediaDefs.h</code>)
</p></td></tr><tr><td><p><span class="term"><code class="function">get_next_encoder(...)</code>:</span></p></td><td><p>
Walks through the installed encoders that match the passed-in parameters,
filling in the <span class="type">media_codec_info</span> each time. You can specify the formats
you'd like it to translate from/to, and which file format you'd like to
write to. There are three different versions of this function, so choose
wisely. In general; the more parameters you specify, the stricter the
search. See the header file for specifics. (<code class="filename">MediaFormats.h</code>)
</p></td></tr></tbody></table><p>
**Note: Although I have said "audio or video" in several places, the API
does not restrict the data to these types. If you can dream up some sort
of time/frame-based media, the API can handle it.
</p><p>
**Also Note: Decoders/Encoders do not necessarily need to translate
to/from raw audio/video, but that's what they all currently do. There's
nothing stopping a Decoder from translating MPEG to Cinepak, but most
applications wouldn't be able to make much use of it; they tend to deal
with raw media formats.
</p><p>
**Note as well, kind readers: Someday you'll all be able to write your
own extractors/writers/encoders/decoders, but that day is not today. The
internal codec API is still in flux and is not yet public.
</p></div></div><div class="sect3"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="id436301"></a>And Now, It's</h4></div></div></div><div class="sect4"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h5 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="id436307"></a>dump_info():</h5></div></div></div><p>
With that out of the way, we can look at <code class="filename">tcode.cpp</code>. Just to get the hang
of things, we'll start out by seeing how tcode knows which
encoders/writers are installed on your system when called with the
'-info' switch. This is handled in <code class="function">dump_info()</code>, and it's time for you to
be amazed at how short it is. Notice that it uses all the structures and
functions I named above, so it's a good place to start.
</p><p>
At a glance, you can easily see what <code class="function">dump_info()</code> is doing:
</p><div class="literallayout"><p>for each writer<br />
    dump video encoders compatible with this file format<br />
    dump audio encoders compatible with this file format<br />
</p></div><p>
The "for each writer" part is accomplished using <code class="function">get_next_file_format()</code>.
Assuming the cookie var is initialized to zero, <code class="function">get_next_file_format()</code>
will return a different <span class="type">media_file_format</span> each time it is called. When
there are no more writers, <code class="function">get_next_file_format()</code> returns <code class="constant">B_BAD_INDEX</code>.
</p><p>
Now that we have a writer (described by 'mfi'), we can find the encoders
compatible with it by using <code class="function">get_next_encoder()</code>. As I said above, there
are three versions of <code class="function">get_next_encoder()</code>. <code class="function">dump_info()</code> uses this one:
</p><pre class="programlisting cpp">
<span class="type">status_t</span>
<code class="function">get_next_encoder</code>(<span class="type">int32 *</span><code class="parameter">cookie</code>,
                 <span class="type">const media_file_format *</span><code class="parameter">mfi</code>,
                 <span class="type">const media_format *</span><code class="parameter">input_format</code>,
                 <span class="type">media_format *</span><code class="parameter">output_format</code>,
                 <span class="type">media_codec_info *</span><code class="parameter">ei</code>);
</pre><p>
This function works like <code class="function">get_next_file_format()</code>,
except that there's the option of restricting the results to match a
certain <span class="type">media_file_format</span> and <span class="type">media_format</span>.
<code class="parameter">mfi</code> (the parameter) is the file format we want to
match, <code class="parameter">input_format</code> is the format of the media we
have, <code class="parameter">output_format</code> will be set by the encoder, and
<code class="parameter">ei</code> describes the encoder. When I say that
<code class="parameter">output_format</code> is set by the encoder, I mean: given
the raw media described by <code class="parameter">input_format</code>, the encoder
will translate it into data described by
<code class="parameter">output_format</code>. It is
<code class="parameter">output_format</code>-type data that will actually be
written to the file, so the writer must accept this format.
</p></div></div><p>
=== Sidebar: media_format pitfalls ===
</p><p>
For the purposes of <code class="function">dump_info()</code>, we don't care too much about the
<span class="type">media_format</span> parameters, but we still need to specify them to
differentiate between audio and video. And now for the cardinal
<span class="type">media_format</span> rule:
</p><p>
** Don't zero-out a media_format **
</p><p>
As with all c++ structs, <span class="type">media_format</span> is a class in disguise; it just
flaunts it more than usual. It has a constructor/destructor as well as
some private data members, and thus a <code class="code">memset(&amp;amp;mf, 0,
sizeof(media_format))</code> could potentially wipe out some important data.
This is a known problem, and there are ways around it. When creating a
<span class="type">media_format</span>, the constructor zeros out the public bits for you. If you'd
like to clear a <span class="type">media_format</span> you've already used, follow the example of
<code class="function">dump_info()</code> by assigning the appropriate union member to the appropriate
wildcard, or do a <code class="code">memset(&amp;amp;mf.u, 0, sizeof(mf.u))</code> which will zero out the
whole union regardless of the media type. And in the same vein:
</p><p>
** Don't use <code class="function">malloc()</code> for dynamic <span class="type">media_format</span>s **
</p><p>
Say you want an array of <span class="type">media_format</span>s. If you were to
</p><pre class="programlisting cpp">
<span class="type">media_format</span> *<code class="varname">mf</code> =
    (<span class="type">media_format</span>*)<code class="function">malloc</code>(10 * <code class="function">sizeof</code>(<span class="type">media_format</span>));
</pre><p>
then the aforementioned constructor would never get called. Instead, use
the c++ construct
</p><pre class="programlisting cpp">
<span class="type">media_format</span> *<code class="varname">mf</code> = new <span class="type">media_format</span>[10];
</pre><p>
and be sure to <code class="code">delete [] mf;</code> when done. There probably is some tricksy
c++ way to use a constructor on the results of <code class="function">malloc()</code>, but I'm not
filthy-minded enough to read that far into my Stroustrup.
</p><p>
All right. So, to get the video encoders we pass in a blank media_format
with the type set to <code class="constant">B_MEDIA_RAW_VIDEO</code>, and to get the audio encoders we
pass in a blank <span class="type">media_format</span> with the type set to <code class="constant">B_MEDIA_RAW_AUDIO</code>.
<code class="function">get_next_encoder()</code> will only return those encoders that can encode
<code class="parameter">input_format</code> and whose results can be written to <span class="type">media_file_format</span>
<code class="parameter">mfi</code>. From there, we can display the pretty table produced by <code class="command">tcode
-info</code> with a minimum of fuss.
</p></div></div><hr class="pagebreak" /><div class="sect1"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h2 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="DevWorkshop5-3"></a>Developers' Workshop: The Haydn Sample Code Projects</h2></div><div xmlns:d="http://docbook.org/ns/docbook"><span xmlns="http://www.w3.org/1999/xhtml" class="author">By <span class="firstname">Owen</span> <span class="surname">Smith</span></span></div></div></div><p>
With the upcoming release of the BeOS comes a brand spanking-new Midi Kit
-- actually, despite the way this kit is traditionally capitalized,
that's not "Le Midi," as in Haydn's Symphony #7, but rather
<acronym class="acronym" title="Musical Instrument Digital Interface">MIDI</acronym>, the
link between you and those synthesizers, drum machines, and other
sound-spewing instruments with 5-pin
<acronym class="acronym" title="Deutsches Institut für Normung">DIN</acronym> connections that you may have
tucked into the corners of various rooms in your household. A little
while back I wrought two pieces of sample code that demonstrate the
abilities of the new <acronym class="acronym">MIDI</acronym> Kit, and I more or less concealed them from the
world at large, in the perpetual gloom of the private
<acronym class="acronym" title="Developer Technical Support">DTS</acronym>
<acronym class="acronym" title="File Transfer Protocol">FTP</acronym> site. Now,
the time has arrived for these pieces of sample code to see the light of
day. Some of you have already seen this code—so, to keep your
interest, I'll even describe how the new Midi Kit works.
</p><div class="sect2"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="id432386"></a>Sights and Sounds of the New Midi Kit</h3></div></div></div><p>
The first and most important point to note is that
<code class="classname">BMidiConsumer</code> and
<code class="classname">BMidiProducer</code> in the Midi Kit are <span class="emphasis"><em>NOT</em></span> directly
analogous to <code class="classname">BBufferConsumer</code> and
<code class="classname">BBufferProducer</code> in the Media Kit! In the Media Kit,
consumers and producers are the data consuming and producing properties of
a media node. A filter in the Media Kit, therefore, inherits from both
<code class="classname">BBufferConsumer</code> and
<code class="classname">BBufferProducer</code>, and implements their virtual member
functions to do its work. In the Midi Kit, consumers and producers act as
endpoints of <acronym class="acronym">MIDI</acronym> data connections, much as
<span class="type">media_source</span> and <span class="type">media_destination</span> do in the
Media Kit. Thus, a <acronym class="acronym">MIDI</acronym> filter does not derive from
<code class="classname">BMidiConsumer</code> and
<code class="classname">BMidiProducer</code>; instead, it contains
<code class="classname">BMidiConsumer</code> and
<code class="classname">BMidiProducer</code> objects for each of its distinct
endpoints that connect to other <acronym class="acronym">MIDI</acronym> objects. This also
contrasts with the old Midi Kit's conception of a
<code class="classname">BMidi</code> object, which stood for an object that both
received and sent <acronym class="acronym">MIDI</acronym> data. In the new Midi Kit, the
endpoints of <acronym class="acronym">MIDI</acronym> connections are all that matters --
what lies between the endpoints, i.e., how a <acronym class="acronym">MIDI</acronym> filter
is actually structured, is entirely at your discretion.
</p><p>
The second thing to note about the Midi Kit is the distinction between
remote and local <acronym class="acronym">MIDI</acronym> objects. If you look at
<code class="classname">BMidiConsumer</code>, for example, you'll see that there
just ain't that much there in terms of implementation API. On the other
hand, just below the declaration for <code class="classname">BMidiConsumer</code>
in <code class="filename">MidiConsumer.h</code> lies the
declaration for <code class="classname">BMidiLocalConsumer</code>, which has all
the hook functions that you'd expect to see in a consumer object. This
dualism comes from the way that the Midi Roster deals with remote objects.
All <acronym class="acronym">MIDI</acronym> endpoints that you create derive from
<code class="classname">BMidiLocalConsumer</code> and
<code class="classname">BMidiLocalProducer</code>, and their member functions work
the way you'd expect. In order to hide the details of communication with
<acronym class="acronym">MIDI</acronym> endpoints in other applications, however, the Midi
Kit must hide the details of how a particular endpoint is implemented.
</p><p>
Thus, the Midi Roster only gives you access to
<code class="classname">BMidiEndpoint</code>s,
<code class="classname">BMidiConsumer</code>s, and
<code class="classname">BMidiProducer</code>s, so these are the classes you'll be
working with when you want access to <acronym class="acronym">MIDI</acronym> objects in
other applications. So, what can you do with remote objects? Only what
<code class="classname">BMidiConsumer</code>, <code class="classname">BMidiProducer</code>,
and <code class="classname">BMidiEndpoint</code> will let you do. You can connect
objects, get properties of these objects—and that's about it.
</p><p>
The final thing I want to note about the Midi Kit is the reference
counting scheme. Each <acronym class="acronym">MIDI</acronym> endpoint has a reference count associated with
it, so that the bookkeeping associated with the endpoints is correct.
When you construct an endpoint, it starts with a count of 1. Once the
count hits 0, the endpoint will be deleted. This means that, to delete an
endpoint, you don't call the delete operator directly; instead, you call
<code class="methodname">BMidiEndpoint::Release()</code>. To balance this call, there's also a
<code class="methodname">BMidiEndpoint::Acquire()</code>, in case you have two disparate parts of your
application working with the endpoint, and you don't want to have to keep
track of who needs to <code class="methodname">Release()</code> the endpoint.
</p><p>
The trick in reference counting that trips up some people is that the
Midi Roster increments the reference count of any object it hands to you,
as a result of <code class="methodname">NextEndpoint()</code> or
<code class="methodname">FindEndpoint()</code>. So, when you're done with any
object the Midi Roster gives you, you must
<code class="methodname">Release()</code> it! This lets you treat remote objects
and local objects the same way with respect to reference counting. Repeat
after me: <code class="methodname">Release()</code> when you're done.
</p></div><div class="sect2"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="id432624"></a>Transposer: The Model <acronym class="acronym">MIDI</acronym> Filter</h3></div></div></div><p>
I remember once being forced to sit at a piano in one of my music classes
and transpose Bach's Prelude in C major (BWV 846) to F# major on the fly
in front of the class. Mathematically, this reduces to a trivial mapping:
just raise each note by six half-steps. Doing this while playing,
however, is considerably less trivial. As a firm believer in the "work
smarter, not harder" ethic, therefore, I commend the following utility to
your attention for when you're called upon to transpose music on a <acronym class="acronym">MIDI</acronym>
instrument:
</p><p>
&lt;ftp://ftp.be.com/pub/samples/midi_kit/Transposer.zip&gt;
</p><p>
This is a <acronym class="acronym">MIDI</acronym> filter that transposes incoming events by a variable
amount and sends them out the output—about as simple a filter as there
is.
</p><p>
The base class that I use in Transposer to represent a
<acronym class="acronym">MIDI</acronym> filter—and a class that I hope will be useful
for you as well!—is called <code class="classname">SimpleMidiFilter</code>. It
contains exactly one <code class="classname">BMidiLocalConsumer</code> and one
<code class="classname">BMidiLocalProducer</code>. When data arrives at the input,
one of a number of filter functions gets called in the filter class,
analogous to the filter operation in <code class="classname">BMessageFilter</code>.
You override any of these functions to handle a specific kind of event
however you want, sending events to the output if necessary, and return a
code to indicate whether the original event should be sent to the input or
not. If you don't override the functions, they return the default action
(which is to send the original event to the output without modification,
though you can specify a different default action if you want).
</p><p>
Note that the consumer endpoint of a
<code class="classname">SimpleMidiFilter</code> derives from
<code class="classname">BMidiLocalConsumer</code>, whereas the procurer endpoint is
simply a <code class="classname">BMidiLocalProducer</code>. This is a common
configuration, because consumers work by overriding the event hooks to do
work when <acronym class="acronym">MIDI</acronym> data arrives (in the case of
<code class="classname">SimpleMidiFilter</code>, the consumer needs to call
<code class="classname">SimpleMidiFilter</code> hook functions), whereas producers
work by sending an event when you call their member functions. You should
never derive from <code class="classname">BMidiLocalProducer</code> (unless you
need to know when the producer gets connected or disconnected, perhaps),
but you'll always have to override one or more of
<code class="classname">BMidiLocalConsumer</code>'s member functions to do
something useful with incoming data.
</p></div><div class="sect2"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="id432736"></a>Dokken in the Patch Bay</h3></div></div></div><p>
The second piece of code I've promised you is a handy tool for browsing
the <acronym class="acronym">MIDI</acronym> objects in your system and connecting them together. It, too, is
now available at participating FTP sites:
</p><p>
&lt;ftp://ftp.be.com/pub/samples/midi_kit/PatchBay.zip&gt;
</p><p>
The interface for <span class="application">PatchBay</span> is crude yet effective. Along the top is a row
of icons representing the consumers in your system; along the left-hand
side is a row of icons representing the producers in your system, and a
wee meter that gives you an idea of the number of events emanating from
that producer. Move your mouse over an icon, and a tool tip pops up to
give you more information about the object, like the ID and name of the
object.
</p><p>
Between these icons is a matrix of check-boxes that represent connections
between the <acronym class="acronym">MIDI</acronym> objects in your system. Click on a
check box to connect two <acronym class="acronym">MIDI</acronym> objects together (such as
running Dokken guitar riffs from your <acronym class="acronym">MIDI</acronym> port into a
<code class="classname">Transposer</code> instance). Click on the check box again
to disconnect the two objects.
</p><p>
The magic behind the implementation of <span class="application">PatchBay</span>
comes from the <code class="methodname">BMidiRoster::StartWatching()</code>
function. You call this function and specify a
<code class="classname">BMessenger</code> that you want to receive
<acronym class="acronym">MIDI</acronym> notifications (in this case, the messenger points
to our top-level view, the <code class="classname">PatchView</code>). When you
start watching, the <code class="classname">BMidiRoster</code> starts by sending
you notifications for all currently registered nodes, and all the current
connections between objects. Thereafter, you'll receive notifications any
time something important happens to an object (objects
registered/connected, objects disconnected/unregistered, properties
changing, etc.). <span class="application">PatchBay</span> uses these
notifications to maintain an up-to-date view of the state of
<acronym class="acronym">MIDI</acronym> objects in your system.
</p><p>
Some of you may be wondering where the icons come from. Well, there's a
mechanism in the new Midi Kit for storing properties associated with an
endpoint in a <code class="classname">BMessage</code>. This can include any kind of information that
might be useful to associate with a <acronym class="acronym">MIDI</acronym> object. If you look in
<code class="classname">Transposer</code>, you'll see that it stores a large and mini icon as properties
in the <code class="classname">BMessage</code>. Feel free to use properties however you want—if you
come up with something particularly useful, let us know!
</p></div></div></div><div id="footer"><hr /><div id="footerT">Prev: <a href="Issue5-2.html">Issue 5-2, January 12, 2000</a>  Up: <a href="volume5.html">Volume 5: 2000</a>  Next: <a href="Issue5-4.html">Issue 5-4, January 26, 2000</a> </div><div id="footerB"><div id="footerBL"><a href="Issue5-2.html" title="Issue 5-2, January 12, 2000"><img src="images/navigation/prev.png" alt="Prev" /></a> <a href="volume5.html" title="Volume 5: 2000"><img src="images/navigation/up.png" alt="Up" /></a> <a href="Issue5-4.html" title="Issue 5-4, January 26, 2000"><img src="images/navigation/next.png" alt="Next" /></a></div><div id="footerBR"><div><a href="../../index.html"><img src="images/People_24.png" alt="haiku-os.org" title="Visit The Haiku Website" /></a></div><div class="navighome" title="Home"><a accesskey="h" href="index-2.html"><img src="images/navigation/home.png" alt="Home" /></a></div></div><div id="footerBC"><a href="http://www.access-company.com/home.html" title="ACCESS Co."><img alt="Access Company" src="images/access_logo.png" /></a></div></div></div><div id="licenseFooter"><div id="licenseFooterBL"><a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/3.0/" title="Creative Commons License"><img alt="Creative Commons License" style="border-width:0" src="../../../licensebuttons.net/l/by-nc-nd/3.0/88x31.png" /></a></div><div id="licenseFooterBR"><a href="LegalNotice.html">Legal Notice</a></div><div id="licenseFooterBC"><span id="licenseText">This work is licensed under a
          <a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/3.0/">Creative
          Commons Attribution-Non commercial-No Derivative Works 3.0 License</a>.</span></div></div><!-- Fathom -->
<script>
(function(f, a, t, h, o, m){
	a[h]=a[h]||function(){
		(a[h].q=a[h].q||[]).push(arguments)
	};
	o=f.createElement('script'),
	m=f.getElementsByTagName('script')[0];
	o.async=1; o.src=t; o.id='fathom-script';
	m.parentNode.insertBefore(o,m)
})(document, window, '../../../metrics.haiku-os.org/tracker.js', 'fathom');
fathom('trackPageview');
</script>
<!-- / Fathom --></body>
<!-- Mirrored from www.haiku-os.org/legacy-docs/benewsletter/Issue5-3.html by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 05 Aug 2021 01:59:36 GMT -->
</html>
