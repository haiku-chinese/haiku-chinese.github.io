<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<!-- Mirrored from www.haiku-os.org/legacy-docs/benewsletter/Issue4-1.html by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 05 Aug 2021 01:42:03 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- /Added by HTTrack -->
<head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Be Newsletters - Volume 4: 1999</title><link rel="stylesheet" href="be_newsletter.css" type="text/css" media="all" /><link rel="shortcut icon" type="image/vnd.microsoft.icon" href="images/favicon.ico" /><!--[if IE]>
    <link rel="stylesheet" type="text/css" href="be_newsletter_ie.css" />
    <![endif]--><meta name="generator" content="DocBook XSL Stylesheets V1.73.2" /><link rel="start" href="index-2.html" title="Be Newsletters" /><link rel="up" href="volume4.html" title="Volume 4: 1999" /><link rel="prev" href="volume4.html" title="Volume 4: 1999" /><link rel="next" href="Issue4-2.html" title="Issue 4-2, January 13, 1999" /></head><body><div id="header"><div id="headerT"><div id="headerTL"><a accesskey="p" href="volume4.html" title="Volume 4: 1999"><img src="images/navigation/prev.png" alt="Prev" /></a> <a accesskey="u" href="volume4.html" title="Volume 4: 1999"><img src="images/navigation/up.png" alt="Up" /></a> <a accesskey="n" href="Issue4-2.html" title="Issue 4-2, January 13, 1999"><img src="images/navigation/next.png" alt="Next" /></a></div><div id="headerTR"><div id="navigpeople"><a href="../../index.html"><img src="images/People_24.png" alt="haiku-os.org" title="Visit The Haiku Website" /></a></div><div class="navighome" title="Home"><a accesskey="h" href="index-2.html"><img src="images/navigation/home.png" alt="Home" /></a></div><div class="navigboxed" id="naviglang" title="English">en</div></div><div id="headerTC">Be Newsletters - Volume 4: 1999</div></div><div id="headerB">Prev: <a href="volume4.html">Volume 4: 1999</a>  Up: <a href="volume4.html">Volume 4: 1999</a>  Next: <a href="Issue4-2.html">Issue 4-2, January 13, 1999</a></div><hr /></div><div class="article"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h2 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="Issue4-1"></a>Issue 4-1, January 6, 1999</h2></div></div></div><div class="sect1"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h2 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="Engineering4-1"></a>Be Engineering Insights: BFont Improvements in R4</h2></div><div xmlns:d="http://docbook.org/ns/docbook"><span xmlns="http://www.w3.org/1999/xhtml" class="author">By <span class="firstname">Pierre</span> <span class="surname">Raynaud-Richard</span></span></div></div></div><p>
Each release of the BeOS includes some new APIs (such as the Media Kit in
R4), along with a bunch of minor to major API "improvements" (or so we
like to think :-). You'll notice quite a few "extras" in the R4 <code class="classname">BFont</code>
class, many of them inspired by feature requests from developers (thanks
for taking the time to send them).
</p><div class="sect2"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="id427020"></a>New Support for Font Faces</h3></div></div></div><p>
The <code class="methodname">SetFace</code>(<span class="type">uint16</span> <code class="parameter">face</code>)
and <span class="type">uint16</span> <code class="methodname">Face()</code> APIs have been around for
awhile, but they haven't really been supported. We initially chose to
define a font by its family name (a free-form string, universally used)
and its style name (another free-form string, far less common). The main
advantage of this was that such a name could be extended without limits.
But this turned into a disadvantage, as the lack of a standard implied
that the style name and the family name could not be set as two
orthogonal options, because there was no easy way to know what styles
would be found in the given font's family.
</p><p>
The font face provides such an orthogonal choice by defining the set of
possibilities once for all, based on the OS/2 TrueType table standard:
italic, underscore, negative, outlined, strikeout, bold, and regular. The
first six can be freely combined (they are defined as one bit in a bit
mask). Regular is reserved for the standard appearance of the font and
can't be mixed with any of the other ones.
</p><p>
For completeness, <code class="methodname">SetFamilyAndStyle()</code> has been extended into
<code class="methodname">SetFamilyAndFace</code>(<span class="type">font_family</span> <code class="parameter">family</code>, <span class="type">uint16</span> <code class="parameter">face</code>).
Finally, setting a
face operates by the closest match. If a perfect match isn't available,
there will be no emulation of the missing attributes. So for example, if
you ask for Bold StrikeOut but the proper font is not installed, then you
may just get Bold. The system will not strike it out for you. That may be
improved in future releases.
</p></div><div class="sect2"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="id427093"></a>New Support for <span class="trademark">Postscript</span>™ Type 1</h3></div></div></div><p>
In R4, we enabled support for Postscript Type 1 fonts. So you may now
want to identify the file format used by a given font family:
<span class="type">font_file_format</span> <code class="methodname">FileFormat()</code>,
which returns <code class="constant">B_TRUETYPE_WINDOWS</code> or
<code class="constant">B_POSTSCRIPT_TYPE1_WINDOWS</code>. Every time the font file manager updates your
list of installed font files, it sorts them by family, creating a list of
available styles per family. You can't do this across different file
formats, though. So if, for example, you have Baskerville Regular and
Baskerville Bold in TrueType and Baskerville Italic in Postscript, you'll
see two families: Baskerville(TT) with two styles and Baskerville(PS)
with one style. This is required, as different sets of font files sharing
the same family name don't always share the same exact design and metric.
</p><p>
Also, even if Postscript Type 1 fonts are transparently supported by the
BeOS font system, we don't recommend using them as regularly as TrueType
fonts. First, because of their limited hinting, they usually render
poorly at small sizes, so it's best to avoid them for screen display.
Second, our TrueType engine's performance is still significantly better
and remains the best choice when font rendering speed is critical. Last,
because of their limitation in character encoding, you may see problems
with non-<acronym class="acronym" title="American Standard Code for Information Interchange">ASCII</acronym>
7-bit or special characters. The current compatibility
with <acronym class="acronym" title="UCS Transformation Format">UTF</acronym>8
is limited, and it's not clear what future improvements can be
made, if any at all.
</p></div><div class="sect2"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="id427145"></a>New APIs to Identify Glyph Availability</h3></div></div></div><p>
Many people rightly complained that there was no easy way—if any way
at all—to know which glyphs were available in a given font. The system
would transparently return the expected glyph or the default box, with no
complaints. As part of our increased support for localized/international
apps, we created the <span class="type">unicode_block</span> class. This object is basically a
128-bit bitfield, capable of handling basic logic operations (AND and
OR), tests (EQUAL and NOT EQUAL), and the more sophisticated "Includes".
</p><p>
The <a class="ulink" href="http://www.unicode.org/"><span class="trademark">Unicode</span>™</a>
range has been cut into 70 blocks (see list in
<code class="filename">UnicodeBlockObjects.h</code>), and
new blocks may be added in the future. For
example, you'll find the basic <acronym class="acronym">ASCII</acronym> 7-bit
block, <code class="constant">B_BASIC_LATIN_BLOCK</code>
(Unicode values 0x0000 to 0x007F), and more exotic ones like
<code class="constant">B_TIBETAN_BLOCK</code> (0x0F00 to 0x0FBF).
<code class="methodname">Blocks()</code> returns a mask of all
<span class="type">unicode_block</span>s that are even partially available in a given font. So for
example, a simple test like:
</p><pre class="programlisting cpp">
if (<code class="varname">aFont</code>-&gt;<code class="methodname">Blocks</code>().<code class="methodname">Includes</code>(<code class="constant">B_TYPICAL_JAPANESE_BLOCKS</code>))
</pre><p>
where <code class="constant">B_TYPICAL_JAPANESE_BLOCKS</code> is a bitmask (yet to be defined) that
contains all the regular Japanese <span class="type">unicode_block</span>s, indicates that
<code class="varname">aFont</code>
should include most common Japanese characters (though specific glyphs
may be missing). It's what a text editor needs to switch fonts
dynamically when the user switches between different input methods
(Hiroshi will give more details about this in a future article).
</p><p>
For people who want to go even further and know if a specific glyph is
available, <code class="methodname">GetHasGlyphs()</code> is what you need.
</p><p>
Note: The APIs discussed here are not very well supported for PS Type 1
fonts. <code class="methodname">Blocks()</code> may return approximated
results, and <code class="methodname">GetHasGlyphs()</code> is not
currently supported at all.
</p></div><div class="sect2"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="id427272"></a>Getting the Shape of a Glyph</h3></div></div></div><p>
The new <code class="methodname">GetGlyphShapes()</code> function returns the shape(s) of one or more
glyph(s), described using Bézier curves and lines. The shapes have their
origin at <code class="literal">(0.0, 0.0)</code> to allow easy linear transformation. To draw them at
the same position that a <code class="methodname">DrawString()</code> would, you need to offset them, using
the following formula:
</p><pre class="programlisting cpp">
<code class="methodname">OffsetBy</code>(<code class="function">floor</code>(<code class="varname">pen0</code>.<code class="varname">x</code>+0.5), <code class="function">floor</code>(<code class="varname">pen0</code>.<code class="varname">y</code>+0.5)-1.0);
</pre><p>
also written as:
</p><pre class="programlisting cpp">
<code class="methodname">OffsetBy</code>(<code class="function">floor</code>(<code class="varname">pen0</code>.<code class="varname">x</code>+0.5), <code class="function">floor</code>(<code class="varname">pen0</code>.<code class="varname">y</code>-0.5));
</pre><p>
<code class="code"><code class="function">floor</code>(+0.5)</code> is the rounding rule used by the app_server. The offset -1.0
on the Y axis is required to compensate for a historical mistake, now
tied to the API forever (for compatibility reasons): the bitmap images
generated by the font engine use an origin in <code class="literal">(0.0, -1.0)</code>, one line over
the normal baseline of the font. So all font drawing is done one line
higher than expected. Since all texts are placed so that they look good,
no one has noticed or complained about this during the last 18 months.
All font-related APIs take that error into account, with the exception of
this one and the font-wide bounding box (see the next paragraph), which
both describe linearly scalable objects, and must originate at <code class="literal">(0.0, 0.0)</code>.
</p></div><div class="sect2"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="id427396"></a>New APIs to Get Font and Glyph Bounding Boxes</h3></div></div></div><p>
How do we know where a <code class="methodname">DrawString()</code>
is going to draw and what area we
should erase to get a correct refresh?
</p><p>
Until R4, the only way to figure this out was by using approximated rules
based on the escapements of the glyphs; the ascent, descent, and leading
of the font, along with empirical safety margins. Such solutions had two
serious flaws. First, the ascent, descent, and leading of the font give
detailed measurements of how tall a text line should be, but don't
guarantee that the font designer didn't intentionally create glyphs so
tall that they will infringe outside their text line. Second, the
escapement does give a measurement of how much the pen position will move
after drawing the glyph, but doesn't guarantee anything about where the
glyph is really going to be drawn.
</p><p>
That's why R4 introduces new APIs, to allow efficient and accurate
processing of those bounding boxes. The first function is global to a
font: <code class="classname">BRect</code> <code class="methodname">BoundingBox()</code>.
If you draw all the glyphs of a given font and
size, one on another, you get a big blob. <code class="methodname">BoundingBox()</code> is the bounding
box of that blob. It's a floating-point scalable rectangle, the value
returned corresponding to point size 1.0. By scaling it, you can get good
approximations of the global font's printing bounding box at print time.
</p><p>
Sadly, when you draw on screen, you don't get the x4, x8, or x16
resolution increase of a printer before rounding to an integer. Also at
small sizes, hinting may try to reduce readability problems by distorting
glyphs. As a result, calculating the screen- approximated bounding box
for a given point size, based on the font's real bounding box, is a
non-trivial task. This gets even worse when you consider that around 20%
of the font files out there provide incorrect bounding box information
for the left side (don't ask me why!). As a result of extensive tests
that I ran on hundreds of common and less common fonts, I propose the
following formulas:
</p><div class="sect3"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="id427441"></a>Notations and comments:</h4></div></div></div><ul class="itemizedlist"><li><p>
<code class="varname">fBBox</code> is the <code class="methodname">BoundingBox()</code>
<code class="classname">BRect</code>. Please note that the Y axis is
oriented from bottom to top, as defined in font files. It must be
inverted to be used in a standard screen or printer coordinate system.
</p></li><li><p>
<code class="varname">pSize</code> is the selected point size.
</p></li><li><p>
<code class="varname">sBBox</code> is the estimated screen bounding box. All borders are included.
</p></li></ul></div><div class="sect3"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="id427489"></a>Regular formulas:</h4></div></div></div><pre class="programlisting cpp">
<code class="varname">sBBox</code>.<code class="varname">left</code> = <code class="function">floor</code>(<code class="varname">fBBox</code>.<code class="varname">left</code> * <code class="varname">pSize</code>)-1;
<code class="varname">sBBox</code>.<code class="varname">top</code> = <code class="function">floor</code>(-<code class="varname">fBBox</code>.<code class="varname">bottom</code> * <code class="varname">pSize</code>)-1;
<code class="varname">sBBox</code>.<code class="varname">right</code> = <code class="function">floor</code>(<code class="varname">fBBox</code>.<code class="varname">right</code> * <code class="varname">pSize</code>)+2;
<code class="varname">sBBox</code>.<code class="varname">bottom</code> = <code class="function">floor</code>(-<code class="varname">fBBox</code>.<code class="varname">top</code> * <code class="varname">pSize</code>)+2;
</pre><p>
These formulas work fine with the 80% of font files that include accurate
bounding box info. Fonts provided by operating system vendors seem to be
always compliant.
</p></div><div class="sect3"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="id427599"></a>Limited correction:</h4></div></div></div><pre class="programlisting cpp">
<code class="varname">sBBox</code>.<code class="varname">right</code> = <code class="function">floor</code>(<code class="varname">fBBox</code>.<code class="varname">right</code> * <code class="varname">pSize</code> * 1.333)+2;
</pre><p>
This formula solves the problem with 90% of the "bad fonts."
</p></div><div class="sect3"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="id426909"></a>Advanced correction:</h4></div></div></div><pre class="programlisting cpp">
<code class="varname">sBBox</code>.<code class="varname">right</code> = <code class="function">floor</code>(<code class="varname">fBBox</code>.<code class="varname">right</code> * <code class="varname">pSize</code> * 2.0)+2;
</pre><p>
This works with all the fonts I tested, except one that was also wrong on
the Y axis (I wonder why they cared about setting the bounding box
information at all...). That global bounding box allows you to calculate
an estimate of the drawing area used by <code class="methodname">DrawString()</code>.
</p></div><div class="sect3"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="id426957"></a>Notations and comments:</h4></div></div></div><ul class="itemizedlist"><li><p>
<code class="varname">total_escape</code>: sum of the escapements of all the glyphs of the string,
from the first one (included) to the last one (excluded).
</p></li><li><p>
<code class="varname">drawRect</code>: resulting bounding box for the
<code class="methodname">DrawString()</code>.
</p></li><li><p>
<code class="varname">pen0</code>: pen position when calling <code class="methodname">DrawString()</code>.
</p></li><li><p>
As <code class="varname">sBBox</code> is a scaled version of the theoretical font bounding box, we
have to take the -1.0 correction for bitmap fonts into account
ourselves (that's the only other case with <code class="methodname">GetGlyphShapes()</code>).
</p></li></ul></div><div class="sect3"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h4 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="id520530"></a>Formulas:</h4></div></div></div><pre class="programlisting cpp">
<code class="varname">drawRect</code> = <code class="varname">sBBox</code>.<code class="varname">left</code>;
<code class="varname">drawRect</code>.<code class="varname">right</code> += <code class="varname">total_escape</code>;
<code class="varname">drawRect</code>.<code class="methodname">OffsetBy</code>(<code class="function">floor</code>(<code class="varname">pen0</code>.<code class="varname">x</code>+0.5), <code class="function">floor</code>(<code class="varname">pen0</code>.<code class="varname">y</code>-0.5));
</pre><p>
The validity of <code class="varname">drawRect</code> will be as good as
that of <code class="varname">sBBox</code> (as discussed
earlier). Most of the time, it won't be the best value, but will be many
pixels wider and taller. Its advantage, though, is that it can be
processed completely on the client side by caching only one rectangle by
font (be careful, <code class="methodname">BoundingBox()</code> is not cached, so it will make a
synchronous call to the server).
</p><p>
For applications where performance isn't critical, other APIs allow you
to calculate the minimal bounding box of a glyph or a string, either on
the screen (the rectangle is rounded to an integer and takes all
distortions into account) or as printed (original floating-point values).
You can switch between the two modes by using the <span class="type">font_metric_mode</span>
parameter (<code class="constant">B_SCREEN_METRIC</code> or <code class="constant">B_PRINTING_METRIC</code>).
</p><p>
The function exists in different flavors: bounding boxes for individual
glyphs (<code class="methodname">GetBoundingBoxesAsGlyphs()</code>) or whole words
(<code class="methodname">GetBoundingBoxesAsString()</code> for a single string, or
<code class="methodname">GetBoundingBoxesForStrings()</code> to process many strings in one call). To
convert those rectangles to screen coordinates, you need to apply the
regular offset formula (no -1.0 needed):
</p><pre class="programlisting cpp">
<code class="varname">drawRect</code>.<code class="methodname">OffsetBy</code>(<code class="function">floor</code>(<code class="varname">pen0</code>.<code class="varname">x</code>+0.5), <code class="function">floor</code>(<code class="varname">pen0</code>.<code class="varname">y</code>+0.5));
</pre><p>
Results are demonstrated in the new fontDemo application shipped with R4,
by enabling the Bounding boxes option.
</p></div></div><div class="sect2"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="id429406"></a>A More Complete API to Access Font Escapements</h3></div></div></div><p>
Some developers noticed an inconsistency in our
<code class="methodname">GetEscapements()</code> API. There
was no way to get the real 2D escapement when using a rotated font. Worse
than that, the 1D value returned in that case was wrong. One work around
was to get the non-rotated escapement and apply the rotation yourself,
but then rounding errors were unavoidable. As we want perfectly accurate
positions on screen to be possible, we created a new version of
<code class="methodname">GetEscapements()</code> that returns one
<code class="classname">BPoint</code> per glyph.
</p><p>
Even beyond that, a few spacing modes (for example using dynamic kerning)
modify the real drawing origin of glyphs without changing their
escapements. For example, the width reserved for a glyph stays the same,
but it will be drawn a little more to the left to improve the overall
appearance of the string. So the most advanced version of <code class="methodname">GetEscapements()</code>
returns two <code class="classname">BPoint</code>s per glyph, one for the escapement, the other one for
the small drawing origin offset, if any.
</p></div><div class="sect2"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h3 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="id429455"></a>A Few Facts That May Interest Some of You...</h3></div></div></div><p>
The <code class="classname">BFont</code> object knows about four different spacing modes. Those were
created to allow optimal font display on screen in different cases.
<code class="constant">B_CHAR_SPACING</code> has been improved in R4 to reduce collisions between
characters at small point sizes. <code class="constant">B_STRING_SPACING</code> was not behaving very
well in Release 3, so it was almost completely rewritten for R4. The new
dynamic kerning engine is much smarter than the previous one and now
protects spaces with great care. That makes it a clear winner if you want
nice <acronym class="acronym" title="What You See Is What You Get">WYSIWYG</acronym>
text display only. It can also be used for text editing, but
that requires special, non-trivial processing to reduce jittering.
Contact me directly if you want more details...
</p><p>
Awhile ago, when we failed to meet our quality expectations with our
current fonts and B&amp;W rasterizer, we chose to keep anti-aliasing always
enabled. So <code class="constant">B_DISABLE_ANTIALIASING</code> was added for applications with
special needs. Recently, we experimented with an automatic way of
enabling/disabling anti-aliasing based on the point size and
font-specific information. The results were not satisfying, so the option
isn't in R4. The new flag <code class="constant">B_FORCE_ANTIALIASING</code>, added for completeness,
was not removed but just disabled. More news in future releases.
</p><p>
<code class="constant">B_TRUNCATE_SMART</code> has not been implemented yet... For now, it still
defaults to <code class="constant">B_TRUNCATE_MIDDLE</code>.
</p><p>
<code class="classname">BFont</code>::<code class="methodname">IsFullAndHalfFixed()</code> isn't a spelling mistake. Since Kanji
characters are much wider than most Roman characters, it's not reasonable
to create a fixed-width font with both Kanji and Roman glyphs. The
solution lies in designing Roman glyphs half the width of Kanji. Sadly,
we didn't have time to implement it for R4, and even less to add proper
support in system applications. But these things will come with time...
</p></div></div><hr class="pagebreak" /><div class="sect1"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h2 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="DevWorkshop4-1"></a>Developers' Workshop: Getting into (B)Shape</h2></div><div xmlns:d="http://docbook.org/ns/docbook"><span xmlns="http://www.w3.org/1999/xhtml" class="author">By <span class="firstname">Michael</span> <span class="surname">Morrissey</span></span></div></div></div><p>
Long-time reader and BeOS fanatic Tim Dolan recently wrote to me
regarding the new <code class="classname">BShape</code> and
<code class="classname">BShapeIterator</code> classes. “<span class="quote">From the header
file, I can see that the <code class="classname">BShape</code> class is just what I need to draw smooth
curves,</span>” Tim wrote. “<span class="quote">But I need help getting started. Can you provide
some no-frills sample code which covers the basics?</span>” Here you go, Tim:
</p><p>
ftp://ftp.be.com/pub/samples/interface_kit/Iterview.zip
</p><p>
This sample code shows how to get the outline of a text string as a
<code class="classname">BShape</code> and manipulate the control points
of the <code class="classname">BShape</code> through
<code class="classname">BShapeIterator</code>, in order to distort the text.
</p><p>
Before you dig into the sample code, take a minute to examine the
<code class="filename">Shape.h</code>
header file. The <code class="classname">BShape</code> class has four central functions, which are used
to describe a curve or path:
</p><ul class="itemizedlist"><li><p>
<code class="methodname">MoveTo()</code> moves to the specified point.
</p></li><li><p>
<code class="methodname">LineTo()</code> creates a line between the current point and the specified
point.
</p></li><li><p>
<code class="methodname">BezierTo()</code> describes a cubic Bézier curve which starts at the current
point and ends at the third point specified.
</p></li><li><p>
<code class="methodname">Close()</code> creates a line between the current point
and the first point of the <code class="classname">BShape</code>.
</p></li></ul><p>
The <code class="classname">BShapeIterator</code> class has four corresponding
functions: <code class="methodname">IterateMoveTo()</code>,
<code class="methodname">IterateLineTo()</code>,
<code class="methodname">IterateBezierTo()</code>, and
<code class="methodname">IterateClose()</code>. An additional function,
<code class="methodname">Iterate()</code>, binds them all together by stepping
through each point of the given <code class="classname">BShape</code>, calling the
appropriate <code class="methodname">Iterate...To()</code> function, and passing
it a pointer to the <code class="classname">BPoint</code> or
<code class="classname">BPoint</code>s which describe that segment of the path. For
this to be useful, you need to derive a class from the
<code class="classname">BShapeIterator</code>, replacing the
<code class="methodname">Iterate...To()</code> functions with functions that do
something interesting, such as displaying the
<code class="classname">BPoint</code>s or relocating them.
</p><p>
In the sample code, we start by creating the
<code class="classname">IterView</code> class, which inherits from both the
<code class="classname">BShapeIterator</code> class and the
<code class="classname">BView</code> class. We'll override the
<code class="methodname">Iterate...To()</code> functions and have each one draw
the control points in the view. We'll also keep lists of the control points
(one list for each of the glyphs in the text string), which will allow the
<code class="methodname">MouseDown()</code> and
<code class="methodname">MouseMoved()</code> functions to manipulate the
<code class="classname">BShape</code>.
</p><p>
We start by obtaining the outlines for the glyphs of our text in the
<code class="methodname">InitializeShapes()</code> routine:
</p><pre class="programlisting cpp">
<span class="type">void</span>
<code class="classname">IterView</code>::<code class="methodname">InitializeShapes</code>()
{
  <code class="classname">BFont</code> <code class="varname">font</code>;
  <code class="methodname">GetFont</code>(&amp;<code class="varname">font</code>);
  <code class="varname">font</code>.<code class="methodname">SetSize</code>(<code class="varname">fontSize</code>);

  <code class="varname">delta</code>.<code class="varname">nonspace</code> = 0.0;
  <code class="varname">delta</code>.<code class="varname">space</code> = 0;

  <code class="varname">font</code>.<code class="methodname">GetGlyphShapes</code>(<code class="varname">text</code>, <code class="varname">textlen</code>, <code class="varname">shapes</code>);
  <code class="varname">font</code>.<code class="methodname">GetEscapements</code>(<code class="varname">text</code>, <code class="varname">textlen</code>, &amp;<code class="varname">delta</code>, <code class="varname">esc</code>,
    <code class="varname">esc</code>+<code class="varname">textlen</code>);
}
</pre><p>
We also get the escapement values for the text, which (when multiplied by
the font size) lets us determine the placement of each glyph. This is
important, as the coordinates of each glyph shape are in absolute terms,
not relative to one another.
</p><p>
The <code class="methodname">Draw()</code> function is the heart of the matter, as
it calls the <code class="methodname">Iterate()</code> function of the
<code class="classname">BShapeIterator</code> class. Each time through the loop,
the offset point is adjusted to determine the starting point of the glyph
shape:
</p><pre class="programlisting cpp">
<span class="type">void</span>
<code class="classname">IterView</code>::<code class="methodname">Draw</code>(<code class="classname">BRect</code> <code class="parameter">R</code>)
{
  <code class="classname">BPoint</code> <code class="varname">where</code>(<code class="varname">initialPoint</code>);

  for (<span class="type">int32</span> <code class="varname">i</code>=0, <code class="varname">curShape</code>=0; <code class="varname">i</code>&lt;<code class="varname">textlen</code>; <code class="varname">i</code>++, <code class="varname">curShape</code>++)
  {
    <code class="varname">offset</code>.<code class="methodname">Set</code>(<code class="function">floor</code>(<code class="varname">where</code>.<code class="varname">x</code>+<code class="varname">esc</code>[<code class="varname">i</code>+<code class="varname">textlen</code>].<code class="varname">x</code>+0.5),
         <code class="function">floor</code>(<code class="varname">where</code>.<code class="varname">y</code>+<code class="varname">esc</code>[<code class="varname">i</code>+<code class="varname">textlen</code>].<code class="varname">y</code>+0.5)-1.0);

    <code class="methodname">MovePenTo</code>(<code class="varname">offset</code>);
    <code class="methodname">SetHighColor</code>(0,0,0);
    <code class="methodname">SetPenSize</code>(2);
    <code class="methodname">StrokeShape</code>(<code class="varname">shapes</code>[<code class="varname">i</code>]);
    <code class="methodname">SetPenSize</code>(1);

    <code class="methodname">Iterate</code>(<code class="varname">shapes</code>[<code class="varname">i</code>]);

    <code class="varname">where</code>.<code class="varname">x</code> += <code class="varname">esc</code>[<code class="varname">i</code>].<code class="varname">x</code> * <code class="varname">fontSize</code>;
    <code class="varname">where</code>.<code class="varname">y</code> += <code class="varname">esc</code>[<code class="varname">i</code>].<code class="varname">y</code> * <code class="varname">fontSize</code>;
  };

  if(<code class="varname">firstPass</code>) <code class="varname">firstPass</code> = <code class="constant">false</code>;
}
</pre><p>
For simplicity's sake, we're drawing directly to the view, rather than
off-screen. This results in flicker when dragging a control point, and is
certainly the first thing you'll want to take care of in a real
application.
</p><p>
The first time you call the <code class="methodname">Iterate()</code> function,
the <code class="varname">firstPass</code> flag is <code class="constant">true</code>, and
each <code class="methodname">Iterate...To()</code> function adds the point or
points and the offset to a <code class="classname">BList</code> of
<code class="classname">glyphPts</code> associated with that
<code class="classname">BShape</code>. For example:
</p><pre class="programlisting cpp">
<span class="type">status_t</span>
<code class="classname">IterView</code>::<code class="methodname">IterateLineTo</code>(<span class="type">int32</span> <code class="parameter">lineCount</code>, <span class="type"><code class="classname">BPoint</code> *</span><code class="parameter">linePts</code>)
{
  <code class="methodname">SetHighColor</code>(255,0,0);
  for(<span class="type">int</span> <code class="varname">i</code>=0; <code class="varname">i</code> &lt; <code class="parameter">lineCount</code>; <code class="varname">i</code>++, <code class="parameter">linePts</code>++)
  {
    <code class="methodname">FillEllipse</code>(*<code class="parameter">linePts</code>+<code class="varname">offset</code>, 2, 2);
    if(<code class="varname">firstPass</code>)
    {
      <code class="varname">shapePts</code>[<code class="varname">curShape</code>].<code class="methodname">AddItem</code>(new <code class="classname">glyphPt</code>(<code class="parameter">linePts</code>,
        <code class="varname">offset</code>));
    }
  }

  <code class="varname">currentPoint</code> = *(<code class="parameter">linePts</code>-1)+<code class="varname">offset</code>;
  return <code class="constant">B_OK</code>;
}
</pre><p>
Note that each <code class="methodname">Iterate...To()</code> function also sets
the <code class="varname">currentPoint</code>, which
is the last point of the <code class="classname">BShape</code> that was drawn.
</p><p>
The <code class="methodname">IterateBezierTo()</code> function needs a little
explanation regarding its control points. <code class="classname">BShape</code>
uses cubic Bézier curves, which means that the curve is described by
four control points; but note that <code class="methodname">BezierTo()</code> and
<code class="methodname">IterateBezierTo()</code> are given
<code class="classname">BPoint</code>s in groups of three, not four. The first
control point is the point of the <code class="classname">BShape</code> immediately
preceding the <code class="methodname">BezierTo()</code> call; this point is not
explicitly passed into <code class="methodname">BezierTo()</code> or
<code class="methodname">IterateBezierTo()</code>. The last control point is the
endpoint of the curve. The two intermediate control points determine the
shape and amplitude of the curve between the first and fourth control
points.
</p><p>
The <code class="methodname">MouseDown()</code> function starts by determining if
the mouse down point falls inside the bounding box of a
<code class="classname">BShape</code>. If it does, it then searches the list of
<code class="classname">glyphPts</code> associated with that
<code class="classname">BShape</code> to determine if the mouse point is within a
small distance of one of the control points. During this search, we need to
take into account the offset of our <code class="classname">BShape</code>. If a
point is found, we set the <code class="varname">isTracking</code> flag to
<code class="constant">true</code>, and set <code class="varname">dragPoint</code> to the
selected control point.
</p><p>
If <code class="varname">isTracking</code> is <code class="constant">true</code> and we enter
the <code class="methodname">MouseMoved()</code> function, we change
the position of the chosen control point (once again taking into account
the offset) and Invalidate the view:
</p><pre class="programlisting cpp">
<span class="type">void</span>
<code class="classname">IterView</code>::<code class="methodname">MouseMoved</code>(<code class="classname">BPoint</code> <code class="parameter">pt</code>, <span class="type">uint32</span> <code class="parameter">code</code>,
  <span class="type">const<code class="classname">BMessage</code> *</span><code class="parameter">msg</code>)
{
  if(<code class="varname">isTracking</code> == <code class="constant">false</code>) return;

  *(<code class="varname">dragPoint</code>-&gt;<code class="varname">pt</code>) = (<code class="parameter">pt</code> - <code class="varname">dragPoint</code>-&gt;<code class="varname">offset</code>);
  <code class="methodname">Invalidate</code>();
}
</pre><p>
There are many interesting things you can do with
<code class="classname">BShapes</code> and <code class="classname">BShapeIterators</code>.
Most obviously, they make excellent drawing primitives, which let you
accurately and flexibly describe complex curves. You can create wonderful
effects or even animations by applying various transformations to the
<code class="classname">BShape</code>, especially for text. You can also clip to
<code class="classname">BShape</code>s: just create a
<code class="classname">BPicture</code> for your <code class="classname">BShape</code>,
display an interesting pattern or bitmap, call
<code class="classname">BView</code>::<code class="methodname">ClipToPicture()</code>, and you've got an amazing
effect for just a few lines of code.
</p><p>
Now that you've seen the possibilities, make it your New Year's
resolution to get into <code class="classname">BShape</code>!
</p></div><hr class="pagebreak" /><div class="sect1"><div xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="titlepage"><div><div xmlns:d="http://docbook.org/ns/docbook"><h2 xmlns="http://www.w3.org/1999/xhtml" class="title"><a id="Gassee4-1"></a>New Year Business Models</h2></div><div xmlns:d="http://docbook.org/ns/docbook"><span xmlns="http://www.w3.org/1999/xhtml" class="author">By <span class="firstname">Jean-Louis</span> <span class="surname">Gassée</span></span></div></div></div><p>
I spent some time in the Old Country over the holidays, seeing family and
friends, visiting Mont Saint-Michel and the Louvre, and sharing the
merriment at the birth of the Euro. While I was there, I also got to
enjoy the feedback our work gets in Europe. As I write this, I've just
heard from Jean Calmon that the BeOS got the top award from PC Expert,
the French version of PC Magazine, coming in ahead of Windows 98 and
DirectX. We appreciate the recognition, not least of all because it helps
us further our gains with software developers, resellers, and end users.
</p><p>
Not that there aren't still skeptics, but this time they weren't humming
the "Microsoft über alles" leitmotif. No, they were cheekier and a little
more creative. One doubter offered to license his secret plan for going
public in six months or less. Instead of continuing with the obsolete
French Farmer business model, you build a business, make money, and then
sell shares of future profits in order to finance growth and make your
anticipated earnings real.
</p><p>
The plan goes like this: build a simple but tasteful Web site and use it
to sell dollar bills, one at a time, for 70 cents each. Yes, he agrees,
you'll lose money on each transaction, but think of the traffic you'll
build! From that high-volume traffic, you'll generate revenues well above
your transaction losses. Even taking postage and handling into account,
you'll be profitable before the investment bankers can park their
<acronym class="acronym" title="Bavarian Motor Works">BMW</acronym>s
behind your office. Then you can have an old-fashioned
<acronym class="acronym" title="Initial Public Offering">IPO</acronym> to finance
further growth. You can vary the plan—sell stamps at less than face
value, offer special editions for advertisers. The Web frenzy will keep
the stock climbing post-<acronym class="acronym">IPO</acronym>.
</p><p>
When I protested, I was chided for not seeing that this was equivalent to
free e-mail. You provide something for less than it costs, but with
better returns. Dollar bills scale up more easily than mail servers. They
require little maintenance and users need no tech support.
</p><p>
Another (French) acquaintance had an explanation for eBay's greater-than
5000 P/E ratio. He described the following "virtuous" circle. In order to
keep the stock price in the stratosphere, the founders sell a little
stock, enough to buy everything that's not snapped up by eBay users. They
put all the junk in containers and dump it in the Bay (hence the company
name). Users are thrilled. The word of mouth is terrific and attracts
more users. The stock keeps climbing and the loop is closed.
</p><p>
Now, there are a couple of professional flea markets around Paris, but
garage sales aren't part of the culture. Merchants who need stuff to sell
advertise that they'll come to your house and, as a service, empty your
cellar and attic of all its bizarre and embarrassing junk. eBay, my wine
bistro companion explained, performs a similarly valuable service by
taking a modest amount of money from the stock market and using it as an
incentive for people to clean their closets and garages. Everyone
benefits from putting the stock market and cyberspace at the service of
New Year resolutions.
</p><p>
My own resolution is never to appear to endorse such unseemly views of
respectable industry trends. As we say in my adopted language, this is a
game of confidence, or something like that. We cannot allow disparaging
satire or infelicitous irony to undermine the glorious edifice of trust
in the new business models.
</p><p>
More seriously, a very Happy New Year to all the members of the Be
extended family, with our best wishes for personal and professional
realization.
</p></div></div><div id="footer"><hr /><div id="footerT">Prev: <a href="volume4.html">Volume 4: 1999</a>  Up: <a href="volume4.html">Volume 4: 1999</a>  Next: <a href="Issue4-2.html">Issue 4-2, January 13, 1999</a> </div><div id="footerB"><div id="footerBL"><a href="volume4.html" title="Volume 4: 1999"><img src="images/navigation/prev.png" alt="Prev" /></a> <a href="volume4.html" title="Volume 4: 1999"><img src="images/navigation/up.png" alt="Up" /></a> <a href="Issue4-2.html" title="Issue 4-2, January 13, 1999"><img src="images/navigation/next.png" alt="Next" /></a></div><div id="footerBR"><div><a href="../../index.html"><img src="images/People_24.png" alt="haiku-os.org" title="Visit The Haiku Website" /></a></div><div class="navighome" title="Home"><a accesskey="h" href="index-2.html"><img src="images/navigation/home.png" alt="Home" /></a></div></div><div id="footerBC"><a href="http://www.access-company.com/home.html" title="ACCESS Co."><img alt="Access Company" src="images/access_logo.png" /></a></div></div></div><div id="licenseFooter"><div id="licenseFooterBL"><a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/3.0/" title="Creative Commons License"><img alt="Creative Commons License" style="border-width:0" src="../../../licensebuttons.net/l/by-nc-nd/3.0/88x31.png" /></a></div><div id="licenseFooterBR"><a href="LegalNotice.html">Legal Notice</a></div><div id="licenseFooterBC"><span id="licenseText">This work is licensed under a
          <a rel="license" href="http://creativecommons.org/licenses/by-nc-nd/3.0/">Creative
          Commons Attribution-Non commercial-No Derivative Works 3.0 License</a>.</span></div></div><!-- Fathom -->
<script>
(function(f, a, t, h, o, m){
	a[h]=a[h]||function(){
		(a[h].q=a[h].q||[]).push(arguments)
	};
	o=f.createElement('script'),
	m=f.getElementsByTagName('script')[0];
	o.async=1; o.src=t; o.id='fathom-script';
	m.parentNode.insertBefore(o,m)
})(document, window, '../../../metrics.haiku-os.org/tracker.js', 'fathom');
fathom('trackPageview');
</script>
<!-- / Fathom --></body>
<!-- Mirrored from www.haiku-os.org/legacy-docs/benewsletter/Issue4-1.html by HTTrack Website Copier/3.x [XR&CO'2014], Thu, 05 Aug 2021 01:42:03 GMT -->
</html>
